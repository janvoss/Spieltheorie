[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Spieltheorie und Verhaltensökonomik",
    "section": "",
    "text": "\\({}\\)\n\\({}\\)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOrganisatorisches\n\n\n\n\n\n\nUnterlagen: https://janvoss.github.io/Spieltheorie/\nModul: 209-031 Sustainable Co-Creation (Green Startups, Planet Centric Design, Spieltheorie, Verhaltensökonomik) (Modulhandbuch)\nWeitere Veranstaltung im ModuL: Sustainable Co-Creation\nPrüfungsleistung: K60,diese VL (50% des Moduls)",
    "crumbs": [
      "Organisatorisches"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Einleitung",
    "section": "",
    "text": "1.1 Modul: Analyse von Kooperations- und Konfliktstrukturen",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "Literatur.html",
    "href": "Literatur.html",
    "title": "Literatur",
    "section": "",
    "text": "Beck, Hanno. 2014. Behavioral Economics: Eine Einführung. Wiesbaden.\n\n\nBerninghaus, Siegfried K., Karl-Martin Ehrhart, and Werner Güth. 2010. Strategische Spiele. Springer-Lehrbuch. Berlin, Heidelberg: Springer. https://doi.org/10.1007/978-3-642-11651-3.\n\n\nDetel, Wolfgang. 2007. Grundkurs Philosophie. Band 5: Philosophie des Sozialen. Stuttgart.\n\n\nGigerenzer, Gerd. 2018. “The Bias Bias in Behavioral Economics.” Review of Behavioral Economics 5: 303–36.\n\n\nHoller, Manfred J., Gerhard Illing, and Stefan Napel. 2019. Einführung in die Spieltheorie. Berlin, Heidelberg: Springer. https://doi.org/10.1007/978-3-642-31963-1.\n\n\nJust, David R. 2014. Introduction to Behavioral Economics. Noneconomic Factors That Shape Economic Decisions. Hoboken NJ.\n\n\nLee, Dwight R., and J. R. Clark. 2017. “Can Behavioral Economists Improve Economic Rationality?” Public Choice 174: 1–18.\n\n\nMusgrave, Allen. 1981. “Unreal Assumptions in Economic Theory. The f-Twist Untwisted.” Kyklos 34: 377–87.\n\n\nWeintraub, E. Roy. 2017. “Game Theory and Cold War Rationality: A Review Essay.” Journal of Economic Literature 55: 148–61.\n\n\nWinter, Stefan. 2019. Grundzüge der Spieltheorie. Ein Lehr- und Arbeitsbuch für das (Selbst-)Studium. Berlin Heidelberg.",
    "crumbs": [
      "Literatur"
    ]
  },
  {
    "objectID": "intro.html#ökomomische-modellierung-menschlichen-verhaltens",
    "href": "intro.html#ökomomische-modellierung-menschlichen-verhaltens",
    "title": "1  Einleitung",
    "section": "",
    "text": "Methodologischer Individualismus\n\nSituationslogik erlaubt Verknüpfung von Situation, Zielen und Handlung\nRationalität\n\nStrenge Rationalität\nBeschränkte Rationalität\nVerhaltensökonomik\n\nRationalität als Konzept\nRationalität als Behauptung über einen Sachverhalt\nRationalität als Analysegrammatik",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "intro.html#formen-des-wettbewerbs",
    "href": "intro.html#formen-des-wettbewerbs",
    "title": "1  Einleitung",
    "section": "1.2 Formen des Wettbewerbs",
    "text": "1.2 Formen des Wettbewerbs\n-Vollkommener Wettbewerb auf Märkten - Innovationswettbewerb - Entdeckungswettbewerb - \\(\\dots\\)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "intro.html#arenen-des-wettbewerbs",
    "href": "intro.html#arenen-des-wettbewerbs",
    "title": "1  Einleitung",
    "section": "1.3 Arenen des Wettbewerbs",
    "text": "1.3 Arenen des Wettbewerbs\n\nMärkte\nOrganisationen\n\ndurch Märkte diszipliniert (Unternehmen)\nnicht durch Märkte diszipliniert (Behörden, Vereine, \\(\\dots\\))",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "intro.html#fazit-zum-modul",
    "href": "intro.html#fazit-zum-modul",
    "title": "1  Einleitung",
    "section": "1.4 Fazit zum Modul",
    "text": "1.4 Fazit zum Modul\n\\(\\rightarrow\\) Im Modul befassen wir uns mit Wettbewerb in unterschiedlichen Kontexten\n\\(\\rightarrow\\) Basis der Überlegungen sind (unterschiedliche) Konzepte über menschliches Verhalten",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "Rationalitaet.html",
    "href": "Rationalitaet.html",
    "title": "2  Rationalität",
    "section": "",
    "text": "2.1 Basisschema der Handlungserklärung\nDas Folgende ist fast wörtlich aus Detel (2007) S. 20 übernommen.\nDas Basisschema ist noch unvollständig:\n\\(\\Rightarrow\\) erweitertes Schema der Handlungserklärung",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Rationalität</span>"
    ]
  },
  {
    "objectID": "Rationalitaet.html#basisschema-der-handlungserklärung",
    "href": "Rationalitaet.html#basisschema-der-handlungserklärung",
    "title": "2  Rationalität",
    "section": "",
    "text": "Person \\(S\\) wünscht, Ziel \\(Z\\) zu realisieren.\n\\(S\\) glaubt, die Handlung \\(H\\) sei ein Mittel, um \\(Z\\) zu realisieren.\n\\(S\\) vollzieht Handlung \\(H\\).\n\n\n\nWas ist, wenn es für \\(S\\) bessere Handlungen als \\(H\\) gibt, \\(Z\\) zu realisieren? Dann wäre es nicht vernünftig, \\(H\\) zu vollziehen.\nWas ist, wenn es \\(S\\) \\(H\\) gar nicht vollziehen kann?\nWas ist, wenn \\(H\\) mit negativen Folgen einhergeht, die schlimmer sind, als \\(Z\\) nicht zu realisieren?\nWas ist, wenn \\(S\\) noch weitere Ziele realisieren will, die mit \\(Z\\) nicht vereinbar sind?",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Rationalität</span>"
    ]
  },
  {
    "objectID": "Rationalitaet.html#erweitertes-schema-der-handlungserklärung",
    "href": "Rationalitaet.html#erweitertes-schema-der-handlungserklärung",
    "title": "2  Rationalität",
    "section": "2.2 Erweitertes Schema der Handlungserklärung",
    "text": "2.2 Erweitertes Schema der Handlungserklärung\n\n\\(S\\) hat die Absicht, Ziel \\(Z\\) zu realisieren.\n\\(S\\) glaubt, dass, wenn sie Handlung \\(H\\) vollzieht, sie somit \\(Z\\) realisieren kann.\n\\(S\\) glaubt in der Lage zu sein, \\(Z\\) zu realisieren und \\(H\\) zu vollziehen.\n\\(S\\) weiß, wie man \\(Z\\) realisiert und \\(H\\) vollzieht.\n\\(S\\) glaubt nicht, dass es etwas Besseres gibt als \\(H\\), um \\(Z\\) zu realisieren.\n\\(S\\) glaubt nicht, dass der Vollzug von \\(H\\) Folgen hat, die schlimmer sind als nicht \\(Z\\) realisieren zu können.\n\\(S\\) hat nicht die Absicht, ein Ziel zu realisieren, von dem \\(S\\) weiß, dass es unvereinbar damit ist, \\(Z\\) zu realisieren, und das sie \\(Z\\) gegenüber vorzieht.\n\\(S\\) vollzieht Handlung \\(H\\).",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Rationalität</span>"
    ]
  },
  {
    "objectID": "Rationalitaet.html#zwischenfazit",
    "href": "Rationalitaet.html#zwischenfazit",
    "title": "2  Rationalität",
    "section": "2.3 Zwischenfazit",
    "text": "2.3 Zwischenfazit\n\nErklärungen rationaler Handlungen unterstellen nicht zwangsläufig, dass die handelnde Person “alles richtig” macht.\nInsbesondere lässt es beschränkte Handlungsmöglichkeiten zu und unvollständige oder fehlerhafte Informationslagen.\nDas Rationalprinzip ist weniger eine Behauptung über die handelnde Person, sondern ein Schema, eine “Grammatik” der Erklärung.\nDiese Grammatik verwenden wir sowohl in der Spieltheorie als auch in der Verhaltensökonomik\n\nSchwerpunkt Spieltheorie: Individuen handeln nach (dem richtigen) mathematischen Kalkül und machen höchstens zufällig Fehler\n\nSchwerpunkt Verhaltensökonomik: Individuen handeln nachvollziehbar, aber nach Kalkülen, die nicht ganz “richtig” sind.\n\n\n\n\n\n\nDetel, Wolfgang. 2007. Grundkurs Philosophie. Band 5: Philosophie des Sozialen. Stuttgart.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Rationalität</span>"
    ]
  },
  {
    "objectID": "Spieltheorie.html",
    "href": "Spieltheorie.html",
    "title": "3  Nicht-kooperative Spieltheorie",
    "section": "",
    "text": "3.1 Einleitung und begriffliche Einordnung",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Nicht-kooperative Spieltheorie</span>"
    ]
  },
  {
    "objectID": "Spieltheorie.html#das-nash-gleichgewicht",
    "href": "Spieltheorie.html#das-nash-gleichgewicht",
    "title": "3  Nicht-kooperative Spieltheorie",
    "section": "3.2 Das Nash-Gleichgewicht",
    "text": "3.2 Das Nash-Gleichgewicht",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Nicht-kooperative Spieltheorie</span>"
    ]
  },
  {
    "objectID": "Spieltheorie.html#simultane-spiele",
    "href": "Spieltheorie.html#simultane-spiele",
    "title": "3  Nicht-kooperative Spieltheorie",
    "section": "3.2 Simultane Spiele",
    "text": "3.2 Simultane Spiele\n\n3.2.1 Grundsätzliche Struktur eines Spiels\n\n\nCode\nfrom lets_plot import *\n\nLetsPlot.setup_html()\n\nggplot() + \\\ngeom_text(x=- .5, y= 2   , label='a') +\\\ngeom_text(x=-1.5, y=  .75, label='A') +\\\ngeom_text(x=- .5, y=-1   , label='b') +\\\ngeom_text(x=-1.5, y=-2.25, label='B') +\\\ngeom_text(x= 1.5, y= 2   , label='c') +\\\ngeom_text(x=  .5, y=  .75, label='C') +\\\ngeom_text(x= 1.5, y=-1   , label='d') +\\\ngeom_text(x=  .5, y=-2.25, label='D') +\\\ngeom_text(x=-1  , y= 3.3 , label='links')+\\\ngeom_text(x= 1  , y= 3.3 , label='rechts')+\\\ngeom_text(x=-2.2, y= 1.375, angle=90, label='oben')+\\\ngeom_text(x=-2.2, y=-1.625, angle=90, label='unten')+\\\ngeom_text(x= 0 , y= 4 ,\n          fontface = \"bold\", label='Spieler 2')+\\\ngeom_text(x=-2.7 , y= 0 , angle=90,\n          fontface = \"bold\", label='Spieler 1')+\\\ngeom_segment(x=-2,  xend= 2, y= 0, yend= 0) +\\\ngeom_segment(x=-2,  xend= 2, y= 3, yend= 3) +\\\ngeom_segment(x=-2,  xend= 2, y=-3, yend=-3) +\\\ngeom_segment(x=-2,  xend=-2, y=-3, yend= 3) +\\\ngeom_segment(x= 0,  xend= 0, y=-3, yend= 3) +\\\ngeom_segment(x= 2,  xend= 2, y=-3, yend= 3) +\\\ntheme_void()+\\\nlabs(title='Auszahlungen in einem simultanen Spiel' #,\n    # caption = 'Caption'\n)\n\n\n\n            \n            \n            \n\n\n   \n   \n\n\n\n\n3.2.2 Reine Strategien\n\n3.2.2.1 Definition Nash-Gleichgewicht\nEin Nash-Gleichgewicht liegt vor, wenn jeder Spieler die beste Antwort auf die beste Strategie des Gegenspielers spielt.\nFormal:\n\\(u_{i}\\left(s_{i}^{*},s_{-i}^{*}\\right)\\geq u_{i}\\left(s_{i},s_{-i}^{*}\\right)\\mbox{ für alle }i,\\mbox{ }s_{i}\\in S_{i}\\)\nIntuition: Ein Nash-Gleichgewicht liegt vor, wenn kein Spieler mehr die Möglichkeit hat, seine Situation durch eine nur eigene Entscheidungsänderung zu verbessern.\nIn der Matrix oben heißt dass, das geprüft werden muss\n\\(A \\geq B \\land a \\geq c\\) \\(\\rightarrow\\) ol\n\\(B \\geq A \\land b \\geq d\\) \\(\\rightarrow\\) ul\n\\(C \\geq D \\land c \\geq a\\) \\(\\rightarrow\\) or\n\\(D \\geq C \\land d \\geq b\\) \\(\\rightarrow\\) ur\nEs kann kein oder ein Nash-Gleichgewicht existieren oder mehrere Nash-Gleichgewichte\n\n\n3.2.2.2 Einperiodige Spiele\n\n\nCode\nimport numpy as np\n\nimport random\n\n# Zufällige Ganzzahlen zwischen 0 und 9 generieren\n\nrandom.seed(123)\n\nA = random.randint(0, 9)\nB = random.randint(0, 9)\nC = random.randint(0, 9)\nD = random.randint(0, 9)\na = random.randint(0, 9)\nb = random.randint(0, 9)\nc = random.randint(0, 9)\nd = random.randint(0, 9)\n\n# Formatierte Bimatrix ausgeben\n# print(f\"     l    r\\n o  {A},{a}  {C},{c}\\n # u  {B},{b}  {D},{d}\")\n\nfrom lets_plot import *\n\nLetsPlot.setup_html()\n\nggplot() + \\\ngeom_text(x=- .5, y= 2   , label=a) +\\\ngeom_text(x=-1.5, y=  .75, label=A) +\\\ngeom_text(x=- .5, y=-1   , label=b) +\\\ngeom_text(x=-1.5, y=-2.25, label=B) +\\\ngeom_text(x= 1.5, y= 2   , label=c) +\\\ngeom_text(x=  .5, y=  .75, label=C) +\\\ngeom_text(x= 1.5, y=-1   , label=d) +\\\ngeom_text(x=  .5, y=-2.25, label=D) +\\\ngeom_text(x=-1  , y= 3.3 , label='links')+\\\ngeom_text(x= 1  , y= 3.3 , label='rechts')+\\\ngeom_text(x=-2.2, y= 1.375, angle=90, label='oben')+\\\ngeom_text(x=-2.2, y=-1.625, angle=90, label='unten')+\\\ngeom_text(x= 0 , y= 4 ,\n          fontface = \"bold\", label='Spieler 2')+\\\ngeom_text(x=-2.7 , y= 0 , angle=90,\n          fontface = \"bold\", label='Spieler 1')+\\\ngeom_segment(x=-2,  xend= 2, y= 0, yend= 0) +\\\ngeom_segment(x=-2,  xend= 2, y= 3, yend= 3) +\\\ngeom_segment(x=-2,  xend= 2, y=-3, yend=-3) +\\\ngeom_segment(x=-2,  xend=-2, y=-3, yend= 3) +\\\ngeom_segment(x= 0,  xend= 0, y=-3, yend= 3) +\\\ngeom_segment(x= 2,  xend= 2, y=-3, yend= 3) +\\\ntheme_void()+\\\nlabs(title='Auszahlungen in einem simultanen Spiel')\n\n\n\n            \n            \n            \n\n\n   \n   \n\n\n\n\nCode\n# Funktionen für Nash-Bedingungen\ndef is_ol_nash(A, B, a, c):\n  return \"ol\" if (A &gt;= B) and (a &gt;= c) else \"not_ol\"\n\ndef is_ul_nash(B, A, b, d):\n  return \"ul\" if (B &gt;= A) and (b &gt;= d) else \"not_ul\"\n\ndef is_or_nash(C, D, c, a):\n  return \"or\" if (C &gt;= D) and (c &gt;= a) else \"not_or\"\n\ndef is_ur_nash(D, C, d, b):\n  return \"ur\" if (D &gt;= C) and (d &gt;= b) else \"not_ur\"\n\n# Nash-Bedingungen überprüfen und Strings zuweisen\nCand_Nash_ol = is_ol_nash(A, B, a, c)\nCand_Nash_ul = is_ul_nash(B, A, b, d)\nCand_Nash_or = is_or_nash(C, D, c, a)\nCand_Nash_ur = is_ur_nash(D, C, d, b)\n\n# Ergebnisse kombinieren und NAs entfernen\nNash_GG = np.array([Cand_Nash_ol, Cand_Nash_ul, Cand_Nash_or, Cand_Nash_ur])\nNash_GG_filtered = []\nfor element in Nash_GG:\n  if element == \"ol\" or element == \"ul\" or element == \"or\" or element == \"ur\":\n    Nash_GG_filtered.append(element)\n\n# Ergebnis ausgeben\n#print(Nash_GG_filtered)\n\n\n\n\nCode\nprint(f\"Nash-Gleichgewicht(e) in reinen Strategien: {', '.join(Nash_GG_filtered)}\")\n\n\nNash-Gleichgewicht(e) in reinen Strategien: ur\n\n\n\n3.2.2.2.1 Koordinationsspiel\n\n\nCode\nimport numpy as np\n\nimport random\n\nrandom.seed(123)\n\n# Zufällige Ganzzahlen zwischen 0 und 9 generieren\nA = 0\nB = random.randint(1, 9)\nC = B\nD = A\na = A\nb = B\nc = C\nd = D\n\n# Formatierte Bimatrix ausgeben\n#print(f\"     l    r\\n o  #{A},{a}  {C},{c}\\n u  {B},{b} # {D},{d}\")\n\n\ndef create_plot():\n    LetsPlot.setup_html()\n    return (\n        ggplot() +\n        geom_text(x=-0.5, y=2, label=a) +\n        geom_text(x=-1.5, y=0.75, label=A) +\n        geom_text(x=-0.5, y=-1, label=b) +\n        geom_text(x=-1.5, y=-2.25, label=B) +\n        geom_text(x=1.5, y=2, label=c) +\n        geom_text(x=0.5, y=0.75, label=C) +\n        geom_text(x=1.5, y=-1, label=d) +\n        geom_text(x=0.5, y=-2.25, label=D) +\n        geom_text(x=-1, y=3.3, label='links') +\n        geom_text(x=1, y=3.3, label='rechts') +\n        geom_text(x=-2.2, y=1.375, angle=90, label='oben') +\n        geom_text(x=-2.2, y=-1.625, angle=90, label='unten') +\n        geom_text(x=0 , y=4 , fontface=\"bold\", label='Spieler 2') +\n        geom_text(x=-2.7 , y=0 , angle=90 , fontface=\"bold\", label='Spieler 1') +\n        geom_segment(x=-2, xend=2, y=0, yend=0) +\n        geom_segment(x=-2, xend=2, y=3, yend=3) +\n        geom_segment(x=-2, xend=2, y=-3, yend=-3) +\n        geom_segment(x=-2, xend=-2, y=-3, yend=3) +\n        geom_segment(x=0 , xend=0 , y=-3 , yend=3) +\n        geom_segment(x=2 , xend=2 , y=-3 , yend=3) +\n        theme_void() +\n        labs(title='Auszahlungen in einem simultanen Spiel')\n    )\n\n    \nplot = create_plot()\n\nplot\n\n\n\n            \n            \n            \n\n\n   \n   \n\n\n\n\nCode\n# Funktionen für Nash-Bedingungen\ndef is_ol_nash(A, B, a, c):\n  return \"ol\" if (A &gt;= B) and (a &gt;= c) else \"not_ol\"\n\ndef is_ul_nash(B, A, b, d):\n  return \"ul\" if (B &gt;= A) and (b &gt;= d) else \"not_ul\"\n\ndef is_or_nash(C, D, c, a):\n  return \"or\" if (C &gt;= D) and (c &gt;= a) else \"not_or\"\n\ndef is_ur_nash(D, C, d, b):\n  return \"ur\" if (D &gt;= C) and (d &gt;= b) else \"not_ur\"\n\n# Nash-Bedingungen überprüfen und Strings zuweisen\nCand_Nash_ol = is_ol_nash(A, B, a, c)\nCand_Nash_ul = is_ul_nash(B, A, b, d)\nCand_Nash_or = is_or_nash(C, D, c, a)\nCand_Nash_ur = is_ur_nash(D, C, d, b)\n\n# Ergebnisse kombinieren und NAs entfernen\nNash_GG = np.array([Cand_Nash_ol, Cand_Nash_ul, Cand_Nash_or, Cand_Nash_ur])\nNash_GG_filtered = []\nfor element in Nash_GG:\n  if element == \"ol\" or element == \"ul\" or element == \"or\" or element == \"ur\":\n    Nash_GG_filtered.append(element)\n\n# Ergebnis ausgeben\nprint(f\"Nash-Gleichgewicht(e) in reinen Strategien: {', '.join(Nash_GG_filtered)}\")\n\n\nNash-Gleichgewicht(e) in reinen Strategien: ul, or\n\n\n\n\n3.2.2.2.2 Chicken Game\n\n\nCode\nimport numpy as np\n\nimport random\n\n# Zufällige Ganzzahlen zwischen 0 und 9 generieren\nA = random.randint(5, 7)\nB = random.randint(8, 9)\nC = random.randint(2, 4)\nD = random.randint(0, 1)\na = random.randint(5, 7)\nb = random.randint(2, 4)\nc = random.randint(8, 9)\nd = random.randint(0, 1)\n\n# Formatierte Bimatrix ausgeben\n# print(f\"     l    r\\n o  {A},{a}  {C},{c}\\n u  {B},{b}  {D},{d}\")\n\nplot = create_plot()\n\nplot\n\n\n\n            \n            \n            \n\n\n   \n   \n\n\n\n\nCode\n# Funktionen für Nash-Bedingungen\ndef is_ol_nash(A, B, a, c):\n  return \"ol\" if (A &gt;= B) and (a &gt;= c) else \"not_ol\"\n\ndef is_ul_nash(B, A, b, d):\n  return \"ul\" if (B &gt;= A) and (b &gt;= d) else \"not_ul\"\n\ndef is_or_nash(C, D, c, a):\n  return \"or\" if (C &gt;= D) and (c &gt;= a) else \"not_or\"\n\ndef is_ur_nash(D, C, d, b):\n  return \"ur\" if (D &gt;= C) and (d &gt;= b) else \"not_ur\"\n\n# Nash-Bedingungen überprüfen und Strings zuweisen\nCand_Nash_ol = is_ol_nash(A, B, a, c)\nCand_Nash_ul = is_ul_nash(B, A, b, d)\nCand_Nash_or = is_or_nash(C, D, c, a)\nCand_Nash_ur = is_ur_nash(D, C, d, b)\n\n# Ergebnisse kombinieren und NAs entfernen\nNash_GG = np.array([Cand_Nash_ol, Cand_Nash_ul, Cand_Nash_or, Cand_Nash_ur])\nNash_GG_filtered = []\nfor element in Nash_GG:\n  if element == \"ol\" or element == \"ul\" or element == \"or\" or element == \"ur\":\n    Nash_GG_filtered.append(element)\n\n# Ergebnis ausgeben\nprint(f\"Nash-Gleichgewicht(e) in reinen Strategien: {', '.join(Nash_GG_filtered)}\")\n\n\nNash-Gleichgewicht(e) in reinen Strategien: ul, or\n\n\n\n\n3.2.2.2.3 Geschlechterkampf\n\n\nCode\nimport numpy as np\n\nimport random\n\n# Zufällige Ganzzahlen zwischen 0 und 9 generieren\nA = random.randint(8, 9)\nB = random.randint(0, 2)\nC = random.randint(3, 5)\nD = random.randint(6, 7)\na = random.randint(6, 7)\nb = random.randint(0, 2)\nc = random.randint(3, 5)\nd = random.randint(8, 9)\n\n# Formatierte Bimatrix ausgeben\n# print(f\"     l    r\\n o  {A},{a}  {C},{c}\\n u  {B},{b}  {D},{d}\")\n\nplot = create_plot()\n\nplot\n\n\n\n            \n            \n            \n\n\n   \n   \n\n\n\n\nCode\n# Funktionen für Nash-Bedingungen\ndef is_ol_nash(A, B, a, c):\n  return \"ol\" if (A &gt;= B) and (a &gt;= c) else \"not_ol\"\n\ndef is_ul_nash(B, A, b, d):\n  return \"ul\" if (B &gt;= A) and (b &gt;= d) else \"not_ul\"\n\ndef is_or_nash(C, D, c, a):\n  return \"or\" if (C &gt;= D) and (c &gt;= a) else \"not_or\"\n\ndef is_ur_nash(D, C, d, b):\n  return \"ur\" if (D &gt;= C) and (d &gt;= b) else \"not_ur\"\n\n# Nash-Bedingungen überprüfen und Strings zuweisen\nCand_Nash_ol = is_ol_nash(A, B, a, c)\nCand_Nash_ul = is_ul_nash(B, A, b, d)\nCand_Nash_or = is_or_nash(C, D, c, a)\nCand_Nash_ur = is_ur_nash(D, C, d, b)\n\n# Ergebnisse kombinieren und NAs entfernen\nNash_GG = np.array([Cand_Nash_ol, Cand_Nash_ul, Cand_Nash_or, Cand_Nash_ur])\nNash_GG_filtered = []\nfor element in Nash_GG:\n  if element == \"ol\" or element == \"ul\" or element == \"or\" or element == \"ur\":\n    Nash_GG_filtered.append(element)\n\n# Ergebnis ausgeben\nprint(f\"Nash-Gleichgewicht(e) in reinen Strategien: {', '.join(Nash_GG_filtered)}\")\n\n\nNash-Gleichgewicht(e) in reinen Strategien: ol, ur\n\n\n\n\n3.2.2.2.4 Gefangenendilemma\n\n\nCode\nimport numpy as np\n\nimport random\n\n# Zufällige Ganzzahlen zwischen 0 und 9 generieren\nA = random.randint(5, 7)\nB = random.randint(8, 9)\nC = random.randint(0, 1)\nD = random.randint(2, 4)\na = random.randint(5, 7)\nb = random.randint(0, 1)\nc = random.randint(8, 9)\nd = random.randint(2, 4)\n\n# Formatierte Bimatrix ausgeben\n# print(f\"     l    r\\n o  {A},{a}  {C},{c}\\n u  {B},{b}  {D},{d}\")\n\nplot = create_plot()\n\nplot\n\n\n\n            \n            \n            \n\n\n   \n   \n\n\n\n\nCode\n# Funktionen für Nash-Bedingungen\ndef is_ol_nash(A, B, a, c):\n  return \"ol\" if (A &gt;= B) and (a &gt;= c) else \"not_ol\"\n\ndef is_ul_nash(B, A, b, d):\n  return \"ul\" if (B &gt;= A) and (b &gt;= d) else \"not_ul\"\n\ndef is_or_nash(C, D, c, a):\n  return \"or\" if (C &gt;= D) and (c &gt;= a) else \"not_or\"\n\ndef is_ur_nash(D, C, d, b):\n  return \"ur\" if (D &gt;= C) and (d &gt;= b) else \"not_ur\"\n\n# Nash-Bedingungen überprüfen und Strings zuweisen\nCand_Nash_ol = is_ol_nash(A, B, a, c)\nCand_Nash_ul = is_ul_nash(B, A, b, d)\nCand_Nash_or = is_or_nash(C, D, c, a)\nCand_Nash_ur = is_ur_nash(D, C, d, b)\n\n# Ergebnisse kombinieren und NAs entfernen\nNash_GG = np.array([Cand_Nash_ol, Cand_Nash_ul, Cand_Nash_or, Cand_Nash_ur])\nNash_GG_filtered = []\nfor element in Nash_GG:\n  if element == \"ol\" or element == \"ul\" or element == \"or\" or element == \"ur\":\n    Nash_GG_filtered.append(element)\n\n# Ergebnis ausgeben\nprint(f\"Nash-Gleichgewicht(e) in reinen Strategien: {', '.join(Nash_GG_filtered)}\")\n\n\nNash-Gleichgewicht(e) in reinen Strategien: ur\n\n\n\n\n3.2.2.2.5 Spiel ohne Gleichgewicht\n\n\nCode\nimport numpy as np\nimport random\n\nwhile True:\n    A = random.randint(0, 9)\n    a = random.randint(0, 9)\n    B = random.randint(0, 9)\n    b = random.randint(0, 9)\n    C = random.randint(0, 9)\n    c = random.randint(0, 9)\n    D = random.randint(0, 9)\n    d = random.randint(0, 9)\n\n    # Bedingungen prüfen\n    cond1 = (A &gt;= B) and (a &gt;= c)\n    cond2 = (B &gt;= A) and (b &gt;= d)\n    cond3 = (C &gt;= D) and (c &gt;= a)\n    cond4 = (D &gt;= C) and (d &gt;= b)\n\n    # Wenn keine Bedingung erfüllt ist, Schleife beenden\n    if not (cond1 or cond2 or cond3 or cond4):\n        break\n\nplot = create_plot()\n\nplot\n\n\n\n            \n            \n            \n\n\n   \n   \n\n\n\n\nCode\n# Nash-Bedingungen überprüfen und Strings zuweisen\nCand_Nash_ol = is_ol_nash(A, B, a, c)\nCand_Nash_ul = is_ul_nash(B, A, b, d)\nCand_Nash_or = is_or_nash(C, D, c, a)\nCand_Nash_ur = is_ur_nash(D, C, d, b)\n\n# Ergebnisse kombinieren und NAs entfernen\nNash_GG = np.array([Cand_Nash_ol, Cand_Nash_ul, Cand_Nash_or, Cand_Nash_ur])\nNash_GG_filtered = []\nfor element in Nash_GG:\n  if element == \"ol\" or element == \"ul\" or element == \"or\" or element == \"ur\":\n    Nash_GG_filtered.append(element)\n\n# Ergebnis ausgeben\nprint(f\"Nash-Gleichgewicht(e) in reinen Strategien: {', '.join(Nash_GG_filtered)}\")\n\n\nNash-Gleichgewicht(e) in reinen Strategien: \n\n\n\n\n\n3.2.2.3 Wiederholte Spiele\n\nAusgangspunkt Gefangenendilemma mit \\(B&gt;A&gt;D&gt;C\\) und \\(c&gt;a&gt;d&gt;b\\)\nNash-Gleichgewicht dann unten rechts mit der Auszahlung D, d\nEffizient wäre oben links mit Ausuahlung A, a\nTit for Tat: Kooperiere in der ersten Runde, erwidere danach die Strategiewahl des Gegenspielers reziprok\nDadurch “Bestrafung” für unkooperatives Verhalten möglich\nFunktioniert das immer?\nFunktioniert nicht bei bekannter endlicher Anzahl von Runden\nIn jeder Runde wird mit der Wahrscheinlichkeit \\(p\\) eine weitere Runde gespielt.\nErwartungswert der Kooperationsgeflecht für \\(T\\) Perioden (die Annahme einer endlichen Anzahl von Perioden wird gleich wieder aufgegeben)\n\\(E^1_k=\\sum_{t=0}^T A \\times p^t\\)\nHilfsüberlegung: \\((1-p)E^1_k = (1-p)\\sum_{t=0}^T A \\times p^t=A(\\sum_{t=0}^T p^t - \\sum_{t=0}^T p^{t+1})\\)\n\n\\(=A(\\sum_{t=0}^T p^t - \\sum_{t=1}^{T+1}p^{t})\\)\n\\(= A(1-p^{T+1})\\)\n\\(\\iff E^1_k=\\frac{A(1-p^{T+1})}{1-p}\\)\n\\[\\boxed{\\lim_{T \\to \\infty}{E^1_k}=\\frac{A}{1-p}}\\]\n\nErwartungswert der Nicht-Kooperation für Spieler 1: \\(E^1_{nk}= B+ \\frac{D}{1-p}-D\\)\nErwartungswert der Kooperation für Spieler 2: \\(E^2_k= \\frac{a}{1-p}\\)\nErwartungswert der Nicht-Kooperation für Spieler 2: \\(E^2_{nk}= c+ \\frac{d}{1-p}-d\\)\nKooperation durch Spieler 1 wenn \\(p\\geq \\frac{B-A}{B-D}\\)\nKooperation durch Spieler 2 wenn \\(p\\geq \\frac{c-a}{c-d}\\)\n\n\n\nCode\nfrom sympy import Symbol, solve, Eq\n\nA = Symbol('A')\nB = Symbol('B')\nC = Symbol('C')\nD = Symbol('D')\na = Symbol('a')\nb = Symbol('b')\nc = Symbol('c')\nd = Symbol('d')\np = Symbol('p')\n\n# Ungleichung aufstellen\n\nE_1K = A/(1-p)\n\n\nE_1NK = B+ D/(1-p)-D\n\n\nBedingung = Eq(E_1K, E_1NK)\n\n\nsol1=solve(Bedingung, p) # wie löse ich das als Ungleichung?\n\nprint(sol1)\n\nE_2K = a/(1-p)\n\nE_2NK = c+ d/(1-p) -d\n\nBedingung = Eq(E_2K, E_2NK)\n\nsol2 = solve(Bedingung, p)\nprint(sol2)\n\n\n\n\nCode\nimport numpy as np\n\nimport random\n\n# Zufällige Ganzzahlen zwischen 0 und 9 generieren\nA = random.randint(5, 7)\nB = random.randint(8, 9)\nC = random.randint(0, 1)\nD = random.randint(2, 4)\na = random.randint(5, 8)\nb = random.randint(0, 1)\nc = random.randint(8, 9)\nd = random.randint(2, 4)\n\n# Formatierte Bimatrix ausgeben\nprint(\"    l   r\")\nprint(f\"o  {A},{a}  {C},{c}\")\nprint(f\"u  {B},{b}  {D},{d}\")\n\n\n# Funktionen für Nash-Bedingungen\ndef is_ol_nash(A, B, a, c):\n  return \"ol\" if (A &gt;= B) and (a &gt;= c) else \"not_ol\"\n\ndef is_ul_nash(B, A, b, d):\n  return \"ul\" if (B &gt;= A) and (b &gt;= d) else \"not_ul\"\n\ndef is_or_nash(C, D, c, a):\n  return \"or\" if (C &gt;= D) and (c &gt;= a) else \"not_or\"\n\ndef is_ur_nash(D, C, d, b):\n  return \"ur\" if (D &gt;= C) and (d &gt;= b) else \"not_ur\"\n\n# Nash-Bedingungen überprüfen und Strings zuweisen\nCand_Nash_ol = is_ol_nash(A, B, a, c)\nCand_Nash_ul = is_ul_nash(B, A, b, d)\nCand_Nash_or = is_or_nash(C, D, c, a)\nCand_Nash_ur = is_ur_nash(D, C, d, b)\n\n# Ergebnisse kombinieren und NAs entfernen\nNash_GG = np.array([Cand_Nash_ol, Cand_Nash_ul, Cand_Nash_or, Cand_Nash_ur])\nNash_GG_filtered = []\nfor element in Nash_GG:\n  if element == \"ol\" or element == \"ul\" or element == \"or\" or element == \"ur\":\n    Nash_GG_filtered.append(element)\n\n# Ergebnis ausgeben\nprint(Nash_GG_filtered)\n\n# Kritisches p für Kooperation\n\np_krit = (B-A)/(B - D)\n#print(round(p_krit,3))\nprint(f\"Für Kooperation durch Spieler 1 muss die Wahrscheinlichkeit für eine weitere Runde mindestens {str(round(p_krit,3)).replace('.',',')} betragen.\")\n\np_krit = (c-a)/(c - d)\n#print(round(p_krit,3))\nprint(f\"Für Kooperation durch Spieler 2 muss die Wahrscheinlichkeit für eine weitere Runde mindestens {str(round(p_krit,3)).replace('.',',')} betragen.\")\n\n\n\n\n3.2.2.4 Trembling Hand\n\n\nCode\n# Python\n\nimport random\n\nrandom.seed(246)\n\nwhile True:\n    A = random.randint(0, 9)\n    a = random.randint(0, 9)\n    B = random.randint(0, 9)\n    b = random.randint(0, 9)\n   # C = random.randint(0, 9)\n    C=-20\n    c = random.randint(0, 9)\n    D = random.randint(0, 9)\n    d = random.randint(0, 9)\n\n    # Bedingungen prüfen\n    cond1 = (A &gt; B) and (a &gt;= c) # NGG ol\n    cond2 = (D  &gt; C) and (A &gt; D) and (a &gt; d)\n\n    # Wenn beide Bedingung erfüllt ist, Schleife beenden\n    if  (cond1 and cond2):\n        break\n\n# Ausgabe der Zahlen\n#print(f\"A={A}, a={a}, B={B}, b={b}, C={C}, c={c}, D={D}, d={d}\")\n\n# Formatierte Bimatrix ausgeben\n#print(\"    l   r\")\n#print(f\"o  {A},{a}  {C},{c}\")\n#print(f\"u  {B},{b}  {D},{d}\")\n\n\nplot = create_plot()\n\nplot\n\n\n\n            \n            \n            \n\n\n   \n   \n\n\n\nIdee: Manche Nash-Gleichgewichte sind riskant\nWenn der Gegenspieler “versehentlich” eine falsche Strategie spielt, dann macht man evtl hohe Verluste\nWie hoch darf die Fehlerwahrscheinlichkeit des Gegenspielers sein, damit das Nash-Gleichgewicht noch die richtige Strategie impliziert?\n\nAngenommen, beide Spieler streben ein Nash-Gleichgewicht oben links an\nFür Spieler 1 muss dann gelten\n\\(E_o\\geq E_u\\)\nWenn er davon ausgeht, dass Spieler 2 mit einer Wahrscheinlichkeit von \\(p\\) versehentlich rechts statt links spielt, heißt das\n\\((1-p)A+pC \\geq (1-p)B+pD\\)\n\\(\\iff A-pA+pC\\geq B-pB+pD\\)\n\\(\\iff A-p(A-C) \\geq B-p(B-D)\\)\n\\(\\iff p(B-D)-p(A-C) \\geq B-A\\)\n\\(\\iff p(B-D-A+C)\\geq B-A\\)\nmit \\((B-D-A+C) &lt;0\\)\n\\(\\iff p \\leq \\frac{B-A}{B-A-D+C}=\\frac{A-B}{A-B-C+D}\\)\nFür Spieler 2 muss dann gelten\n\\(E_l\\geq E_r\\)\n\\((1-p)a+pb \\geq (1-p)c+pd\\)\n\\(\\iff a-pa+pb \\geq c-pc+pd\\)\n\\(\\iff a-p(a-b) \\geq c-p(c-d)\\)\n\\(\\iff p(c-d)-p(a-b) \\geq c-a\\)\n\\(\\iff p(c-d-a+b) \\geq c-a\\)\nmit \\((c-d-a+b)\\neq 0\\)\n\\(p \\leq \\frac{c-a}{(c-d-a+b)}=\\frac{a-c}{(a-b-c+d)}\\)\n\n\nCode\n# Wahrscheinlichkeiten ausrechnen\n\nfrom sympy import Symbol, solve, Eq\n\nsymbols = [Symbol(name) for name in 'ABCDabcdp']\nA, B, C, D, a, b, c, d, p = symbols  # Entpacken und als separate Variablen speichern\n\n# Beide streben ol an\n\nE_o= (1-p)*A+p*C\n\nE_u= (1-p)*B + p*D\n\nsol = solve(Eq(E_o, E_u), p)\nprint(sol)\n\nE_l = (1-p)*a + p*b\nE_r = (1-p)*c + p*d\n\nsol = solve(Eq(E_l, E_r),p)\nprint(sol)\n\n\n\n\n\n3.2.3 Gemischte Strategien\n\nWenn es entweder kein Nash-Gleichgewicht (in reinen Strategien) gibt oder mehrere Nash-Gleichgewichte, dann lässt sich das Handeln der Spielenden nicht gut vorhersagen\nAus der Perspektive jedes Spielenden ist das Handeln des Gegenübers eine Zufallsvariable. Mit einer bestimmten Wahrscheinlichkeit wählt das Gegenüber eine seiner Strategien.\nDen Zufall kann man aber näher charakterisieren, wenn man sich überlegt, welche Wahrscheinlichkeiten ein rationales Gegenüber wählen würde.\nEin rationales Gegenüber wählt die Wahrscheinlichkeiten so, dass der spielende Akteur keine Möglichkeit mehr hat, seine Situation durch die Wahl seiner Strategie zu verbessern.\nJede spielende Person wählt die Wahrscheinlichkeiten für ihre Handlung also so, dass das jeweilige Gegenüber indifferent ist in der Wahl seiner Handlungen.\nEs muss also gelten: \\[E_o=E_u\\] \\[\\iff p_l A+(1-p_l)C=p_lB+(1-p_l)D\\]\n\n\\[\\iff p_l A + C-p_lC=p_lB+D-p_lD\\]\n\\[\\iff p_l(A-C)+C=p_l(B-D)+D\\]\n\\[\\iff p_l(A-C-B+D)=D-C\\] \\[\\boxed{p_l=\\frac{D-C}{A-B-C+D}}\\] \\[E_l=E_r\\]\n\\[\\iff p_o a+(1-p_o)b=p_o c + (1-p_o)d\\]\n\\[\\iff p_o a+b-p_ob=p_oc+d-p_od\\] \\[\\iff p_o(a-b)+b=p_o(c-d)+d\\]\n\\[\\iff p_o(a-b-c+d)=d-b\\]\n\\[\\iff \\boxed{p_o=\\frac{d-b}{a-b-c+d}}\\]\n\n\nCode\nimport numpy as np\nimport random\nfrom lets_plot import *\n\nrandom.seed(12)\n\nwhile True:\n    A = random.randint(0, 9)\n    a = random.randint(0, 9)\n    B = random.randint(0, 9)\n    b = random.randint(0, 9)\n    C = random.randint(0, 9)\n    c = random.randint(0, 9)\n    D = random.randint(0, 9)\n    d = random.randint(0, 9)\n\n    # Bedingungen prüfen: Keine dominante Strategien\n    cond1 = (A &gt;= B) and (C &gt;= D)\n    cond2 = (B &gt;= A) and (D &gt;= C)\n    cond3 = (a &gt;= c) and (b &gt;= d)\n    cond4 = (c &gt;= a) and (d &gt;= b)\n\n    # Wenn keine Bedingung erfüllt ist, Schleife beenden\n    if not (cond1 or cond2 or cond3 or cond4):\n        break\n\nplot = create_plot()\n\nplot\n\n\n\n# Funktionen für Nash-Bedingungen\ndef is_ol_nash(A, B, a, c):\n  return \"ol\" if (A &gt;= B) and (a &gt;= c) else \"not_ol\"\n\ndef is_ul_nash(B, A, b, d):\n  return \"ul\" if (B &gt;= A) and (b &gt;= d) else \"not_ul\"\n\ndef is_or_nash(C, D, c, a):\n  return \"or\" if (C &gt;= D) and (c &gt;= a) else \"not_or\"\n\ndef is_ur_nash(D, C, d, b):\n  return \"ur\" if (D &gt;= C) and (d &gt;= b) else \"not_ur\"\n\n# Nash-Bedingungen überprüfen und Strings zuweisen\nCand_Nash_ol = is_ol_nash(A, B, a, c)\nCand_Nash_ul = is_ul_nash(B, A, b, d)\nCand_Nash_or = is_or_nash(C, D, c, a)\nCand_Nash_ur = is_ur_nash(D, C, d, b)\n\n# Ergebnisse kombinieren und NAs entfernen\nNash_GG = np.array([Cand_Nash_ol, Cand_Nash_ul, Cand_Nash_or, Cand_Nash_ur])\nNash_GG_filtered = []\nfor element in Nash_GG:\n  if element == \"ol\" or element == \"ul\" or element == \"or\" or element == \"ur\":\n    Nash_GG_filtered.append(element)\n\n\n\n# Ergebnis ausgeben\nif Nash_GG_filtered == []:\n   print('Es gibt kein Nash-Gleichgewicht in reinen Strategien')\n\nelse:\n   print(f\"Nash-Gleichgewicht(e) in reinen Strategien: {', '.join(Nash_GG_filtered)}\")\n\n\n\n# Anzahl der Nash GG\n\n#Anzahl_NGG=len(Nash_GG_filtered)\n#print(Anzahl_NGG)\n\n# Wahrscheinlichkeiten ausrechnen.\n# Dabei jeweils den Fall Division duch 0 aussschließen\n\n#p_l\nif (A - B - C + D)!=0: p_l = ( D-C)/(A - B - C + D)\n\n#print(round(p_l, 2))\n\n#p_o\nif (-b + d)/(a - b - c + d)!=0: p_o = (-b + d)/(a - b - c + d)\n\n#print(round(p_o, 2))\n\n\n# Ausgabe Abhängig von Bedingungen\n\nif (#Anzahl_NGG == 1 or\n    p_o &lt; 0 or p_l &lt; 0 or\n            p_o &gt; 1 or p_l &gt; 1 or\n            (a - b - c + d) == 0 or\n            (A - B - C + D) == 0):\n    print(\"Kein Nash-Gleichgewicht in gemischten Strategien\")\nelse:   print(f\"Gemischte Strategien: p_o= {round(p_o, 2)}, p_l= {round(p_l, 2)}\")\n\n\n\n            \n            \n            \n\n\nEs gibt kein Nash-Gleichgewicht in reinen Strategien\nGemischte Strategien: p_o= 0.64, p_l= 0.62\n\n\n\n\nCode\n# Wahrscheinlichkeiten ausrechnen\n\nfrom sympy import Symbol, solve, Eq\n\nsymbols = [Symbol(name) for name in 'ABCDabcdp']\nA, B, C, D, a, b, c, d, p = symbols  # Auspacken in verschiedene Variablen\n\n\n#p_l\nE_o= p*A+(1-p)*C\n\nE_u= p*B  + (1-p)*D\n\nsol = solve(Eq(E_o, E_u), p)\nprint(sol)\n\n#p_o\n\nE_l = p*a + (1-p)*b\nE_r = p*c + (1-p)*d\n\nsol = solve(Eq(E_l, E_r),p)\nprint(sol)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Nicht-kooperative Spieltheorie</span>"
    ]
  },
  {
    "objectID": "Spieltheorie.html#sequenzielle-spiele",
    "href": "Spieltheorie.html#sequenzielle-spiele",
    "title": "3  Nicht-kooperative Spieltheorie",
    "section": "3.3 Sequenzielle Spiele",
    "text": "3.3 Sequenzielle Spiele\nSpieler spielen nacheinander. Dabei kann man die Fälle unterscheiden, dass die Spieler ihre vorherigen Züge sehen können oder nicht oder unvollständig. Man kann ebenso die Fälle unterscheiden, dass sie die Auszahlungen der Mitspieler kennen oder nicht oder unvollständig informiert sind.\n\n3.3.1 Vollständige Information\nAnnahme: Alle Spieler kennen alle Auszahlungen und sehen alle bislang erfolgten Spielzüge\nDarstellung des Spiels mittels eines Spielbaums. Die Benennung der Auszahlungen mit \\(A,a\\) für oben rechts usw. folgt der Darstellung für simultane Spiele.\n\n\n\nGrundstruktur eines Spielbaums\n\n\n\n3.3.1.1 Rückwärtsinduktion\nSequenzielle Spiele wereden „von hinten nach vorn“ gelöst. Man löst zunächst alle Entscheidungen der Vorrunde, dann die der Runde davor usw. Auf diese Weise vollzieht man nach, dass rationale Spieler die rationalen Entscheidungen ihrer Mitspieler antizipieren.\n\n3.3.1.1.1 Beispiele\n\n\n\nBeispiel für Rückwärtsinduktion\n\n\n\n\n\nBeispiel für Rückwärtsinduktion\n\n\n\n\n3.3.1.1.2 Bedingungen für ein Nash-Gleichgewicht\nZunächst vereinfachende Annahme: \\(a\\neq c\\ \\text{und}\\ b \\neq d\\)\nol: \\(a&gt;c \\land ((A&gt;B\\ \\land\\ b&gt;d) \\lor (A&gt;D\\ \\land\\ d&gt;b))\\)\nor: \\(c&gt;a  \\land ((C&gt;D\\ \\land d&gt;b) \\lor (C&gt;B\\ \\land b&gt; d))\\)\nul: \\(b&gt;d \\land ((B&gt;A \\land a&gt;c)\\lor(B&gt;C \\land c&gt;a))\\)\nur: \\(d&gt;b \\land ((D&gt;A \\land a&gt;c)\\lor (D&gt;C \\land c&gt;a))\\)\n\n\nCode\nimport numpy as np\nimport random\n\nrandom.seed(123) # Für reproduzierbare Ergebnisse ggf. fixieren\n\n# Zufällige Ganzzahlen zwischen 0 und 9 generieren\n#A = random.randint(0, 9)\n#B = random.randint(0, 9)\n#C = random.randint(0, 9)\n#D = random.randint(0, 9)\n#a = random.randint(0, 9)\n#b = random.randint(0, 9)\n#c = random.randint(0, 9)\n#d = random.randint(0, 9)\n\n#A = 1\n#B = 0\n#C = 0\n#D = 0\n#a = 1\n#b = 0\n#c = 0\n#d = 0\n\n# Zufallszahlen, aber alle unterschiedlich\nchoices = np.arange(10)\n\n# Generate unique random integers for variables\nParameter = np.random.choice(choices, size=8, replace=False)\nA, B, C, D, a, b, c, d = Parameter\n\n\n# Formatierte Bimatrix ausgeben\n#print(\"    l   r\")\n#print(f\"o  {A},{a}  {C},{c}\")\n#print(f\"u  {B},{b}  {D},{d}\")\n\n\n# Spielbaum ausgeben\n\nprint(f\" ol: {A}, {a}\\n or: {C}, {c}\\n ul: {B}, {b}\\n ur: {D}, {d}\")\n\n# Funktionen für Nash-Bedingungen\n# Spieler 2 (a) entscheidet l/r, Spieler 1 (A) entscheidet o/u\ndef is_ol_nash(A, B, D, a, b, c, d):\n  return \"ol\" if ((a &gt; c) and ((A&gt;= B and b&gt; d) or\n              (A &gt;= D and d&gt;=b))) else \"not_ol\"\n\ndef is_or_nash( B, C, D, a, b, c, d):\n  return \"or\" if (c&gt;a and ((C&gt;= B and b&gt;=d) or\n              (C &gt;= D and d&gt;b))) else \"not_or\"\n\n\ndef is_ul_nash(A, B, C,  a, b, c, d):\n  return \"ul\" if (b&gt;=d and ((B&gt;= A and a&gt;= c) or\n              (B &gt;= C and c&gt;=a))) else \"not_ul\"\n\n\ndef is_ur_nash(A,  C, D, a, b, c, d):\n  return \"ur\" if (d&gt;=b and ((D&gt;= A and a&gt;= c) or\n              (D &gt;= C and c&gt;=a))) else \"not_ur\"\n\n\n# Nash-Bedingungen überprüfen und Strings zuweisen\n\nCand_Nash_ol = is_ol_nash(A, B,    D, a, b, c, d)\nCand_Nash_or = is_or_nash(   B, C, D, a, b, c, d)\nCand_Nash_ul = is_ul_nash(A, B, C,    a, b, c, d)\nCand_Nash_ur = is_ur_nash(A,    C, D, a, b, c, d)\n\n# Ergebnisse kombinieren und NAs entfernen\nNash_GG = np.array([Cand_Nash_ol, Cand_Nash_ul, Cand_Nash_or, Cand_Nash_ur])\nNash_GG_filtered = []\nfor element in Nash_GG:\n  if element == \"ol\" or element == \"or\" or element == \"ul\" or element == \"ur\":\n    Nash_GG_filtered.append(element)\n\n# Ergebnis ausgeben\nprint(Nash_GG_filtered)\n\n\n ol: 7, 8\n or: 0, 4\n ul: 6, 3\n ur: 2, 9\n[np.str_('ol')]\n\n\n\n\n\n3.3.1.2 Teilspielperfektheit\n\nTeilspielperfektheit verlangt, dass jeder Spieler jeden Zug so ausführt, dass das Ergebnis des Zuges seinen Interessen nicht schadet.\nEin Teilspiel beginnt in einem Knoten und enthält alle nachfolgenden Knoten\nFür später: Ein Teilspiel darf nachfolgende Informationsmengen nicht teilen. Es gehören also immer alle Knoten einer Informationsmenge zu einem Teilspiel\n\nBeispiel: Unglaubwürdige Drohung\n\n\n\nUnglaubwürdige Drohung\n\n\nHier: Tafelaufschrieb Markteintrittsspiel\n\n\n3.3.1.3 Selbstbindung\nHier: Sonderabbildung Weltvernichtungsbombe aus Winter (2019)\n\nAutomatisierung der Drohung erzeugt erwünschte Glaubwürdigkeit\nAber: Automatisierung ist riskant, wenn Fehler möglich sind.\nTrembling Hand Überlegungen\n\n\n\nCode\n# Python\n\nA= 1\na= 1\nB= -1\nb= -1\nC= 1\nc= 1\nD= 2\nd= 0\n\n\nfrom lets_plot import *\n\nLetsPlot.setup_html()\n\nggplot() + \\\ngeom_text(x=- .5, y= 2   , label=a) +\\\ngeom_text(x=-1.5, y=  .75, label=A) +\\\ngeom_text(x=- .5, y=-1   , label=b) +\\\ngeom_text(x=-1.5, y=-2.25, label=B) +\\\ngeom_text(x= 1.5, y= 2   , label=c) +\\\ngeom_text(x=  .5, y=  .75, label=C) +\\\ngeom_text(x= 1.5, y=-1   , label=d) +\\\ngeom_text(x=  .5, y=-2.25, label=D) +\\\ngeom_text(x=-1  , y= 3.3 , label='automatische Bombe')+\\\ngeom_text(x= 1  , y= 3.3 , label='nichtautomatische Bombe')+\\\ngeom_text(x=-2.2, y= 1.375, angle=90, label='Kein Angriff')+\\\ngeom_text(x=-2.2, y=-1.625, angle=90, label='Angriff')+\\\ngeom_text(x= 0 , y= 4 ,\n          fontface = \"bold\", label='UdSSR')+\\\ngeom_text(x=-2.7 , y= 0 , angle=90,\n          fontface = \"bold\", label='USA')+\\\ngeom_segment(x=-2,  xend= 2, y= 0, yend= 0) +\\\ngeom_segment(x=-2,  xend= 2, y= 3, yend= 3) +\\\ngeom_segment(x=-2,  xend= 2, y=-3, yend=-3) +\\\ngeom_segment(x=-2,  xend=-2, y=-3, yend= 3) +\\\ngeom_segment(x= 0,  xend= 0, y=-3, yend= 3) +\\\ngeom_segment(x= 2,  xend= 2, y=-3, yend= 3) +\\\ntheme_void()+\\\nlabs(title='Auszahlungen im Szenario mit Weltvernichtungsbombe')\n\n\n\n            \n            \n            \n\n\n   \n   \n\n\n\nZwei Nash-Gleichgewichte\nZunächst das Gleichgewicht oben links\nWie ist es einzuschätzen, wenn beide Spieler mit einer Wahrscheinlichkeit \\(p_i\\) mit \\(i \\in (\\text{USA, UdSSR})\\) einen Fehler machen?\n\nKalkül der USA:\n\\(E_{kA}=(1-p_{\\text{UdSSR}}) 1 + p_{\\text{UdSSR}} 1 =1\\)\n\\(E_A=(1-p_{\\text{UdSSR}}) (-1) + p_{\\text{UdSSR}} 2\\)\n\\(=-1 + p_{\\text{UdSSR}} +2 p_{\\text{UdSSR}}=-1+ 3 p_{\\text{UdSSR}}\\)\n\\(E_{kA}\\geq E_A\\)\n\\(1\\geq -1+ 3 p_{\\text{UdSSR}}\\)\n\\(\\iff p_{\\text{UdSSR}} \\leq \\frac{2}{3}\\)\nKalkül der UdSSR\n\\(E_{aB}=(1-p_{\\text{USA}}) 1 + p_{\\text{USA}} (-1) = 1-2p_{\\text{USA}}\\)\n\\(E_{naB}= (1-p_{\\text{USA}}) 1 + p_{\\text{USA}} 0 = 1-p_{\\text{USA}}\\)\n\\(E_{aB} \\geq E_{naB}\\)\n\\(1-2p_{\\text{USA}} \\geq 1-p_{\\text{USA}}\\)\n\\(\\iff p_{\\text{USA}} \\leq 0\\)\n\\(\\rightarrow\\) das Gleichgewicht ist nicht trembling-Hand-perfekt\nWie sieht es mit dem anderen Gleichgewichht aus?\nProbieren Sie es aus!\n\\(E_A=\\)\n\\(E_{kA}=\\)\n\n\n\n3.3.2 Unvollständige Information\n\n3.3.2.1 Alles beobachtbar, aber Auszahlungen für Spieler 1 u/o 2 können gleich sein\n\n\n\nAuszahlungen von Spieler 1 sind gleich\n\n\n\\(\\rightarrow\\) Spieler 1 muss sich irgendwie entscheiden, aber Spieler 2 kann die Entscheidung sehen.\n\\(\\rightarrow\\) Unproblematischer Fall\n\n\n\nAuszahlungen von Spieler 2 sind gleich\n\n\n\\(\\rightarrow\\) Spieler 1 kann nicht antizipieren, was Spieler 2 im Fall “unten” macht.\n\\(\\rightarrow\\) Kriterium für Entscheidung unter Risiko\nMögliche Kriterien:\n\nErwartungswert\nErwartungsnutzen\nMaximin\n\\(\\dots\\)\n\nHier unterstellt: Erwartungswertkriterium\nDie Bedingungen für ein Nash-Gleichgewicht bei sequenziellen Spielen lauten dann:\nol: \\(a&gt;c \\land ((A\\geq B\\ \\land\\ b \\geq d) \\lor (A \\geq  D\\ \\land\\ d \\geq b) ) \\lor a=c \\land ((b&gt;d \\land (\\frac{A+C}{2} \\geq B)\\lor (d&gt;b \\land \\frac{A+C}{2}\\geq D) \\lor (b=d \\land(\\frac{A+C}{2}\\geq \\frac{B+D}{2})))\\)\nor: \\(c&gt;a  \\land ((C&gt;D\\ \\land d&gt;b) \\lor (C&gt;B\\ \\land b&gt; d)) \\lor a=c \\land ((b&gt;d \\land (\\frac{A+C}{2} \\geq B)\\lor (d&gt;b \\land \\frac{A+C}{2}\\geq D) \\lor (b=d \\land(\\frac{A+C}{2}\\geq \\frac{B+D}{2})))\\)\nul: \\(b&gt;d \\land ((B&gt;A \\land a&gt;c)\\lor(B&gt;C \\land c&gt;a))\\lor b=d \\land ((a&gt;c \\land (\\frac{B+D}{2} \\geq A)\\lor (c&gt;a \\land \\frac{B+D}{2}\\geq C) \\lor (b=d \\land(\\frac{B+D}{2}\\geq \\frac{A+C}{2})))\\)\nur: \\(d&gt;b \\land ((D&gt;A \\land a&gt;c)\\lor (D&gt;C \\land c&gt;a))\\lor b=d \\land ((a&gt;c \\land (\\frac{B+D}{2} \\geq A)\\lor (c&gt;a \\land \\frac{B+D}{2}\\geq C) \\lor (b=d \\land(\\frac{B+D}{2}\\geq \\frac{A+C}{2})))\\)\n\n\n3.3.2.2 Zug von Spieler 1 ist für Spieler 2 unsichtbar\nDurch eine gestrichelte Linie im Spielbaum werdn die Knoten verbunden, die ein Spieler nicht voneinander unterscheiden kann. Die spielende Person weiß also nicht, ob sie sich in dem einen Knoten am einen Ende der gestrichelten Linie befindet oder am anderen Ende.\n - Fehlende Information ist für Spieler 2 kein Problem, wenn er eine dominante Alternative hat oder wenn alle Auszahlungen für ihn gleich sind.\n\nFehlende Information für Spieler 2 ist auch kein Problem, wenn Spieler 1 eine dominante Alternative hat.\nWenn Information nicht vorliegt, Entscheidungskriterium unter Risiko nutzen. Hier: Erwartungswert\n\n\n\n3.3.2.3 Typ von Spieler 1 (und damit die Menge seiner Auszahlungen) ist für Spieler 2 unsichtbar\n\nTafelaufschrieb\n\nGrundsätzlich zwei verschiedene Typen von Gleichgewichten:\n\nSeparierende Gleichgewichte: Spieler 1 offenbart durch seine Entscheidung, von welchem Typ er ist\nPooling Gleichgewichte: Man kann kann aus dem Handeln des Spielers 1 nicht auf seinen Typ schließen\n\n\n\n\nTyp Spieler 1 unsichtbar. Separierendes Gleichgewicht\n\n\n\n\n\nTyp Spieler 1 unsichtbar. Pooling-Gleichgewicht\n\n\n\nDas Verhalten des Spielers 1 lässt jetzt keinen Schluss mehr auf seinen Typ zu.\nEntscheidung unter Risiko (hier: Erwartungswert für Spieler 2 berechnen)\n\n\\(E_l=0,6 \\times 7 + 0,4 \\times 4=5,8\\)\n\\(E_r=0,6 \\times 5 + 0,4 \\times 9=6,6\\)\n\nDer Erwartungswert für “rechts” ist also höher als der für “links”\n\n - Spieler 2 spielt “rechts”, wenn “unten”\n\nSpieler 2 spielt “links”, wenn “oben”\nSpieler 1 spielt “oben”, wenn Typ 1\nSpieler 1 spielt “unten”, wenn Typ 2",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Nicht-kooperative Spieltheorie</span>"
    ]
  },
  {
    "objectID": "Spieltheorie.html#koalitionsspiele",
    "href": "Spieltheorie.html#koalitionsspiele",
    "title": "3  Nicht-kooperative Spieltheorie",
    "section": "3.5 Koalitionsspiele",
    "text": "3.5 Koalitionsspiele",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Nicht-kooperative Spieltheorie</span>"
    ]
  },
  {
    "objectID": "Spieltheorie.html#evolutionäre-spiele",
    "href": "Spieltheorie.html#evolutionäre-spiele",
    "title": "3  Nicht-kooperative Spieltheorie",
    "section": "3.4 Evolutionäre Spiele",
    "text": "3.4 Evolutionäre Spiele\n\n3.4.1 Grundlagen\n\nModell zur Beschreibung der Verbreitung bestimmter Strategien in Populationen basierend auf relativer Fitness\nUnterscheidet sich von klassischer Spieltheorie durch Fokus auf evolutionäre Selektion statt rationaler Entscheidungen\nGrundkonzepte der evolutionären Spieltheorie\n\nBetrachtet Populationen mit unterschiedlichen Verhaltensstrategien\nFrequenzabhängige Selektion: Fitness hängt von Populationszusammensetzung ab\nDrei evolutionäre Grundprinzipien:\n\nReplikation\n\nSelektion\n\nMutation (in Grundmodellen oft vernachlässigt)\n\nMathematische Beschreibung durch Normalformspiele mit Auszahlungsmatrix \\(U = [u_{ij}]\\)\nHier: 2 Spielertypen \\(i=1,2\\)\n\nReplikatordynamik-Gleichung\n\nKontinuierliche Differentialgleichung für unendliche (oder zumindest sehr große) Populationen:\n\\[\\dot{p}_i = p_i \\left(f_i(P_t) - \\bar{f}(P_t)\\right)\\]\n\n\\(P_t\\): Zusammensetzung der Population zum Zeitpunkt \\(t\\)\n\\(p_i\\): Anteil der Strategie-i-Spieler\n\n\\(f_i(P_t)\\): Fitness der Strategie \\(i\\) zum Zeitpunkt \\(t\\)\n\\(\\bar{f}(P_t)\\): Durchschnittliche Populationsfitness zum Zeitpunkt \\(t\\)\n\n\nFitnessberechnung:\n\n\n\\[f_1(P_t) = p_1 u_{11} + (1-p_1) u_{12}\\] \\[f_2(P_t) = p_1 u_{21} + (1-p_1) u_{22}\\]\n\nDurchschnittsfitness:\n\n\\[\\bar{f}(P_t) = p_1 f_1(P_t) + (1-p_1) f_2(P_t)\\]\n\nKernaussage: Der Anteil der Population, der eine überdurchschnittlicher Fitness aufweist, wächst, der andere schrumpft.\nGrundsätzlich möglich\n\nRandlösungen: Eine Strategie setzt sich komplett durch\nStabile Anteile der Strategien\n\n\n\n\n3.4.2 Einige Spiele\n\n3.4.2.1 Koordinationsspiel\n\nIm (klassischen) Koordinationsspiel gibt es ein Gleichgewicht in gemischten Strategien\nIn einem evolutionären (klassischen) Koordinationsspiel sind drei Fälle in Abhängigkeit der Ausgangsverteilung der Strategien möglich\n\nDie Anteile der Strategien entsprechen den Wahrscheinlichkeiten des Gleichgewichts in gemischten Strategien\nDie Anteile der Strategien konvergieren gegen das eine Nash-Gleichgewicht in reinen Strategien\nDie Anteile konvergieren gegen das andere Gleichgewicht\n\n\n\n\nCode\n# Python\n\n\nA= 1\na= 1\nB= 0\nb= 0\nC= 0\nc= 0\nD= 1\nd= 1\n\n\nfrom lets_plot import *\n\nLetsPlot.setup_html()\n\nggplot() + \\\ngeom_text(x=- .5, y= 2   , label=a) +\\\ngeom_text(x=-1.5, y=  .75, label=A) +\\\ngeom_text(x=- .5, y=-1   , label=b) +\\\ngeom_text(x=-1.5, y=-2.25, label=B) +\\\ngeom_text(x= 1.5, y= 2   , label=c) +\\\ngeom_text(x=  .5, y=  .75, label=C) +\\\ngeom_text(x= 1.5, y=-1   , label=d) +\\\ngeom_text(x=  .5, y=-2.25, label=D) +\\\ngeom_text(x=-1  , y= 3.3 , label='I')+\\\ngeom_text(x= 1  , y= 3.3 , label='II')+\\\ngeom_text(x=-2.2, y= 1.375, angle=90, label='I')+\\\ngeom_text(x=-2.2, y=-1.625, angle=90, label='II')+\\\ngeom_text(x= 0 , y= 4 ,\n          fontface = \"bold\", label='Spieler 2')+\\\ngeom_text(x=-2.7 , y= 0 , angle=90,\n          fontface = \"bold\", label='Spieler 1')+\\\ngeom_segment(x=-2,  xend= 2, y= 0, yend= 0) +\\\ngeom_segment(x=-2,  xend= 2, y= 3, yend= 3) +\\\ngeom_segment(x=-2,  xend= 2, y=-3, yend=-3) +\\\ngeom_segment(x=-2,  xend=-2, y=-3, yend= 3) +\\\ngeom_segment(x= 0,  xend= 0, y=-3, yend= 3) +\\\ngeom_segment(x= 2,  xend= 2, y=-3, yend= 3) +\\\ntheme_void()+\\\nlabs(title='Auszahlungen in einem Koordinationsspiel')\n\n\n\n            \n            \n            \n\n\n   \n   \n\n\n\n\nCode\n#p_l\nif (A - B - C + D)!=0: p_l = ( D-C)/(A - B - C + D)\n\n#print(round(p_l, 2))\n\n#p_o\nif (-b + d)/(a - b - c + d)!=0: p_o = (-b + d)/(a - b - c + d)\n\n#print(round(p_o, 2))\n\n\n# Ausgabe Abhängig von Bedingungen\n\nif (#Anzahl_NGG == 1 or\n    p_o &lt; 0 or p_l &lt; 0 or\n            p_o &gt; 1 or p_l &gt; 1 or\n            (a - b - c + d) == 0 or\n            (A - B - C + D) == 0):\n    print(\"Kein Nash-Gleichgewicht in gemischten Strategien\")\nelse:   print(f\"Gemischte Strategien: p_o= {round(p_o, 2)}, p_l= {round(p_l, 2)}\")\n\n\nGemischte Strategien: p_o= 0.5, p_l= 0.5\n\n\nFür dieses Spiel beträgt im Gleichgewicht in gemischten Strategien \\(p_I=p_II=0,5\\)\n\nErster Fall: Schon zu Beginn des Spiels entsprechen die Populationsanteile diesen Werten und die Replikatordynamik ist deterministisch. Dann ist die Zusammensetzung der Population stabil.\nZweiter Fall: Schon zu Beginn des Spiels entsprechen die Populationsanteile diesen Werten und die Replikatordynamik ist stochastisch. Dann ist die Zusammensetzung der Population instabil und konvergiert gegen \\(p_I=0\\) oder gegen \\(p_I=1\\).\nDritter Fall: Zu Beginn des Spiels gilt \\(p_I \\neq 0.5\\). Dann konvergiert gegen \\(p_I=0\\) oder gegen \\(p_I=1\\), je nachdem ob zu Beginn \\(p_I\\) kleiner oder größer \\(0,5\\) war.\n\n\n\nCode\nimport sympy as sp\nimport numpy as np\nfrom lets_plot import *\n\n# Symbolische Berechnung des Gleichgewichts mit sympy\np = sp.symbols('p')\nF_II = p * D + (1 - p) * B\nF_I = p * C + (1 - p) * A\nequilibrium_eq = sp.Eq(F_II, F_I)\nequilibrium_p = sp.solve(equilibrium_eq, p)[0]\nprint(f\"Das Gleichgewicht liegt bei p = {equilibrium_p}\")\n\n# Parameter für die Simulation\ngenerations = 100\np_value = 0.5  # Startanteil der Strategie II\nq_value=1-p_value\ndt = 0.1\np_values = [p_value]\nq_values = [q_value]\nsigma=0\n\n# Simulation\nfor _ in range(generations):\n    F_II_val = p_value * D + (1 - p_value) * B\n    F_I_val = p_value * C + (1 - p_value) * A\n    F_avg = p_value * F_II_val + (1 - p_value) * F_I_val\n    dp_dt = p_value * (F_II_val - F_avg) + np.random.normal(loc=0, scale=sigma) # noise\n    p_value += dp_dt * dt\n    p_values.append(p_value)\n    q_values.append(1-p_value)\n\n# Daten für den Plot vorbereiten\n\ndata = {\n    'Generation': list(range(generations + 1))*2,\n    'Strategien': [item for item in [\"Strategie I\",\"Strategie II\"] for _ in range (generations + 1)],\n    'Anteile'   : q_values + p_values\n}\n\n# print(data)\n\n# Plot mit lets-plot\n\nLetsPlot.setup_html()\n\np = (ggplot(data, aes(x='Generation', y='Anteile', color='Strategien')) +\n     geom_line() +\n     geom_hline(yintercept=float(equilibrium_p), color='red', linetype='dashed', size=1) +\n     ggtitle('Evolution im Koordinationsspiel') +\n     xlab('Generation') +\n     ylab('Anteil der Strategien') +\n     theme_minimal() #+\n #    + geom_text(x=11, y=float(equilibrium_p) + 0.05,\n  #               label=f'Gleichgewicht p = #{round(equilibrium_p, 2)}', color='red')\n)\n\n# Plot anzeigen\np.show()\n\n\nDas Gleichgewicht liegt bei p = 1/2\n\n\n\n            \n            \n            \n\n\n   \n   \n\n\n\n\nCode\nimport numpy as np\nimport sympy as sp\nfrom lets_plot import *\n\nLetsPlot.setup_html()\n\n\n# Symbolische Berechnung des Gleichgewichts mit sympy\np = sp.symbols('p')\nF_II = p * D + (1 - p) * B\nF_I = p * C + (1 - p) * A\nequilibrium_eq = sp.Eq(F_II, F_I)\nequilibrium_p = sp.solve(equilibrium_eq, p)[0]\nprint(f\"Das Gleichgewicht liegt bei p = {equilibrium_p}\")\n\n\n\nseeds = list(range(3,7))\nplots = []\n\nrunde = 0\n\nfor seed in seeds:\n    # Parameter (Beispielwerte, bitte ggf. anpassen)\n\n    runde= runde+1\n\n    generations = 100\n #   A, B, C, D = 1, 2, 3, 4\n    sigma = 0.1\n    dt = 0.1\n  #  equilibrium_p = 0.5  # Beispielwert\n\n    np.random.seed(seed)\n    p_value = 0.5\n    p_values = [p_value]\n    q_values = [1 - p_value]\n\n    # Simulation\n    for _ in range(generations):\n        F_II_val = p_value * D + (1 - p_value) * B\n        F_I_val = p_value * C + (1 - p_value) * A\n        F_avg = p_value * F_II_val + (1 - p_value) * F_I_val\n        dp_dt = p_value * (F_II_val - F_avg) + np.random.normal(loc=0, scale=sigma)\n        p_value += dp_dt * dt\n        p_values.append(p_value)\n        q_values.append(1 - p_value)\n\n    # Daten für den Plot vorbereiten\n    data = {\n        'Generation': list(range(generations + 1)) * 2,\n        'Strategien': [item for item in [\"Strategie I\", \"Strategie II\"] for _ in range(generations + 1)],\n        'Anteile': q_values + p_values\n    }\n\n    # Plot erstellen\n    p = (\n        ggplot(data, aes(x='Generation', y='Anteile', color='Strategien')) +\n        geom_line() +\n        geom_hline(yintercept=float(equilibrium_p), color='red', linetype='dashed', size=1) +\n        ggtitle(f'Runde {runde}') +\n        xlab('Generation') +\n        ylab('Anteil der Strategien') +\n        theme_minimal() #+\n    #    geom_text(x=44, y=float(equilibrium_p) + 0.05,\n    #              label=f'Gleichgewicht p = {round(equilibrium_p, 2)}', color='red')\n    )\n    plots.append(p)\n\n# Plots im 2x2-Grid anzeigen\ngggrid(plots, ncol=2)\n\n\n\n            \n            \n            \nEvolution im Koordinationsspiel mit noise\n\n\nDas Gleichgewicht liegt bei p = 1/2\n\n\n   \n   \n\n\n\n\n3.4.2.2 Anti-Koordinationsspiel\nKoordinationsspiele mit asymmetrischen Nash-Gleichgewichten nennt man auch Anti-Koordinationsspiel.\n\n\nCode\n# Python\n\n\nA= 0\na= 0\nB= 1\nb= 1\nC= 1\nc= 1\nD= 0\nd= 0\n\n\nfrom lets_plot import *\n\nLetsPlot.setup_html()\n\nggplot() + \\\ngeom_text(x=- .5, y= 2   , label=a) +\\\ngeom_text(x=-1.5, y=  .75, label=A) +\\\ngeom_text(x=- .5, y=-1   , label=b) +\\\ngeom_text(x=-1.5, y=-2.25, label=B) +\\\ngeom_text(x= 1.5, y= 2   , label=c) +\\\ngeom_text(x=  .5, y=  .75, label=C) +\\\ngeom_text(x= 1.5, y=-1   , label=d) +\\\ngeom_text(x=  .5, y=-2.25, label=D) +\\\ngeom_text(x=-1  , y= 3.3 , label='I')+\\\ngeom_text(x= 1  , y= 3.3 , label='II')+\\\ngeom_text(x=-2.2, y= 1.375, angle=90, label='I')+\\\ngeom_text(x=-2.2, y=-1.625, angle=90, label='II')+\\\ngeom_text(x= 0 , y= 4 ,\n          fontface = \"bold\", label='Spieler 2')+\\\ngeom_text(x=-2.7 , y= 0 , angle=90,\n          fontface = \"bold\", label='Spieler 1')+\\\ngeom_segment(x=-2,  xend= 2, y= 0, yend= 0) +\\\ngeom_segment(x=-2,  xend= 2, y= 3, yend= 3) +\\\ngeom_segment(x=-2,  xend= 2, y=-3, yend=-3) +\\\ngeom_segment(x=-2,  xend=-2, y=-3, yend= 3) +\\\ngeom_segment(x= 0,  xend= 0, y=-3, yend= 3) +\\\ngeom_segment(x= 2,  xend= 2, y=-3, yend= 3) +\\\ntheme_void()+\\\nlabs(title='Auszahlungen in einem Anti-Koordinationsspiel')\n\n\n\n            \n            \n            \n\n\n   \n   \n\n\n\n\nCode\n#p_l\nif (A - B - C + D)!=0: p_l = ( D-C)/(A - B - C + D)\n\n#print(round(p_l, 2))\n\n#p_o\nif (-b + d)/(a - b - c + d)!=0: p_o = (-b + d)/(a - b - c + d)\n\n#print(round(p_o, 2))\n\n\n# Ausgabe Abhängig von Bedingungen\n\nif (#Anzahl_NGG == 1 or\n    p_o &lt; 0 or p_l &lt; 0 or\n            p_o &gt; 1 or p_l &gt; 1 or\n            (a - b - c + d) == 0 or\n            (A - B - C + D) == 0):\n    print(\"Kein Nash-Gleichgewicht in gemischten Strategien\")\nelse:   print(f\"Gemischte Strategien: p_o= {round(p_o, 2)}, p_l= {round(p_l, 2)}\")\n\n\nGemischte Strategien: p_o= 0.5, p_l= 0.5\n\n\n\n\nCode\nimport sympy as sp\nimport numpy as np\nfrom lets_plot import *\n\n# Symbolische Berechnung des Gleichgewichts mit sympy\np = sp.symbols('p')\nF_II = p * D + (1 - p) * B\nF_I = p * C + (1 - p) * A\nequilibrium_eq = sp.Eq(F_II, F_I)\nequilibrium_p = sp.solve(equilibrium_eq, p)[0]\nprint(f\"Das Gleichgewicht liegt bei p = {equilibrium_p}\")\n\n# Parameter für die Simulation\ngenerations = 100\np_value = 0.5  # Startanteil der Strategie II\nq_value=1-p_value\ndt = 0.1\np_values = [p_value]\nq_values = [q_value]\n\nsigma=0\n\n\n# Simulation\nfor _ in range(generations):\n    F_II_val = p_value * D + (1 - p_value) * B\n    F_I_val = p_value * C + (1 - p_value) * A\n    F_avg = p_value * F_II_val + (1 - p_value) * F_I_val\n    dp_dt = p_value * (F_II_val - F_avg)  + np.random.normal(loc=0, scale=sigma) # noise\n    p_value += dp_dt * dt\n    p_values.append(p_value)\n    q_values.append(1-p_value)\n\n# Daten für den Plot vorbereiten\n\ndata = {\n    'Generation': list(range(generations + 1))*2,\n    'Strategien': [item for item in [\"Strategie I\",\"Strategie II\"] for _ in range (generations + 1)],\n    'Anteile'   : q_values + p_values\n}\n\n# print(data)\n\n# Plot mit lets-plot\n\nLetsPlot.setup_html()\n\np = (ggplot(data, aes(x='Generation', y='Anteile', color='Strategien')) +\n     geom_line() +\n     geom_hline(yintercept=float(equilibrium_p), color='red', linetype='dashed', size=1) +\n     ggtitle('Evolution im Anti-Koordinationsspiel') +\n     xlab('Generation') +\n     ylab('Anteil der Strategien') +\n     theme_minimal() #+\n #    + geom_text(x=11, y=float(equilibrium_p) + 0.05,\n #                label=f'Gleichgewicht p = {round(equilibrium_p, 2)}', color='red')\n)\n\n# Plot anzeigen\np.show()\n\n\nDas Gleichgewicht liegt bei p = 1/2\n\n\n\n            \n            \n            \n\n\n   \n   \n\n\n\n\nCode\nimport numpy as np\nimport sympy as sp\nfrom lets_plot import *\n\nLetsPlot.setup_html()\n\n\n# Symbolische Berechnung des Gleichgewichts mit sympy\np = sp.symbols('p')\nF_II = p * D + (1 - p) * B\nF_I = p * C + (1 - p) * A\nequilibrium_eq = sp.Eq(F_II, F_I)\nequilibrium_p = sp.solve(equilibrium_eq, p)[0]\nprint(f\"Das Gleichgewicht liegt bei p = {equilibrium_p}\")\n\n\n\nseeds = [123, 124, 125, 126]\nplots = []\n\nrunde = 0\n\nfor seed in seeds:\n    # Parameter (Beispielwerte, bitte ggf. anpassen)\n    runde=runde+1\n    generations = 100\n #   A, B, C, D = 1, 2, 3, 4\n    sigma = 0.1\n    dt = 0.1\n  #  equilibrium_p = 0.5  # Beispielwert\n\n    np.random.seed(seed)\n    p_value = 0.5\n    p_values = [p_value]\n    q_values = [1 - p_value]\n\n    # Simulation\n    for _ in range(generations):\n        F_II_val = p_value * D + (1 - p_value) * B\n        F_I_val = p_value * C + (1 - p_value) * A\n        F_avg = p_value * F_II_val + (1 - p_value) * F_I_val\n        dp_dt = p_value * (F_II_val - F_avg) + np.random.normal(loc=0, scale=sigma)\n        p_value += dp_dt * dt\n        p_values.append(p_value)\n        q_values.append(1 - p_value)\n\n    # Daten für den Plot vorbereiten\n    data = {\n        'Generation': list(range(generations + 1)) * 2,\n        'Strategien': [item for item in [\"Strategie I\", \"Strategie II\"] for _ in range(generations + 1)],\n        'Anteile': q_values + p_values\n    }\n\n    # Plot erstellen\n    p = (\n        ggplot(data, aes(x='Generation', y='Anteile', color='Strategien')) +\n        geom_line() +\n        geom_hline(yintercept=float(equilibrium_p), color='red', linetype='dashed', size=1) +\n        ggtitle(f'Runde {runde}') +\n        xlab('Generation') +\n        ylab('Anteil der Strategien') +\n        theme_minimal() #+\n      #  geom_text(x=11, y=float(equilibrium_p) + 0.05,\n      #            label=f'Gleichgewicht p = {round(equilibrium_p, 2)}', color='red')\n    )\n    plots.append(p)\n\n# Plots im 2x2-Grid anzeigen\ngggrid(plots, ncol=2)\n\n\n\n            \n            \n            \nEvolution im Anti-Koordinationsspiel mit noise\n\n\nDas Gleichgewicht liegt bei p = 1/2\n\n\n   \n   \n\n\nDer Evolutionsprozess konvergiert immer gegen die Anteile entsprechend des Nash-Gleichgewichts in gemischten Strategien\n\n\n3.4.2.3 Falke-Tauben-Spiel\n\n\nCode\n# Python\n\n\nA= 2\na= 2\nB= 4\nb= 0\nC= 0\nc= 4\nD= -1\nd= -1\n\n\nfrom lets_plot import *\n\nLetsPlot.setup_html()\n\nggplot() + \\\ngeom_text(x=- .5, y= 2   , label=a) +\\\ngeom_text(x=-1.5, y=  .75, label=A) +\\\ngeom_text(x=- .5, y=-1   , label=b) +\\\ngeom_text(x=-1.5, y=-2.25, label=B) +\\\ngeom_text(x= 1.5, y= 2   , label=c) +\\\ngeom_text(x=  .5, y=  .75, label=C) +\\\ngeom_text(x= 1.5, y=-1   , label=d) +\\\ngeom_text(x=  .5, y=-2.25, label=D) +\\\ngeom_text(x=-1  , y= 3.3 , label='Taube')+\\\ngeom_text(x= 1  , y= 3.3 , label='Falke')+\\\ngeom_text(x=-2.2, y= 1.375, angle=90, label='Taube')+\\\ngeom_text(x=-2.2, y=-1.625, angle=90, label='Falke')+\\\ngeom_text(x= 0 , y= 4 ,\n          fontface = \"bold\", label='Spieler 2')+\\\ngeom_text(x=-2.7 , y= 0 , angle=90,\n          fontface = \"bold\", label='Spieler 1')+\\\ngeom_segment(x=-2,  xend= 2, y= 0, yend= 0) +\\\ngeom_segment(x=-2,  xend= 2, y= 3, yend= 3) +\\\ngeom_segment(x=-2,  xend= 2, y=-3, yend=-3) +\\\ngeom_segment(x=-2,  xend=-2, y=-3, yend= 3) +\\\ngeom_segment(x= 0,  xend= 0, y=-3, yend= 3) +\\\ngeom_segment(x= 2,  xend= 2, y=-3, yend= 3) +\\\ntheme_void()+\\\nlabs(title='Auszahlungen Tauben und Falken')\n\n\n\n            \n            \n            \n\n\n   \n   \n\n\n\n\nCode\n#p_l\nif (A - B - C + D)!=0: p_l = ( D-C)/(A - B - C + D)\n\n#print(round(p_l, 2))\n\n#p_o\nif (-b + d)/(a - b - c + d)!=0: p_o = (-b + d)/(a - b - c + d)\n\n#print(round(p_o, 2))\n\n\n# Ausgabe Abhängig von Bedingungen\n\nif (#Anzahl_NGG == 1 or\n    p_o &lt; 0 or p_l &lt; 0 or\n            p_o &gt; 1 or p_l &gt; 1 or\n            (a - b - c + d) == 0 or\n            (A - B - C + D) == 0):\n    print(\"Kein Nash-Gleichgewicht in gemischten Strategien\")\nelse:   print(f\"Gemischte Strategien: p_o= {round(p_o, 2)}, p_l= {round(p_l, 2)}\")\n\n\nGemischte Strategien: p_o= 0.33, p_l= 0.33\n\n\n\n\nCode\nimport sympy as sp\nfrom lets_plot import *\n\n# Symbolische Berechnung des Gleichgewichts mit sympy\np = sp.symbols('p')\nF_falke = p * D + (1 - p) * B\nF_taube = p * C + (1 - p) * A\nequilibrium_eq = sp.Eq(F_falke, F_taube)\nequilibrium_p = sp.solve(equilibrium_eq, p)[0]\nprint(f\"Das Gleichgewicht liegt bei p = {equilibrium_p}\")\n\n# Parameter für die Simulation\ngenerations = 100\np_value = 0.2  # Startanteil der Falken\ndt = 0.1\np_values = [p_value]\n\n# Simulation\nfor _ in range(generations):\n    F_falke_val = p_value * D + (1 - p_value) * B\n    F_taube_val = p_value * C + (1 - p_value) * A\n    F_avg = p_value * F_falke_val + (1 - p_value) * F_taube_val\n    dp_dt = p_value * (F_falke_val - F_avg)\n    p_value += dp_dt * dt\n    p_values.append(p_value)\n\n# Daten für den Plot vorbereiten\ndata = {\n    'Generation': list(range(generations + 1)),\n    'Anteil_Falken': p_values\n}\n\n# Plot mit lets-plot\n\nLetsPlot.setup_html()\n\np = (ggplot(data, aes(x='Generation', y='Anteil_Falken')) +\n     geom_line(color='blue', size=1, tooltips=layer_tooltips().line('@Anteil_Falken')) +\n     geom_hline(yintercept=float(equilibrium_p), color='red', linetype='dashed', size=1) +\n     ggtitle('Evolution im Falke-Tauben-Spiel') +\n     xlab('Generation') +\n     ylab('Anteil der Falken') +\n     theme_minimal() #+\n    # + geom_text(x=11, y=float(equilibrium_p) + 0.05,\n     #            label=f'Gleichgewicht p = {round(equilibrium_p, 2)}', #color='red')\n)\n\n# Plot anzeigen\np.show()\n\n\nDas Gleichgewicht liegt bei p = 2/3\n\n\n\n            \n            \n            \n\n\n   \n   \n\n\n\n\n\n3.4.3 Diskussion und Ausblick\n\nWofür (evolutionäre) Spieltheorie?\nNur eine Heuristik?\nIst das so wenig?\n\n\n\n\n\nWinter, Stefan. 2019. Grundzüge der Spieltheorie. Ein Lehr- und Arbeitsbuch für das (Selbst-)Studium. Berlin Heidelberg.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Nicht-kooperative Spieltheorie</span>"
    ]
  },
  {
    "objectID": "Verhaltensoekonomik.html",
    "href": "Verhaltensoekonomik.html",
    "title": "4  Verhaltensökonomik",
    "section": "",
    "text": "4.1 Einleitung",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Verhaltensökonomik</span>"
    ]
  },
  {
    "objectID": "Verhaltensoekonomik.html#unrealistische-annahmen-vs.-realistische-modellierung",
    "href": "Verhaltensoekonomik.html#unrealistische-annahmen-vs.-realistische-modellierung",
    "title": "4  Verhaltensökonomik",
    "section": "4.2 Unrealistische Annahmen vs. realistische Modellierung",
    "text": "4.2 Unrealistische Annahmen vs. realistische Modellierung\n\n\nCode\nlibrary(tidyverse)\n\n\nset.seed(123)\nAnzahl &lt;- 150\n\ndf &lt;- data.frame(Farbe=c(rep(\"rot\", Anzahl), rep(\"blau\", Anzahl))\n) %&gt;% mutate(x=(ifelse(Farbe==\"rot\", 0, 1)),\n              y=0)\n# head(df)\n\ndf %&gt;% ggplot(aes(x,y, color=Farbe))+\ngeom_jitter(width= 1.3, alpha=.5, size=3)+\nscale_color_manual(values=c(\"blue\", \"red\"))+\ntheme_void()+\nlabs(title=\"Rote und blaue Punkte\",\n     caption=\"Abbildung: Jan S. Voßwinkel\")\n\n\n\n\n\n\n\n\n\nUnd jetzt reden wir über Musgrave (1981)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Verhaltensökonomik</span>"
    ]
  },
  {
    "objectID": "Verhaltensoekonomik.html#flat-rate-bias",
    "href": "Verhaltensoekonomik.html#flat-rate-bias",
    "title": "4  Verhaltensökonomik",
    "section": "4.3 Flat-Rate Bias",
    "text": "4.3 Flat-Rate Bias\n\nTafelaufschrieb",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Verhaltensökonomik</span>"
    ]
  },
  {
    "objectID": "Verhaltensoekonomik.html#die-prospect-theory",
    "href": "Verhaltensoekonomik.html#die-prospect-theory",
    "title": "4  Verhaltensökonomik",
    "section": "4.4 Die Prospect Theory",
    "text": "4.4 Die Prospect Theory\n\n4.4.1 Eine Nutzenfunktion\n\n\nCode\nlibrary(ggplot2)\n\n#  Sigmoid-Funktion\nsigmoid_sym &lt;- function(x, k, lambda) {\n  ifelse(x&gt;=0, x / (1 + abs(x)^k)^(1/k),\n         (lambda)*x / (1 + abs(x)^k)^(1/k))\n}\n\n# Daten erzeugen\ndf &lt;- data.frame(x = seq(-5, 5, length.out = 200))\ndf$y &lt;- sigmoid_sym(df$x, k = .88, lambda=2.25)\n\n# Hilfslinien und Achsen-Breaks\nx_vals &lt;- c(-3, -2, -1, 1, 2, 3)\ny_vals &lt;- sigmoid_sym(x_vals, k = .88, lambda=2.25)\nlines_df &lt;- data.frame(x = x_vals, y = y_vals)\n\np &lt;- ggplot(df, aes(x, y)) +\n  geom_line(size = 1.2, color = \"blue\") +\n  # Vertikale Hilfslinien\n  geom_segment(\n    data = lines_df,\n    aes(x = x, xend = x, y = 0, yend = y),\n    linetype = \"dashed\", color = \"red\"\n  ) +\n  # Horizontale Hilfslinien\n  geom_segment(\n    data = lines_df,\n    aes(x = x, xend = 0, y = y, yend = y),\n    linetype = \"dashed\", color = \"red\"\n  ) +\n  # Achsen durch den Ursprung\n  geom_hline(yintercept = 0, color = \"black\", linewidth = 0.8) +\n  geom_vline(xintercept = 0, color = \"black\", linewidth = 0.8) +\n  # Achsen-Breaks\n  scale_x_continuous(breaks = c(-2, -1, 0, 1, 2)) +\n  scale_y_continuous(breaks = c(round(y_vals, 2), 0)) +\n  labs(title = \"Eine Nutzenfunktion nach der Prospect Theory\",\n       x = \"Zugang von Gütern\", y = \"Nutzen\") +\n  theme_light() +\n  theme(panel.border = element_blank(),\n        axis.line = element_blank())\n\n# p\n\np+ coord_cartesian(xlim = c(0, 5), ylim = c(0, 1))+\n  ggtitle(\"Eine Nutzenfunktion\")\n\n\n\n\n\nEine Nutzenfunktion\n\n\n\n\n\n\n4.4.2 Eine Wertefunktion nach der Prospect Theory\n\n\nCode\np\n\n\n\n\n\nEine Wertefunktion nach der Prospect Theory\n\n\n\n\n\n\n\n\n\n\nWertefunktion im Original\n\n\n\n\n\n\n\nCode\nlibrary(ggplot2)\n\n# Symmetrische Wertefunktion\n\nlambda &lt;- -2.25\nalpha &lt;- .88\nbeta &lt;- .88\n\nprospect &lt;- function(x) {ifelse(x&lt;0,\n                         lambda* ((-1)*x)^beta,\n                         x^alpha)\n}\n\n# Daten erzeugen\ndf &lt;- data.frame(x = seq(-5, 5, length.out = 200))\ndf$y &lt;- prospect(df$x)\n\n# Hilfslinien und Achsen-Breaks\nx_vals &lt;- c(-3, -2, -1, 1, 2, 3)\ny_vals &lt;- prospect(x_vals)\nlines_df &lt;- data.frame(x = x_vals, y = y_vals)\n\n ggplot(df, aes(x, y)) +\n  geom_line(size = 1.2, color = \"blue\") +\n  # Vertikale Hilfslinien\n  geom_segment(\n    data = lines_df,\n    aes(x = x, xend = x, y = 0, yend = y),\n    linetype = \"dashed\", color = \"red\"\n  ) +\n  # Horizontale Hilfslinien\n  geom_segment(\n    data = lines_df,\n    aes(x = x, xend = 0, y = y, yend = y),\n    linetype = \"dashed\", color = \"red\"\n  ) +\n  # Achsen durch den Ursprung\n  geom_hline(yintercept = 0, color = \"black\", linewidth = 0.8) +\n  geom_vline(xintercept = 0, color = \"black\", linewidth = 0.8) +\n  # Achsen-Breaks\n  scale_x_continuous(breaks = c(-2, -1, 0, 1, 2)) +\n  scale_y_continuous(breaks = c(round(y_vals, 2), 0)) +\n  labs(title = \"Eine Nutzenfunktion nach der Prospect Theory\",\n       subtitle = \"Parameter nach Kahnemann & Tversky\",\n       x = \"Zugang von Gütern\", y = \"Nutzen\") +\n  theme_light() +\n  theme(panel.border = element_blank(),\n        axis.line = element_blank())\n\n\n\n\n\nWertefunktion im Original\n\n\n\n\n\n\n\n\n\n4.4.3 Wahrscheinlichkeitsgewichtung\n\nIm Rahmen der Prospect Theory geht man davon aus, dass Entscheidungen nicht unmittelbar auf Wahrscheinlichkeiten beruhen, sondern auf Gewichtungen \\(w(p)\\), die eine Funktion der Wahrscheinlichkeit sind\nDabei werden kleine Wahrscheinlichkeiten übergewichtet und hohe Wahrscheinlichkeiten untergewichtet\n\n\n\nCode\nlibrary(ggplot2)\n\n# Definition der Gewichtungsfunktion nach Kahneman/Tversky\nweighting_function &lt;- function(p, gamma = 0.61) {\n  p^gamma / (p^gamma + (1-p)^gamma)^(1/gamma)\n}\n\n# Daten erstellen\nprobabilities &lt;- seq(0.01, 0.99, by = 0.01)\nweights &lt;- weighting_function(probabilities)\ndf &lt;- data.frame(p = probabilities, w = weights)\n\n# Plot erstellen\nggplot(df, aes(x = p)) +\n  geom_line(aes(y = w), color = \"blue\", linewidth = 1) +  # Gewichtungsfunktion\n  geom_line(aes(y = p), color = \"black\", linetype = \"dashed\") +  # Referenzdiagonale\n  geom_ribbon(aes(ymin = p, ymax = ifelse(w &gt; p, w, p)),\n              fill = \"green\", alpha = 0.3) +  # Übergewichtungsbereich\n  geom_ribbon(aes(ymin = ifelse(w &lt; p, w, p), ymax = p),\n              fill = \"red\", alpha = 0.3) +  # Untergewichtungsbereich\n  labs(title = \"Wahrscheinlichkeitsgewichtungsfunktion nach Kahneman & Tversky\",\n     #  subtitle = expression(paste(\"Parameter \", gamma, \" = 0.61\")),\n       x = \"Objektive Wahrscheinlichkeit (p)\",\n       y = \"Subjektive Gewichtung w(p)\",\n       caption = \"Abbildung: Jan S. Voßwinkel\") +\n  #scale_x_continuous(breaks = seq(0, 1, 0.1)) +\n  #scale_y_continuous(breaks = seq(0, 1, 0.1)) +\n  theme_minimal()\n\n\n\n\n\nWahrscheinlichkeitsgewichtung\n\n\n\n\nEine mögliche Form der Gewichtung:\n\\(w(p) = \\frac{p^{\\gamma}}{\\left[ p^{\\gamma} + (1-p)^{\\gamma} \\right]^{1/\\gamma}}\\)\n\n\nCode\nlibrary(ggplot2)\n\n# Definition der Gewichtungsfunktion nach Kahneman/Tversky\nweighting_function &lt;- function(p, gamma) {\n  p^gamma / (p^gamma + (1-p)^gamma)^(1/gamma)\n}\n\n# Daten erstellen\nprobabilities &lt;- seq(0.01, 0.99, by = 0.01)\ndf &lt;- data.frame(\n  p = rep(probabilities, 2),\n  w = c(weighting_function(probabilities, gamma = 0.61),\n        weighting_function(probabilities, gamma = 0.69)),\n  gamma = factor(rep(c(\"positive Ereignisse\", \"negative Ereignisse\"), each = length(probabilities)))\n)\n\n# Plot erstellen\nggplot(df, aes(x = p, y = w, color = gamma)) +\n  geom_line(linewidth = 1) +\n  geom_line(aes(x = p, y = p), color = \"black\", linetype = \"dashed\", linewidth = 0.8, inherit.aes = FALSE) +\n  labs(\n    title = \"Wahrscheinlichkeitsgewichtungsfunktion nach Kahneman & Tversky\",\n    subtitle=\"Unterschiedliche Gewichtungen bei positiven und negativen Ereignissen\",\n    x = \"Objektive Wahrscheinlichkeit p\",\n    y = \"Subjektive Gewichtung w(p)\",\n    color = \"Ereignisart\",\n    caption = \"Abbildung: Jan S. Voßwinkel\"\n  ) +\n  theme_minimal()\n\n\n\n\n\nWahrscheinlichkeitsgewichtung bei positiven und negativen Ereignissen",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Verhaltensökonomik</span>"
    ]
  },
  {
    "objectID": "Verhaltensoekonomik.html#mental-accounting",
    "href": "Verhaltensoekonomik.html#mental-accounting",
    "title": "4  Verhaltensökonomik",
    "section": "4.5 Mental Accounting",
    "text": "4.5 Mental Accounting\n\nTafelaufschrieb",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Verhaltensökonomik</span>"
    ]
  },
  {
    "objectID": "Verhaltensoekonomik.html#der-status-quo-bias",
    "href": "Verhaltensoekonomik.html#der-status-quo-bias",
    "title": "4  Verhaltensökonomik",
    "section": "4.6 Der Status-quo Bias",
    "text": "4.6 Der Status-quo Bias",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Verhaltensökonomik</span>"
    ]
  },
  {
    "objectID": "Verhaltensoekonomik.html#umgang-mit-risiken",
    "href": "Verhaltensoekonomik.html#umgang-mit-risiken",
    "title": "4  Verhaltensökonomik",
    "section": "4.7 Umgang mit Risiken",
    "text": "4.7 Umgang mit Risiken\n\n4.7.1 Erwartungsnutzentheorie\n\nErwartungswert als Kriterium unplausibel: St. Petersburg Paradox\nStattdessen: Erwartungsnutzen\nNutzen des Erwartunswerts \\(\\neq\\) Erwartungswert des Nutzens (\\(U(EW)\\neq EW(U)\\))\nAxiome der Erwartungsnutzentheorie:\n\nVollständigkeit: FÜr alle Alternativen \\(A\\) und \\(B\\) gilt entweder \\(A \\succeq B\\) oder \\(A \\preceq B\\) oder beide Bedingungen\nTransitivität: Aus \\(A \\preceq B\\) und \\(B \\preceq C\\) folgt \\(A \\preceq C\\)\nStetigkeit: Für alle Alternativen \\(A, B, C\\) mit \\(A \\preceq B\\) und \\(B \\preceq C\\) existiert eine Wahrscheinlichkeit \\(p\\), sodass gilt \\(pA+(1-p)C \\sim B\\)\nUnabhängigkeit: Für alle Alternativen \\(A, B, C\\) mit \\(A \\preceq B\\) gilt \\(pA+(1-p)C \\preceq pB+(1-p)C\\)\n\n\nVerlauf des Erwartungsnutzens (s. Tafelaufschrieb)\n\n\n4.7.2 Allais-Paradoxon\n\n\nCode\nlibrary(knitr)\nlibrary(tidyverse)\nlibrary(kableExtra)\n\ndf &lt;- data.frame(Farbe=c(\"schwarz\", \"weiß\", \"rot\"),\n                  Anzahl=c(10, 89, 1),\n                 A=c(1000, 1000, 1000),\n                 B=c(5000, 1000, 0),\n                 C=c(1000, 0, 1000),\n                 D=c(5000, 0, 0)\n)\n\n# head(df)\n\nkable(df, \"html\") %&gt;%\nadd_header_above(c(\"Urne\" = 2, \"Spiel\" = 4), line = FALSE)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUrne\n\n\nSpiel\n\n\n\nFarbe\nAnzahl\nA\nB\nC\nD\n\n\n\n\nschwarz\n10\n1000\n5000\n1000\n5000\n\n\nweiß\n89\n1000\n1000\n0\n0\n\n\nrot\n1\n1000\n0\n1000\n0\n\n\n\n\n\n\nWelches Spiel wird bevorzugt?\n\nA vs. B\nC vs. D\n\nErwartungsnutzentheorie: Konsistenz des Vergleichs (wenn A (B), dann C (D))\nEmpirie: A, aber D\nWie kann das sein?\n\n\n\nCode\n# Wahrscheinlichkeitsdreiecke\nlibrary(tidyverse)\n\ns1 &lt;- 110 # Schritte p1\n\nsu &lt;- 35 # Schritte u\n\ndf &lt;- data.frame(\n         p1= rep(seq(0, 1, length.out=s1), su), # X-Achse\n         u = rep(seq(-2.9, 1, length.out=su), each=s1), # Einzelne Indifferenzkurven\n         Steigung = rep(c(.3, 2.5),  each=s1*su) # Steigungen der Indifferenzkurven #(p1 und u werden automatisch verdoppelt?)\n) %&gt;% mutate(p3=u + Steigung *p1, # Gleichung für Indifferenzkurven\n              label=ifelse(Steigung==.3, \"flach\", \"steil\")) %&gt;%\n      group_by(Steigung,  u)%&gt;%\n      filter(p3&lt;=1-p1 & p3&gt;=0)\n\n# head(df)\n\n# Punkte\n\nPunkte &lt;- data.frame(Namen=c(\"A\", \"B\", \"C\", \"D\"),\n                         x=c(0, .06, .84, .90),\n                         y=c(0, .1, 0, .1))\n\n# head(Punkte)\n\n# Grafik\n\ndf%&gt;% ggplot(aes(p1, p3, group=u))+\n        geom_line()+\n        geom_abline(slope=-1, intercept=1, color=\"blue\", linewidth=1)+\n        geom_hline(yintercept= 0, color= \"blue\", linewidth=1)+\n        geom_vline(xintercept= 0, color= \"blue\",  linewidth=1)+\n        geom_point(data=Punkte, aes(x, y, group=Namen), size=2)+\n        scale_x_continuous(limits = c(0, 1), expand=c(0.01,0.01)\n) +\n        scale_y_continuous(limits = c(0, 1), expand=c(0.01,0.01)\n) +\n       # expand_limits(x = 0, y = 0)+\n        theme_light()+\n        facet_wrap(~label)\n\n\n\n\n\n\n\n\n\nTafelaufschrieb\n\n\nCode\n# Wahrscheinlichkeitsdreiecke\nlibrary(tidyverse)\n\ns1 &lt;- 300 # Schritte p1\n\nsu &lt;- 100 # Schritte u\n\ndf &lt;- data.frame(\n         p1= rep(seq(0, 1, length.out=s1), su), # X-Achse\n         u = rep(seq(-3.9, 3, length.out=su), each=s1) #, # Einzelne Indifferenzkurven\n        # Steigung = rep(.5),  each=s1*su\n         ) %&gt;%\n  mutate(Steigung= (u+4)^2-9, # Steigung ändert sich mit jeder Indifferenzkurve. Konkrete zahlen sind \"gebastelt\"\n    p3=u + Steigung *p1, # Gleichung für Indifferenzkurven\n              ) %&gt;%\n      group_by(Steigung,  u)%&gt;%\n      filter(p3&lt;=1-p1 & p3&gt;=0)\n\n# head(df)\n\n# Punkte\n\nPunkte &lt;- data.frame(Namen=c(\"A\", \"B\", \"C\", \"D\"),\n                         x=c(0, .06, .84, .90),\n                         y=c(0, .1, 0, .1))\n\n# head(Punkte)\n\n# Grafik\n\ndf%&gt;% ggplot(aes(p1, p3, group=u))+\n        geom_line()+\n        geom_abline(slope=-1, intercept=1, color=\"blue\", linewidth=1)+\n        geom_hline(yintercept= 0, color= \"blue\", linewidth=1)+\n        geom_vline(xintercept= 0, color= \"blue\",  linewidth=1)+\n        geom_point(data=Punkte, aes(x, y, group=Namen), size=2)+\n        scale_x_continuous(limits = c(0, 1), expand=c(0.01,0.01)\n) +\n        scale_y_continuous(limits = c(0, 1), expand=c(0.01,0.01)\n) +\n       # expand_limits(x = 0, y = 0)+\n        theme_light()",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Verhaltensökonomik</span>"
    ]
  },
  {
    "objectID": "Verhaltensoekonomik.html#kritische-diskussion-der-verhaltensökonomik",
    "href": "Verhaltensoekonomik.html#kritische-diskussion-der-verhaltensökonomik",
    "title": "4  Verhaltensökonomik",
    "section": "4.8 Kritische Diskussion der Verhaltensökonomik",
    "text": "4.8 Kritische Diskussion der Verhaltensökonomik\n\n\n\n\nMusgrave, Allen. 1981. “Unreal Assumptions in Economic Theory. The f-Twist Untwisted.” Kyklos 34: 377–87.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Verhaltensökonomik</span>"
    ]
  },
  {
    "objectID": "Spieltheorie.html#einleitung",
    "href": "Spieltheorie.html#einleitung",
    "title": "3  Nicht-kooperative Spieltheorie",
    "section": "4.1 Einleitung",
    "text": "4.1 Einleitung",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Nicht-kooperative Spieltheorie</span>"
    ]
  },
  {
    "objectID": "Spieltheorie.html#flat-rate-bias",
    "href": "Spieltheorie.html#flat-rate-bias",
    "title": "3  Nicht-kooperative Spieltheorie",
    "section": "4.2 Flat-rate bias",
    "text": "4.2 Flat-rate bias",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Nicht-kooperative Spieltheorie</span>"
    ]
  },
  {
    "objectID": "Spieltheorie.html#mental-accounting",
    "href": "Spieltheorie.html#mental-accounting",
    "title": "3  Nicht-kooperative Spieltheorie",
    "section": "4.3 Mental Accounting",
    "text": "4.3 Mental Accounting",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Nicht-kooperative Spieltheorie</span>"
    ]
  },
  {
    "objectID": "Spieltheorie.html#prospect-theory",
    "href": "Spieltheorie.html#prospect-theory",
    "title": "3  Nicht-kooperative Spieltheorie",
    "section": "4.4 Prospect Theory",
    "text": "4.4 Prospect Theory",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Nicht-kooperative Spieltheorie</span>"
    ]
  },
  {
    "objectID": "Spieltheorie.html#status-quo-bias",
    "href": "Spieltheorie.html#status-quo-bias",
    "title": "3  Nicht-kooperative Spieltheorie",
    "section": "4.5 Status-quo bias",
    "text": "4.5 Status-quo bias",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Nicht-kooperative Spieltheorie</span>"
    ]
  },
  {
    "objectID": "Spieltheorie.html#umgang-mit-risiken",
    "href": "Spieltheorie.html#umgang-mit-risiken",
    "title": "3  Nicht-kooperative Spieltheorie",
    "section": "4.6 Umgang mit Risiken",
    "text": "4.6 Umgang mit Risiken\n\n4.6.1 Erwartungsnutzen\n\nErwartungswert als Kriterium unplausibel: St. Petersburg Paradox\nStattdessen: Erwartungsnutzen\nNutzen des Erwartunswerts \\(\\neq\\) Erwartungswert des Nutzens (\\(U(EW)\\neq EW(U)\\))\nAxiome der Erwartungsnutzentheorie:\n\nVollständigkeit: FÜr alle Alternativen \\(A\\) und \\(B\\) gilt entweder \\(A \\succeq B\\) oder \\(A \\preceq B\\) oder beide Bedingungen\nTransitivität: Aus \\(A \\preceq B\\) und \\(B \\preceq C\\) folgt \\(A \\preceq C\\)\nStegitgkeit: Für alle Alternativen \\(A, B, C\\) mit \\(A \\preceq B\\) und \\(B \\preceq C\\) existiert eine Wahrscheinlichkeit \\(p\\), sodass gilt \\(pA+(1-p)C \\sim B\\)\nUnabhängigkeit: Für alle Alternativen \\(A, B, C\\) mit \\(A \\preceq B\\) gilt \\(pA+(1-p)C \\preceq pB+(1-p)C\\)\n\n\n\n\n4.6.2 Allais-Paradoxon\n```",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Nicht-kooperative Spieltheorie</span>"
    ]
  },
  {
    "objectID": "intro.html#modul-analyse-von-kooperations--und-konfliktstrukturen",
    "href": "intro.html#modul-analyse-von-kooperations--und-konfliktstrukturen",
    "title": "1  Einleitung",
    "section": "",
    "text": "Unter welchen Bedingugungen gelingt Kooperation im Team\nWie gelingt es, Konfliktstrukturen aufzubrechen, um Kooperation zu ermöglichen?\nWann ist Kooperation rational?\nBerücksichtigung „menschlicher Schwächen“",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "intro.html#ökonomische-modellierung-menschlichen-verhaltens",
    "href": "intro.html#ökonomische-modellierung-menschlichen-verhaltens",
    "title": "1  Einleitung",
    "section": "1.2 Ökonomische Modellierung menschlichen Verhaltens",
    "text": "1.2 Ökonomische Modellierung menschlichen Verhaltens\n\nMethodologischer Individualismus\n\nSituationslogik erlaubt Verknüpfung von Situation, Zielen und Handlung\nRationalität\n\nStrenge Rationalität\nBeschränkte Rationalität\nVerhaltensökonomik\n\nRationalität als Konzept\nRationalität als Behauptung über einen Sachverhalt\nRationalität als Analysegrammatik",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "Uebungsaufgaben.html",
    "href": "Uebungsaufgaben.html",
    "title": "Übungsaufgaben",
    "section": "",
    "text": "Bitte geben Sie für die folgenden Spiele jeweils an, ob es kein, ein oder mehrere Nash-Gleichgewichte in reinen Strategien gibt, und benennen Sie diese.\nBitte geben Sie die Nash-Gleichgewichte in gemischten Strategien an.\n\n\n\nCode\nimport numpy as np\nimport random\nimport pandas as pd\n\nfrom lets_plot import *\nfrom IPython.display import display, HTML\n\nLetsPlot.setup_html()\n\n\ndef create_plot(a, A, b, B, c, C, d, D, Spiel):\n    LetsPlot.setup_html()\n    return (\n        ggplot() +\n        geom_text(x=-0.5, y=2, label=a) +\n        geom_text(x=-1.5, y=0.75, label=A) +\n        geom_text(x=-0.5, y=-1, label=b) +\n        geom_text(x=-1.5, y=-2.25, label=B) +\n        geom_text(x=1.5, y=2, label=c) +\n        geom_text(x=0.5, y=0.75, label=C) +\n        geom_text(x=1.5, y=-1, label=d) +\n        geom_text(x=0.5, y=-2.25, label=D) +\n        geom_text(x=-1, y=3.3, label='links') +\n        geom_text(x=1, y=3.3, label='rechts') +\n        geom_text(x=-2.2, y=1.375, angle=90, label='oben') +\n        geom_text(x=-2.2, y=-1.625, angle=90, label='unten') +\n        geom_text(x=0 , y=4 , fontface=\"bold\", label='Spieler 2') +\n        geom_text(x=-2.7 , y=0 , angle=90 , fontface=\"bold\", label='Spieler 1') +\n        geom_segment(x=-2, xend=2, y=0, yend=0) +\n        geom_segment(x=-2, xend=2, y=3, yend=3) +\n        geom_segment(x=-2, xend=2, y=-3, yend=-3) +\n        geom_segment(x=-2, xend=-2, y=-3, yend=3) +\n        geom_segment(x=0 , xend=0 , y=-3 , yend=3) +\n        geom_segment(x=2 , xend=2 , y=-3 , yend=3) +\n        theme_void() +\n        labs(title=f'Auszahlungen Spiel {Spiel}')\n        )\n\nmyseed = 0\nSpiel = 0\nplots = []\n\n# ! hier Beginn der Schleife, 10 Durchgänge\nresults = []\n\nfor i in range(10):\n    myseed = myseed + 1\n    Spiel = Spiel + 1\n    random.seed(myseed)  # Optional für Reproduzierbarkeit\n\n    while True:\n        A = random.randint(0, 9)\n        a = random.randint(0, 9)\n        B = random.randint(0, 9)\n        b = random.randint(0, 9)\n        C = random.randint(0, 9)\n        c = random.randint(0, 9)\n        D = random.randint(0, 9)\n        d = random.randint(0, 9)\n\n        # Bedingungen prüfen: Keine dominante Strategien\n        cond1 = (A &gt;= B) and (C &gt;= D)\n        cond2 = (B &gt;= A) and (D &gt;= C)\n        cond3 = (a &gt;= c) and (b &gt;= d)\n        cond4 = (c &gt;= a) and (d &gt;= b)\n\n        # Wenn keine Bedingung erfüllt ist, Schleife beenden\n        if not (cond1 or cond2 or cond3 or cond4):\n            break\n\n    p = create_plot(a, A, b, B, c, C, d, D, Spiel)\n\n    # Funktionen für Nash-Bedingungen\n    def is_ol_nash(A, B, a, c):\n        return \"ol\" if (A &gt;= B) and (a &gt;= c) else \"not_ol\"\n\n    def is_ul_nash(B, A, b, d):\n        return \"ul\" if (B &gt;= A) and (b &gt;= d) else \"not_ul\"\n\n    def is_or_nash(C, D, c, a):\n        return \"or\" if (C &gt;= D) and (c &gt;= a) else \"not_or\"\n\n    def is_ur_nash(D, C, d, b):\n        return \"ur\" if (D &gt;= C) and (d &gt;= b) else \"not_ur\"\n\n    # Nash-Bedingungen überprüfen und Strings zuweisen\n    Cand_Nash_ol = is_ol_nash(A, B, a, c)\n    Cand_Nash_ul = is_ul_nash(B, A, b, d)\n    Cand_Nash_or = is_or_nash(C, D, c, a)\n    Cand_Nash_ur = is_ur_nash(D, C, d, b)\n\n    # Ergebnisse kombinieren und NAs entfernen\n    Nash_GG = np.array([Cand_Nash_ol, Cand_Nash_ul, Cand_Nash_or, Cand_Nash_ur])\n    Nash_GG_filtered = []\n    for element in Nash_GG:\n        if element in [\"ol\", \"ul\", \"or\", \"ur\"]:\n            Nash_GG_filtered.append(element)\n\n    # Anzahl der Nash GG\n    Anzahl_NGG = len(Nash_GG_filtered)\n\n    # Wahrscheinlichkeiten ausrechnen\n    p_l = None\n    p_o = None\n    if (A - B - C + D) != 0:\n        p_l = (D - C) / (A - B - C + D)\n    if (a - b - c + d) != 0:\n        p_o = (-b + d) / (a - b - c + d)\n\n    # ! Nash_GG_filtered zusammen mit Aufgabe und p_l in einem data frame speichern.\n    results.append({\n        'Spiel': Spiel,\n        'Nash_GG_filtered': ','.join(Nash_GG_filtered) if Nash_GG_filtered else 'none',\n        'p_l': round(p_l, 2) if p_l is not None else None,\n        'p_o': round(p_o, 2) if p_o is not None else None\n    })\n\n    plots.append(p)\n    display(p)\n\n# Plots ausgeben\n#display(gggrid(plots, ncol=1))\n\n\n\n# ! Data frame ausgeben\n\nresults_df = pd.DataFrame(results)\n#print(results_df)\n\nresults_df.columns=[\"Spiel\", \"Nash GG\",\"p_l\", \"p_o\"]\n\n#display(HTML(results_df.to_html(index=False)))\n\n\n\n            \n            \n            \nSpiele für Übungsaufgaben\n\n\n\n            \n            \n            \n\n\n   \n   \n\n\n\n            \n            \n            \n\n\n   \n   \n\n\n\n            \n            \n            \n\n\n   \n   \n\n\n\n            \n            \n            \n\n\n   \n   \n\n\n\n            \n            \n            \n\n\n   \n   \n\n\n\n            \n            \n            \n\n\n   \n   \n\n\n\n            \n            \n            \n\n\n   \n   \n\n\n\n            \n            \n            \n\n\n   \n   \n\n\n\n            \n            \n            \n\n\n   \n   \n\n\n\n            \n            \n            \n\n\n   \n   \n\n\n\n\n\n\n\n\nLösungen\n\n\n\n\n\n\n\nCode\ndisplay(HTML(results_df.to_html(index=False)))\n\n\n\n\n\nSpiel\nNash GG\np_l\np_o\n\n\n\n\n1\nol,ur\n0.86\n0.60\n\n\n2\nol,ur\n0.11\n0.31\n\n\n3\nul,or\n0.67\n0.29\n\n\n4\nnone\n0.38\n0.83\n\n\n5\nnone\n0.43\n0.73\n\n\n6\nol,ur\n0.50\n0.83\n\n\n7\nol,ur\n0.20\n0.67\n\n\n8\nul,or\n0.43\n0.50\n\n\n9\nul,or\n0.50\n0.36\n\n\n10\nul,or\n0.50\n0.83\n\n\n\nLösungstabelle",
    "crumbs": [
      "Übungsaufgaben"
    ]
  }
]