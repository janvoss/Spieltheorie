[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Spieltheorie und Verhaltensökonomik",
    "section": "",
    "text": "Organisatorisches\n\n\n\n\n\n\n\n\\({}\\)\n\\({}\\)\n\n\n\n\n\n\n\n\n\n\nUnterlagen: https://janvoss.github.io/Spieltheorie/\nModul: 203-039 Wettbewerb und Staat I Modulhandbuch\nWeitere Veranstaltung im ModuL: Industrie- und Regulierungsökonomik, Wettbewerbspolitik\nPrüfungsleistung: K60, diese VL davon 50%",
    "crumbs": [
      "Organisatorisches"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Einleitung",
    "section": "",
    "text": "1.1 Ökomomische Modellierung menschlichen Verhaltens",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "Literatur.html",
    "href": "Literatur.html",
    "title": "Literatur",
    "section": "",
    "text": "Beck, Hanno. 2014. Behavioral Economics: Eine Einführung. Wiesbaden.\n\n\nBerninghaus, Siegfried K., Karl-Martin Ehrhart, and Werner Güth. 2010. Strategische Spiele. Springer-Lehrbuch. Berlin, Heidelberg: Springer. https://doi.org/10.1007/978-3-642-11651-3.\n\n\nDetel, Wolfgang. 2007. Grundkurs Philosophie. Band 5: Philosophie des Sozialen. Stuttgart.\n\n\nGigerenzer, Gerd. 2018. “The Bias Bias in Behavioral Economics.” Review of Behavioral Economics 5: 303–36.\n\n\nHoller, Manfred J., Gerhard Illing, and Stefan Napel. 2019. Einführung in die Spieltheorie. Berlin, Heidelberg: Springer. https://doi.org/10.1007/978-3-642-31963-1.\n\n\nJust, David R. 2014. Introduction to Behavioral Economics. Noneconomic Factors That Shape Economic Decisions. Hoboken NJ.\n\n\nLee, Dwight R., and J. R. Clark. 2017. “Can Behavioral Economists Improve Economic Rationality?” Public Choice 174: 1–18.\n\n\nMusgrave, Allen. 1981. “Unreal Assumptions in Economic Theory. The f-Twist Untwisted.” Kyklos 34: 377–87.\n\n\nWeintraub, E. Roy. 2017. “Game Theory and Cold War Rationality: A Review Essay.” Journal of Economic Literature 55: 148–61.\n\n\nWinter, Stefan. 2019. Grundzüge der Spieltheorie. Ein Lehr- und Arbeitsbuch für das (Selbst-)Studium. Berlin Heidelberg.",
    "crumbs": [
      "Literatur"
    ]
  },
  {
    "objectID": "intro.html#ökomomische-modellierung-menschlichen-verhaltens",
    "href": "intro.html#ökomomische-modellierung-menschlichen-verhaltens",
    "title": "1  Einleitung",
    "section": "",
    "text": "Methodologischer Individualismus\n\nSituationslogik erlaubt Verknüpfung von Situation, Zielen und Handlung\nRationalität\n\nStrenge Rationalität\nBeschränkte Rationalität\nVerhaltensökonomik\n\nRationalität als Konzept\nRationalität als Behauptung über einen Sachverhalt\nRationalität als Analysegrammatik",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "intro.html#formen-des-wettbewerbs",
    "href": "intro.html#formen-des-wettbewerbs",
    "title": "1  Einleitung",
    "section": "1.2 Formen des Wettbewerbs",
    "text": "1.2 Formen des Wettbewerbs\n-Vollkommener Wettbewerb auf Märkten - Innovationswettbewerb - Entdeckungswettbewerb - \\(\\dots\\)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "intro.html#arenen-des-wettbewerbs",
    "href": "intro.html#arenen-des-wettbewerbs",
    "title": "1  Einleitung",
    "section": "1.3 Arenen des Wettbewerbs",
    "text": "1.3 Arenen des Wettbewerbs\n\nMärkte\nOrganisationen\n\ndurch Märkte diszipliniert (Unternehmen)\nnicht durch Märkte diszipliniert (Behörden, Vereine, \\(\\dots\\))",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "intro.html#fazit-zum-modul",
    "href": "intro.html#fazit-zum-modul",
    "title": "1  Einleitung",
    "section": "1.4 Fazit zum Modul",
    "text": "1.4 Fazit zum Modul\n\\(\\rightarrow\\) Im Modul befassen wir uns mit Wettbewerb in unterschiedlichen Kontexten\n\\(\\rightarrow\\) Basis der Überlegungen sind (unterschiedliche) Konzepte über menschliches Verhalten",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "Rationalitaet.html",
    "href": "Rationalitaet.html",
    "title": "2  Rationalität",
    "section": "",
    "text": "2.1 Basisschema der Handlungserklärung\nDas Basisschema ist noch unvollständig:\n\\(\\Rightarrow\\) erweitertes Schema der Handlungserklärung",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Rationalität</span>"
    ]
  },
  {
    "objectID": "Rationalitaet.html#basisschema-der-handlungserklärung",
    "href": "Rationalitaet.html#basisschema-der-handlungserklärung",
    "title": "2  Rationalität",
    "section": "",
    "text": "Person \\(S\\) wünscht, Ziel \\(Z\\) zu realisieren.\n\\(S\\) glaubt, die Handlung \\(H\\) sei ein Mittel, um \\(Z\\) zu realisieren.\n\\(S\\) vollzieht Handlung \\(H\\).\n\n\n\nWas ist, wenn es für \\(S\\) bessere Handlungen als \\(H\\) gibt, \\(Z\\) zu realisieren? Dann wäre es nicht vernünftig, \\(H\\) zu vollziehen.\nWas ist, wenn es \\(S\\) \\(H\\) gar nicht vollziehen kann?\nWas ist, wenn \\(H\\) mit negativen Folgen einhergeht, die schlimmer sind, als \\(Z\\) nicht zu realisieren?\nWas ist, wenn \\(S\\) noch weitere Ziele realisieren will, die mit \\(Z\\) nicht vereinbar sind?",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Rationalität</span>"
    ]
  },
  {
    "objectID": "Rationalitaet.html#erweitertes-schema-der-handlungserklärung",
    "href": "Rationalitaet.html#erweitertes-schema-der-handlungserklärung",
    "title": "2  Rationalität",
    "section": "2.2 Erweitertes Schema der Handlungserklärung",
    "text": "2.2 Erweitertes Schema der Handlungserklärung\n\n\\(S\\) hat die Absicht, Ziel \\(Z\\) zu realisieren.\n\\(S\\) glaubt, dass, wenn sie Handlung \\(H\\) vollzieht, sie somit \\(Z\\) realisieren kann.\n\\(S\\) glaubt in der Lage zu sein, \\(Z\\) zu realisieren und \\(H\\) zu vollziehen.\n\\(S\\) weiß, wie man \\(Z\\) realisiert und \\(H\\) vollzieht.\n\\(S\\) glaubt nicht, dass es etwas Besseres gibt als \\(H\\), um \\(Z\\) zu realisieren.\n\\(S\\) glaubt nicht, dass der Vollzug von \\(H\\) Folgen hat, die schlimmer sind als nicht \\(Z\\) realisieren zu können.\n\\(S\\) hat nicht die Absicht, ein Ziel zu realisieren, von dem \\(S\\) weiß, dass es unvereinbar damit ist, \\(Z\\) zu realisieren, und das sie \\(Z\\) gegenüber vorzieht.\n\\(S\\) vollzieht Handlung \\(H\\).",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Rationalität</span>"
    ]
  },
  {
    "objectID": "Rationalitaet.html#zwischenfazit",
    "href": "Rationalitaet.html#zwischenfazit",
    "title": "2  Rationalität",
    "section": "2.3 Zwischenfazit",
    "text": "2.3 Zwischenfazit\n\nErklärungen rationaler Handlungen unterstellen nicht zwangsläufig, dass die handelnde Person “alles richtig” macht.\nInsbesondere lässt es beschränkte Handlungsmöglichkeiten zu und unvollständige oder fehlerhafte Informationslagen.\nDas Rationalprinzip ist weniger eine Behauptung über die handelnde Person, sondern ein Schema, eine “Grammatik” der Erklärung.\nDiese Grammatik verwenden wir sowohl in der Spieltheorie als auch in der Verhaltensökonomik\n\nSchwerpunkt Spieltheorie: Individuen handeln nach (dem richtigen) mathematischen Kalkül und machen höchstens zufällig Fehler\n\nSchwerpunkt Verhaltensökonomik: Individuen handeln nachvollziehbar, aber nach Kalkülen, die nicht ganz “richtig” sind.\n\n\n\n\n\n\nDetel, Wolfgang. 2007. Grundkurs Philosophie. Band 5: Philosophie des Sozialen. Stuttgart.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Rationalität</span>"
    ]
  },
  {
    "objectID": "Spieltheorie.html",
    "href": "Spieltheorie.html",
    "title": "3  Nicht-kooperative Spieltheorie",
    "section": "",
    "text": "3.1 Einleitung und begriffliche Einordnung",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Nicht-kooperative Spieltheorie</span>"
    ]
  },
  {
    "objectID": "Spieltheorie.html#das-nash-gleichgewicht",
    "href": "Spieltheorie.html#das-nash-gleichgewicht",
    "title": "3  Nicht-kooperative Spieltheorie",
    "section": "3.2 Das Nash-Gleichgewicht",
    "text": "3.2 Das Nash-Gleichgewicht",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Nicht-kooperative Spieltheorie</span>"
    ]
  },
  {
    "objectID": "Spieltheorie.html#simultane-spiele",
    "href": "Spieltheorie.html#simultane-spiele",
    "title": "3  Nicht-kooperative Spieltheorie",
    "section": "3.3 Simultane Spiele",
    "text": "3.3 Simultane Spiele\n\n3.3.1 Grundsätzliche Struktur eines Spiels\n\n\n\nAllgemeines Struktur eines Spiels\n\n\n\n\n3.3.2 Reine Strategien\n\n3.3.2.1 Definition Nash-Gleichgewicht\nEin Nash-Gleichgewicht liegt vor, wenn jeder Spieler die beste Antwort auf die beste Strategie des Gegenspielers spielt.\nFormal:\n\\(u_{i}\\left(s_{i}^{*},s_{-i}^{*}\\right)\\geq u_{i}\\left(s_{i},s_{-i}^{*}\\right)\\mbox{ für alle }i,\\mbox{ }s_{i}\\in S_{i}\\)\nIntuition: Ein Nash-Gleichgewicht liegt vor, wenn kein Spieler mehr die Möglichkeit hat, seine Situation durch eine nur eigene Entscheidungsänderung zu verbessern.\nIn der Matrix oben heißt dass, das geprüft werden muss\n\\(A \\geq B \\land a \\geq c\\) \\(\\rightarrow\\) ol\n\\(B \\geq A \\land b \\geq d\\) \\(\\rightarrow\\) ul\n\\(C \\geq D \\land c \\geq a\\) \\(\\rightarrow\\) or\n\\(D \\geq C \\land d \\geq b\\) \\(\\rightarrow\\) ur\nEs kann kein oder ein Nash-Gleichgewicht existieren oder mehrere Nash-Gleichgewichte\n\n\n3.3.2.2 Einperiodige Spiele\n\n\nCode\nimport numpy as np\n\nimport random\n\n# Zufällige Ganzzahlen zwischen 0 und 9 generieren\nA = random.randint(0, 9)\nB = random.randint(0, 9)\nC = random.randint(0, 9)\nD = random.randint(0, 9)\na = random.randint(0, 9)\nb = random.randint(0, 9)\nc = random.randint(0, 9)\nd = random.randint(0, 9)\n\n# Formatierte Bimatrix ausgeben\nprint(f\"     l    r\\n o  {A},{a}  {C},{c}\\n u  {B},{b}  {D},{d}\")\n\n\n     l    r\n o  8,1  7,7\n u  0,7  1,0\n\n\nCode\n\n\n# Funktionen für Nash-Bedingungen\ndef is_ol_nash(A, B, a, c):\n  return \"ol\" if (A &gt;= B) and (a &gt;= c) else \"not_ol\"\n\ndef is_ul_nash(B, A, b, d):\n  return \"ul\" if (B &gt;= A) and (b &gt;= d) else \"not_ul\"\n\ndef is_or_nash(C, D, c, a):\n  return \"or\" if (C &gt;= D) and (c &gt;= a) else \"not_or\"\n\ndef is_ur_nash(D, C, d, b):\n  return \"ur\" if (D &gt;= C) and (d &gt;= b) else \"not_ur\"\n\n# Nash-Bedingungen überprüfen und Strings zuweisen\nCand_Nash_ol = is_ol_nash(A, B, a, c)\nCand_Nash_ul = is_ul_nash(B, A, b, d)\nCand_Nash_or = is_or_nash(C, D, c, a)\nCand_Nash_ur = is_ur_nash(D, C, d, b)\n\n# Ergebnisse kombinieren und NAs entfernen\nNash_GG = np.array([Cand_Nash_ol, Cand_Nash_ul, Cand_Nash_or, Cand_Nash_ur])\nNash_GG_filtered = []\nfor element in Nash_GG:\n  if element == \"ol\" or element == \"ul\" or element == \"or\" or element == \"ur\":\n    Nash_GG_filtered.append(element)\n\n# Ergebnis ausgeben\n#print(Nash_GG_filtered)\n\n\n\n\nCode\nprint(Nash_GG_filtered)\n\n\n['or']\n\n\n\n3.3.2.2.1 Koordinationsspiel\n\n\n\nKoordinationsspiel\n\n\n\n\nCode\nimport numpy as np\n\nimport random\n\n# Zufällige Ganzzahlen zwischen 0 und 9 generieren\nA = 0\nB = random.randint(1, 9)\nC = B\nD = A\na = A\nb = B\nc = C\nd = D\n\n# Formatierte Bimatrix ausgeben\nprint(f\"     l    r\\n o  {A},{a}  {C},{c}\\n u  {B},{b}  {D},{d}\")\n\n\n     l    r\n o  0,0  4,4\n u  4,4  0,0\n\n\nCode\n# Funktionen für Nash-Bedingungen\ndef is_ol_nash(A, B, a, c):\n  return \"ol\" if (A &gt;= B) and (a &gt;= c) else \"not_ol\"\n\ndef is_ul_nash(B, A, b, d):\n  return \"ul\" if (B &gt;= A) and (b &gt;= d) else \"not_ul\"\n\ndef is_or_nash(C, D, c, a):\n  return \"or\" if (C &gt;= D) and (c &gt;= a) else \"not_or\"\n\ndef is_ur_nash(D, C, d, b):\n  return \"ur\" if (D &gt;= C) and (d &gt;= b) else \"not_ur\"\n\n# Nash-Bedingungen überprüfen und Strings zuweisen\nCand_Nash_ol = is_ol_nash(A, B, a, c)\nCand_Nash_ul = is_ul_nash(B, A, b, d)\nCand_Nash_or = is_or_nash(C, D, c, a)\nCand_Nash_ur = is_ur_nash(D, C, d, b)\n\n# Ergebnisse kombinieren und NAs entfernen\nNash_GG = np.array([Cand_Nash_ol, Cand_Nash_ul, Cand_Nash_or, Cand_Nash_ur])\nNash_GG_filtered = []\nfor element in Nash_GG:\n  if element == \"ol\" or element == \"ul\" or element == \"or\" or element == \"ur\":\n    Nash_GG_filtered.append(element)\n\n# Ergebnis ausgeben\nprint(Nash_GG_filtered)\n\n\n['ul', 'or']\n\n\n\n\n3.3.2.2.2 Chicken Game\n\n\n\nChicken Game\n\n\n\n\nCode\nimport numpy as np\n\nimport random\n\n# Zufällige Ganzzahlen zwischen 0 und 9 generieren\nA = random.randint(5, 7)\nB = random.randint(8, 9)\nC = random.randint(2, 4)\nD = random.randint(0, 1)\na = random.randint(5, 7)\nb = random.randint(2, 4)\nc = random.randint(8, 9)\nd = random.randint(0, 1)\n\n# Formatierte Bimatrix ausgeben\nprint(f\"     l    r\\n o  {A},{a}  {C},{c}\\n u  {B},{b}  {D},{d}\")\n\n\n     l    r\n o  6,7  4,8\n u  9,2  0,1\n\n\nCode\n# Funktionen für Nash-Bedingungen\ndef is_ol_nash(A, B, a, c):\n  return \"ol\" if (A &gt;= B) and (a &gt;= c) else \"not_ol\"\n\ndef is_ul_nash(B, A, b, d):\n  return \"ul\" if (B &gt;= A) and (b &gt;= d) else \"not_ul\"\n\ndef is_or_nash(C, D, c, a):\n  return \"or\" if (C &gt;= D) and (c &gt;= a) else \"not_or\"\n\ndef is_ur_nash(D, C, d, b):\n  return \"ur\" if (D &gt;= C) and (d &gt;= b) else \"not_ur\"\n\n# Nash-Bedingungen überprüfen und Strings zuweisen\nCand_Nash_ol = is_ol_nash(A, B, a, c)\nCand_Nash_ul = is_ul_nash(B, A, b, d)\nCand_Nash_or = is_or_nash(C, D, c, a)\nCand_Nash_ur = is_ur_nash(D, C, d, b)\n\n# Ergebnisse kombinieren und NAs entfernen\nNash_GG = np.array([Cand_Nash_ol, Cand_Nash_ul, Cand_Nash_or, Cand_Nash_ur])\nNash_GG_filtered = []\nfor element in Nash_GG:\n  if element == \"ol\" or element == \"ul\" or element == \"or\" or element == \"ur\":\n    Nash_GG_filtered.append(element)\n\n# Ergebnis ausgeben\nprint(Nash_GG_filtered)\n\n\n['ul', 'or']\n\n\n\n\n3.3.2.2.3 Geschlechterkampf\n\n\n\nGeschlechterkampf\n\n\n\n\nCode\nimport numpy as np\n\nimport random\n\n# Zufällige Ganzzahlen zwischen 0 und 9 generieren\nA = random.randint(8, 9)\nB = random.randint(0, 2)\nC = random.randint(3, 5)\nD = random.randint(6, 7)\na = random.randint(6, 7)\nb = random.randint(0, 2)\nc = random.randint(3, 5)\nd = random.randint(8, 9)\n\n# Formatierte Bimatrix ausgeben\nprint(f\"     l    r\\n o  {A},{a}  {C},{c}\\n u  {B},{b}  {D},{d}\")\n\n\n     l    r\n o  9,6  3,3\n u  2,0  7,8\n\n\nCode\n# Funktionen für Nash-Bedingungen\ndef is_ol_nash(A, B, a, c):\n  return \"ol\" if (A &gt;= B) and (a &gt;= c) else \"not_ol\"\n\ndef is_ul_nash(B, A, b, d):\n  return \"ul\" if (B &gt;= A) and (b &gt;= d) else \"not_ul\"\n\ndef is_or_nash(C, D, c, a):\n  return \"or\" if (C &gt;= D) and (c &gt;= a) else \"not_or\"\n\ndef is_ur_nash(D, C, d, b):\n  return \"ur\" if (D &gt;= C) and (d &gt;= b) else \"not_ur\"\n\n# Nash-Bedingungen überprüfen und Strings zuweisen\nCand_Nash_ol = is_ol_nash(A, B, a, c)\nCand_Nash_ul = is_ul_nash(B, A, b, d)\nCand_Nash_or = is_or_nash(C, D, c, a)\nCand_Nash_ur = is_ur_nash(D, C, d, b)\n\n# Ergebnisse kombinieren und NAs entfernen\nNash_GG = np.array([Cand_Nash_ol, Cand_Nash_ul, Cand_Nash_or, Cand_Nash_ur])\nNash_GG_filtered = []\nfor element in Nash_GG:\n  if element == \"ol\" or element == \"ul\" or element == \"or\" or element == \"ur\":\n    Nash_GG_filtered.append(element)\n\n# Ergebnis ausgeben\nprint(Nash_GG_filtered)\n\n\n['ol', 'ur']\n\n\n\n\n3.3.2.2.4 Gefangenendilemma\n\n\n\nGefangenendilemma\n\n\n\n\nCode\nimport numpy as np\n\nimport random\n\n# Zufällige Ganzzahlen zwischen 0 und 9 generieren\nA = random.randint(5, 7)\nB = random.randint(8, 9)\nC = random.randint(0, 1)\nD = random.randint(2, 4)\na = random.randint(5, 8)\nb = random.randint(0, 1)\nc = random.randint(8, 9)\nd = random.randint(2, 4)\n\n# Formatierte Bimatrix ausgeben\nprint(f\"     l    r\\n o  {A},{a}  {C},{c}\\n u  {B},{b}  {D},{d}\")\n\n\n     l    r\n o  6,6  1,8\n u  9,0  2,4\n\n\nCode\n# Funktionen für Nash-Bedingungen\ndef is_ol_nash(A, B, a, c):\n  return \"ol\" if (A &gt;= B) and (a &gt;= c) else \"not_ol\"\n\ndef is_ul_nash(B, A, b, d):\n  return \"ul\" if (B &gt;= A) and (b &gt;= d) else \"not_ul\"\n\ndef is_or_nash(C, D, c, a):\n  return \"or\" if (C &gt;= D) and (c &gt;= a) else \"not_or\"\n\ndef is_ur_nash(D, C, d, b):\n  return \"ur\" if (D &gt;= C) and (d &gt;= b) else \"not_ur\"\n\n# Nash-Bedingungen überprüfen und Strings zuweisen\nCand_Nash_ol = is_ol_nash(A, B, a, c)\nCand_Nash_ul = is_ul_nash(B, A, b, d)\nCand_Nash_or = is_or_nash(C, D, c, a)\nCand_Nash_ur = is_ur_nash(D, C, d, b)\n\n# Ergebnisse kombinieren und NAs entfernen\nNash_GG = np.array([Cand_Nash_ol, Cand_Nash_ul, Cand_Nash_or, Cand_Nash_ur])\nNash_GG_filtered = []\nfor element in Nash_GG:\n  if element == \"ol\" or element == \"ul\" or element == \"or\" or element == \"ur\":\n    Nash_GG_filtered.append(element)\n\n# Ergebnis ausgeben\nprint(Nash_GG_filtered)\n\n\n['ur']\n\n\n\n\n\n3.3.2.3 Wiederholte Spiele\n\nAusgangspunkt Gefangenendilemma mit \\(B&gt;A&gt;D&gt;C\\) und \\(c&gt;a&gt;d&gt;b\\)\nErwartungswert der Kooperation für Spieler 1: \\(E^1_k\\approx \\frac{A}{1-p}\\)\nErwartungswert der Nicht-Kooperation für Spieler 1: \\(E^1_{nk}\\approx B+ \\frac{D}{1-p}-D\\)\nErwartungswert der Kooperation für Spieler 2: \\(E^2_k\\approx \\frac{a}{1-p}\\)\nErwartungswert der Nicht-Kooperation für Spieler 2: \\(E^2_{nk}\\approx c+ \\frac{d}{1-p}-d\\)\nKooperation durch Spieler 1 wenn \\(p\\geq \\frac{B-A}{B-D}\\)\nKooperation durch Spieler 2 wenn \\(p\\geq \\frac{c-a}{c-d}\\)\n\n\n\nCode\nfrom sympy import Symbol, solve, Eq\n\nA = Symbol('A')\nB = Symbol('B')\nC = Symbol('C')\nD = Symbol('D')\na = Symbol('a')\nb = Symbol('b')\nc = Symbol('c')\nd = Symbol('d')\np = Symbol('p')\n\n# Ungleichung aufstellen\n\nE_1K = A/(1-p)\n\n\nE_1NK = B+ D/(1-p)-D\n\n\nBedingung = Eq(E_1K, E_1NK)\n\n\nsol1=solve(Bedingung, p) # wie löse ich das als Ungleichung?\n\nprint(sol1)\n\nE_2K = a/(1-p)\n\nE_2NK = c+ d/(1-p) -d\n\nBedingung = Eq(E_2K, E_2NK)\n\nsol2 = solve(Bedingung, p)\nprint(sol2)\n\n\n\n\nCode\nimport numpy as np\n\nimport random\n\n# Zufällige Ganzzahlen zwischen 0 und 9 generieren\nA = random.randint(5, 7)\nB = random.randint(8, 9)\nC = random.randint(0, 1)\nD = random.randint(2, 4)\na = random.randint(5, 8)\nb = random.randint(0, 1)\nc = random.randint(8, 9)\nd = random.randint(2, 4)\n\n# Formatierte Bimatrix ausgeben\nprint(\"    l   r\")\nprint(f\"o  {A},{a}  {C},{c}\")\nprint(f\"u  {B},{b}  {D},{d}\")\n\n\n# Funktionen für Nash-Bedingungen\ndef is_ol_nash(A, B, a, c):\n  return \"ol\" if (A &gt;= B) and (a &gt;= c) else \"not_ol\"\n\ndef is_ul_nash(B, A, b, d):\n  return \"ul\" if (B &gt;= A) and (b &gt;= d) else \"not_ul\"\n\ndef is_or_nash(C, D, c, a):\n  return \"or\" if (C &gt;= D) and (c &gt;= a) else \"not_or\"\n\ndef is_ur_nash(D, C, d, b):\n  return \"ur\" if (D &gt;= C) and (d &gt;= b) else \"not_ur\"\n\n# Nash-Bedingungen überprüfen und Strings zuweisen\nCand_Nash_ol = is_ol_nash(A, B, a, c)\nCand_Nash_ul = is_ul_nash(B, A, b, d)\nCand_Nash_or = is_or_nash(C, D, c, a)\nCand_Nash_ur = is_ur_nash(D, C, d, b)\n\n# Ergebnisse kombinieren und NAs entfernen\nNash_GG = np.array([Cand_Nash_ol, Cand_Nash_ul, Cand_Nash_or, Cand_Nash_ur])\nNash_GG_filtered = []\nfor element in Nash_GG:\n  if element == \"ol\" or element == \"ul\" or element == \"or\" or element == \"ur\":\n    Nash_GG_filtered.append(element)\n\n# Ergebnis ausgeben\nprint(Nash_GG_filtered)\n\n# Kritisches p für Kooperation\n\np_krit = (B-A)/(B - D)\n#print(round(p_krit,3))\nprint(f\"Für Kooperation durch Spieler 1 muss die Wahrscheinlichkeit für eine weitere Runde mindestens {str(round(p_krit,3)).replace('.',',')} betragen.\")\n\np_krit = (c-a)/(c - d)\n#print(round(p_krit,3))\nprint(f\"Für Kooperation durch Spieler 2 muss die Wahrscheinlichkeit für eine weitere Runde mindestens {str(round(p_krit,3)).replace('.',',')} betragen.\")\n\n\n\n\n3.3.2.4 Trembling Hand\n\nIdee: Manche Nash-Gleichgewichte sind riskant\nWenn der Gegenspieler “versehentlich” eine falsche Strategie spielt, dann macht man evtl hohe Verluste\nWie hoch darf die Fehlerwahrscheinlichkeit des Gegenspielers sein, damit das Nash-Gleichgewicht noch die richtige Strategie impliziert?\n\nAngenommen, beide Spieler streben ein Nash-Gleichgewicht oben links an\nFür Spieler 1 muss dann gelten\n\\(E_o\\geq E_u\\)\nWenn er davon ausgeht, dass Spieler 2 mit einer Wahrscheinlichkeit von \\(p\\) versehentlich rechts statt links spielt, heißt das\n\\((1-p)A+pC \\geq (1-p)B+pD\\)\n\\(\\iff A-pA+pC\\geq B-pB+pD\\)\n\\(\\iff A-p(A-C) \\geq B-p(B-D)\\)\n\\(\\iff p(B-D)-p(A-C) \\geq B-A\\)\n\\(\\iff p(B-D-A+C)\\geq B-A\\)\nmit \\((B-D-A+C) &lt;0\\)\n\\(\\iff p \\leq \\frac{B-A}{B-A-D+C}=\\frac{A-B}{A-B-C+D}\\)\nFür Spieler 2 muss dann gelten\n\\(E_l\\geq E_r\\)\n\\((1-p)a+pb \\geq (1-p)c+pd\\)\n\\(\\iff a-pa+pb \\geq c-pc+pd\\)\n\\(\\iff a-p(a-b) \\geq c-p(c-d)\\)\n\\(\\iff p(c-d)-p(a-b) \\geq c-a\\)\n\\(\\iff p(c-d-a+b) \\geq c-a\\)\nmit \\((c-d-a+b)\\neq 0\\)\n\\(p \\leq \\frac{c-a}{(c-d-a+b)}=\\frac{a-c}{(a-b-c+d)}\\)\n\n\nCode\n# Wahrscheinlichkeiten ausrechnen\n\nfrom sympy import Symbol, solve, Eq\n\nsymbols = [Symbol(name) for name in 'ABCDabcdp']\nA, B, C, D, a, b, c, d, p = symbols  # Entpacken und als separate Variablen speichern\n\n# Beide streben ol an\n\nE_o= (1-p)*A+p*C\n\nE_u= (1-p)*B + p*D\n\nsol = solve(Eq(E_o, E_u), p)\nprint(sol)\n\nE_l = (1-p)*a + p*b\nE_r = (1-p)*c + p*d\n\nsol = solve(Eq(E_l, E_r),p)\nprint(sol)\n\n\n\n\n\n3.3.3 Gemischte Strategien\n\nEs könnte sinnvoll sein, zufällig zu spielen, um nicht vorhersehbar zu sein\nGesucht sind die Wahrscheinlichkeiten, bei denen der Gegenspieler indifferent ist in der Wahl seiner Handlungsmöglichkeiten (also seine Lage durch cleveres Spielen nicht verbessern kann)\n\n\n\nCode\n# Wahrscheinlichkeiten ausrechnen\n\nfrom sympy import Symbol, solve, Eq\n\nsymbols = [Symbol(name) for name in 'ABCDabcdp']\nA, B, C, D, a, b, c, d, p = symbols  # Auspacken in verschiedene Variablen\n\n\n#p_l\nE_o= p*A+(1-p)*C\n\nE_u= p*B  + (1-p)*D\n\nsol = solve(Eq(E_o, E_u), p)\nprint(sol)\n\n#p_o\n\nE_l = p*a + (1-p)*b\nE_r = p*c + (1-p)*d\n\nsol = solve(Eq(E_l, E_r),p)\nprint(sol)\n\n\n\n\nCode\nimport numpy as np\nimport random\n\n# Zufällige Ganzzahlen zwischen 0 und 9 generieren\nA = random.randint(0, 9)\nB = random.randint(0, 9)\nC = random.randint(0, 9)\nD = random.randint(0, 9)\na = random.randint(0, 9)\nb = random.randint(0, 9)\nc = random.randint(0, 9)\nd = random.randint(0, 9)\n\n# Formatierte Bimatrix ausgeben\nprint(f\"     l    r\\n o  {A},{a}  {C},{c}\\n u  {B},{b}  {D},{d}\")\n\n\n# Funktionen für Nash-Bedingungen\ndef is_ol_nash(A, B, a, c):\n  return \"ol\" if (A &gt;= B) and (a &gt;= c) else \"not_ol\"\n\ndef is_ul_nash(B, A, b, d):\n  return \"ul\" if (B &gt;= A) and (b &gt;= d) else \"not_ul\"\n\ndef is_or_nash(C, D, c, a):\n  return \"or\" if (C &gt;= D) and (c &gt;= a) else \"not_or\"\n\ndef is_ur_nash(D, C, d, b):\n  return \"ur\" if (D &gt;= C) and (d &gt;= b) else \"not_ur\"\n\n# Nash-Bedingungen überprüfen und Strings zuweisen\nCand_Nash_ol = is_ol_nash(A, B, a, c)\nCand_Nash_ul = is_ul_nash(B, A, b, d)\nCand_Nash_or = is_or_nash(C, D, c, a)\nCand_Nash_ur = is_ur_nash(D, C, d, b)\n\n# Ergebnisse kombinieren und NAs entfernen\nNash_GG = np.array([Cand_Nash_ol, Cand_Nash_ul, Cand_Nash_or, Cand_Nash_ur])\nNash_GG_filtered = []\nfor element in Nash_GG:\n  if element == \"ol\" or element == \"ul\" or element == \"or\" or element == \"ur\":\n    Nash_GG_filtered.append(element)\n\n# Ergebnis ausgeben\nprint(Nash_GG_filtered)\n\n\n# Anzahl der Nash GG\n\n#Anzahl_NGG=len(Nash_GG_filtered)\n#print(Anzahl_NGG)\n\n# Wahrscheinlichkeiten ausrechnen.\n# Dabei jeweils den Fall Division duch 0 aussschließen\n\n#p_l\nif (A - B - C + D)!=0: p_l = ( D-C)/(A - B - C + D)\n\n#print(round(p_l, 2))\n\n#p_o\nif (-b + d)/(a - b - c + d)!=0: p_o = (-b + d)/(a - b - c + d)\n\n#print(round(p_o, 2))\n\n\n# Ausgabe Abhängig von Bedingungen\n\nif (#Anzahl_NGG == 1 or \n    p_o &lt; 0 or p_l &lt; 0 or\n            p_o &gt; 1 or p_l &gt; 1 or\n            (a - b - c + d) == 0 or\n            (A - B - C + D) == 0): print(\"Kein Nash-Gleichgewicht in gemischten Strategien\")\nelse:   print(f\"p_l= {round(p_l, 2)}, p_o= {(round(p_o, 2))}\")",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Nicht-kooperative Spieltheorie</span>"
    ]
  },
  {
    "objectID": "Spieltheorie.html#sequenzielle-spiele",
    "href": "Spieltheorie.html#sequenzielle-spiele",
    "title": "3  Nicht-kooperative Spieltheorie",
    "section": "3.4 Sequenzielle Spiele",
    "text": "3.4 Sequenzielle Spiele\nSpieler spielen nacheinander.\n\n3.4.1 Vollständige Information\nAnnahme: Alle Spieler kennen alle Auszahlungen und sehen alle bislang erfolgten Spielzüge\nDarstellung des Spiels mittels eines Spielbaums\n\n\n\nGrundstruktur eines Spielbaums\n\n\n\n3.4.1.1 Rückwärtsinduktion\nLösen des Spiels “von hinten nach vorn”\n\n3.4.1.1.1 Beispiele\n\n\n\nBeispiel für Rückwärtsinduktion\n\n\n\n\n\nBeispiel für Rückwärtsinduktion\n\n\n\n\n3.4.1.1.2 Bedingungen für ein Nash-Gleichgewicht\nZunächst vereinfachende Annahme: \\(a\\neq c\\ \\text{und}\\ b \\neq d\\)\nJa, was sind die Bedingungen?\nol: \\(a&gt;c \\land ((A&gt;B\\ \\land\\ b&gt;d) \\lor (A&gt;D\\ \\land\\ d&gt;b))\\)\nor: \\(c&gt;a  \\land ((C&gt;D\\ \\land d&gt;b) \\lor (C&gt;B\\ \\land b&gt; d))\\)\nul: \\(b&gt;d \\land ((B&gt;A \\land a&gt;c)\\lor(B&gt;C \\land c&gt;a))\\)\nur: \\(d&gt;b \\land ((D&gt;A \\land a&gt;c)\\lor (D&gt;C \\land c&gt;a))\\)\nHier: Implementierung in Python\n\n\nCode\nimport numpy as np\nimport random\n\nrandom.seed(123) # Für reproduzierbare Ergebnisse ggf. fixieren\n\n# Zufällige Ganzzahlen zwischen 0 und 9 generieren\n#A = random.randint(0, 9)\n#B = random.randint(0, 9)\n#C = random.randint(0, 9)\n#D = random.randint(0, 9)\n#a = random.randint(0, 9)\n#b = random.randint(0, 9)\n#c = random.randint(0, 9)\n#d = random.randint(0, 9)\n\n#A = 1\n#B = 0\n#C = 0\n#D = 0\n#a = 1\n#b = 0\n#c = 0\n#d = 0\n\n# Zufallszahlen, aber alle unterschiedlich\nchoices = np.arange(10)\n\n# Generate unique random integers for uppercase variables\nParameter = np.random.choice(choices, size=8, replace=False)\nA, B, C, D, a, b, c, d = Parameter\n\n\n# Formatierte Bimatrix ausgeben\n#print(\"    l   r\")\n#print(f\"o  {A},{a}  {C},{c}\")\n#print(f\"u  {B},{b}  {D},{d}\")\n\n\n# Spielbaum ausgeben\n\nprint(f\" ol: {A}, {a}\\n or: {C}, {c}\\n ul: {B}, {b}\\n ur: {D}, {d}\")\n\n\n ol: 3, 5\n or: 9, 4\n ul: 0, 8\n ur: 7, 6\n\n\nCode\n# Funktionen für Nash-Bedingungen\n# Spieler 2 (a) entscheidet l/r, Spieler 1 (A) entscheidet o/u\ndef is_ol_nash(A, B, D, a, b, c, d):\n  return \"ol\" if ((a &gt; c) and ((A&gt;= B and b&gt; d) or\n              (A &gt;= D and d&gt;=b))) else \"not_ol\"\n\ndef is_or_nash( B, C, D, a, b, c, d):\n  return \"or\" if (c&gt;a and ((C&gt;= B and b&gt;=d) or\n              (C &gt;= D and d&gt;b))) else \"not_or\"\n\n\ndef is_ul_nash(A, B, C,  a, b, c, d):\n  return \"ul\" if (b&gt;=d and ((B&gt;= A and a&gt;= c) or\n              (B &gt;= C and c&gt;=a))) else \"not_ul\"\n\n\ndef is_ur_nash(A,  C, D, a, b, c, d):\n  return \"ur\" if (d&gt;=b and ((D&gt;= A and a&gt;= c) or\n              (D &gt;= C and c&gt;=a))) else \"not_ur\"\n\n\n# Nash-Bedingungen überprüfen und Strings zuweisen\n\nCand_Nash_ol = is_ol_nash(A, B,    D, a, b, c, d)\nCand_Nash_or = is_or_nash(   B, C, D, a, b, c, d)\nCand_Nash_ul = is_ul_nash(A, B, C,    a, b, c, d)\nCand_Nash_ur = is_ur_nash(A,    C, D, a, b, c, d)\n\n# Ergebnisse kombinieren und NAs entfernen\nNash_GG = np.array([Cand_Nash_ol, Cand_Nash_ul, Cand_Nash_or, Cand_Nash_ur])\nNash_GG_filtered = []\nfor element in Nash_GG:\n  if element == \"ol\" or element == \"or\" or element == \"ul\" or element == \"ur\":\n    Nash_GG_filtered.append(element)\n\n# Ergebnis ausgeben\nprint(Nash_GG_filtered)\n\n\n['ol']\n\n\n\n\n\n3.4.1.2 Teilspielperfektheit\n\nTeilspielperfektheit verlangt, dass jeder Spieler jeden Zug so ausführt, dass das Ergebnis des Zuges seinen Interessen nicht schadet.\nEin Teilspiel beginnt in einem Knoten und enthält alle nachfolgenden Knoten\nFür später: Ein Teilspiel darf nachfolgende Informationsmengen nicht teilen. Es gehören also immer alle Knoten einer Informationsmenge zu einem Teilspiel\n\nBeispiel: Unglaubwürdige Drohung\n\n\n\nUnglaubwürdige Drohung\n\n\nHier: Tafelaufschrieb Markteintrittsspiel\n\n\n3.4.1.3 Selbstbindung\nHier: Sonderabbildung Weltvernichtungsbombe\n\n\n\n3.4.2 Unvollständige Information\n\n3.4.2.1 Alles beobachtbar, aber Auszahlungen können gleich sein\n\n\n\nAuszahlungen von Spieler 1 sind gleich\n\n\n\\(\\rightarrow\\) Spieler 1 muss sich irgendwie entscheiden, aber Spieler 2 kann die Entscheidung sehen.\n\n\n\nAuszahlungen von Spieler 2 sind gleich\n\n\n\\(\\rightarrow\\) Spieler 1 kann nicht antizipieren, was Spieler 2 im Fall “unten” macht.\n\\(\\rightarrow\\) Kriterium für Entscheidung unter Risiko\nMögliche Kriterien:\n\nErwartungswert\nErwartungsnutzen\nMaximin\n\\(\\dots\\)\n\nHier unterstellt: Erwartungswertkriterium\nDie Bedingungen für ein Nash-Gleichgewicht bei sequenziellen Spielen lauten dann:\nja wie?\nol: \\(a&gt;c \\land ((A\\geq B\\ \\land\\ b \\geq d) \\lor (A \\geq  D\\ \\land\\ d \\geq b) ) \\lor a=c \\land ((b&gt;d \\land (\\frac{A+C}{2} \\geq B)\\lor (d&gt;b \\land \\frac{A+C}{2}\\geq D) \\lor (b=d \\land(\\frac{A+C}{2}\\geq \\frac{B+D}{2})))\\)\nor: \\(c&gt;a  \\land ((C&gt;D\\ \\land d&gt;b) \\lor (C&gt;B\\ \\land b&gt; d))\\)\nul: \\(b&gt;d \\land ((B&gt;A \\land a&gt;c)\\lor(B&gt;C \\land c&gt;a))\\)\nur: \\(d&gt;b \\land ((D&gt;A \\land a&gt;c)\\lor (D&gt;C \\land c&gt;a))\\)\n\n\n3.4.2.2 Zug von Spieler 1 ist für Spieler 2 unsichtbar\n - Fehlende Information für Spieler 2 kein Problem, wenn er eine dominante Alternative hat oder wenn alle Auszahlungen für ihn gleich sind.\n\nFehlende Information für Spieler 2 kein Problem, wenn Spieler 1 eine dominante Alternative hat.\nWenn Information nicht vorliegt, Entscheidungskriterium unter Risiko nutzen. Hier: Erwartungswert\n\n\n\nCode\n#|echo: true\n#| eval: false\n\n\nimport numpy as np\nimport random\n\n#random.seed(123) # Für reproduzierbare Ergebnisse ggf. fixieren\n\n# Zufällige Ganzzahlen zwischen 0 und 9 generieren\n\nA, B, C, D, a, b, c, d = random.choices(range(10), k=8)\n\n\n# Formatierte Bimatrix ausgeben\n#print(\"    l   r\")\n#print(f\"o  {A},{a}  {C},{c}\")\n#print(f\"u  {B},{b}  {D},{d}\")\n\n\n# Spielbaum ausgeben\n\nprint(f\" ol: {A}, {a}\\n or: {C}, {c}\\n ul: {B}, {b}\\n ur: {D}, {d}\")\n\n\n ol: 5, 3\n or: 8, 2\n ul: 3, 3\n ur: 1, 0\n\n\nCode\n# Annahme: Spieler 2 sieht Zug von Spieler 1 nicht\n\n\n# Kommentare zur Strategie\n\n\n\n# Funktionen für Nash-Bedingungen\n# Spieler 2 (a) entscheidet l/r, Spieler 1 (A) entscheidet o/u \n\n#def is_ol_nash(A, B, C, D, a, b, c, d):\n#  return \"ol\" if ...\n#              else \"not_ol\"\n\n#def is_or_nash(A, B, C, D, a, b, c, d):\n # return \"or\" if... \n  #          else \"not_or\"\n\n\n#def is_ul_nash(A, B, C, D, a, b, c, d):\n#  return \"ul\" if ...\n #             else \"not_ul\"\n\n\n#def is_ur_nash(A, B, C, D, a, b, c, d):\n#  return \"ur\" if ...\n #             else \"not_ur\"\n\n\n# Nash-Bedingungen überprüfen und Strings zuweisen\n\nCand_Nash_ol = is_ol_nash(A, B, C, D, a, b, c, d)\nCand_Nash_or = is_or_nash(A, B, C, D, a, b, c, d)\nCand_Nash_ul = is_ul_nash(A, B, C, D, a, b, c, d)\nCand_Nash_ur = is_ur_nash(A, B, C, D, a, b, c, d)\n\n# Ergebnisse kombinieren und NAs entfernen\nNash_GG = np.array([Cand_Nash_ol, Cand_Nash_ul, Cand_Nash_or, Cand_Nash_ur])\nNash_GG_filtered = []\nfor element in Nash_GG:\n  if element == \"ol\" or element == \"or\" or element == \"ul\" or element == \"ur\":\n    Nash_GG_filtered.append(element)\n    \n#Ergebnis ausgeben\nprint(Nash_GG_filtered)\n\n\n['ol']\n\n\n\n\n3.4.2.3 Typ von Spieler 1 (und damit die Menge seiner Auszahlungen) ist für Spieler 2 unsichtbar\n\nTafelaufschrieb\n\nGrundsätzlich zwei verschiedene Typen von Gleichgewichten:\n\nSeparierende Gleichgewichte: Spieler 1 offenbart durch seine Entscheidung, von welchem Typ er ist\nPooling Gleichgewichte: Man kann kann aus dem Handeln des Spielers 1 nicht auf seinen Typ schließen",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Nicht-kooperative Spieltheorie</span>"
    ]
  },
  {
    "objectID": "Spieltheorie.html#koalitionsspiele",
    "href": "Spieltheorie.html#koalitionsspiele",
    "title": "3  Nicht-kooperative Spieltheorie",
    "section": "3.5 Koalitionsspiele",
    "text": "3.5 Koalitionsspiele",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Nicht-kooperative Spieltheorie</span>"
    ]
  },
  {
    "objectID": "Spieltheorie.html#evolutionäre-spiele",
    "href": "Spieltheorie.html#evolutionäre-spiele",
    "title": "3  Nicht-kooperative Spieltheorie",
    "section": "3.6 Evolutionäre Spiele",
    "text": "3.6 Evolutionäre Spiele",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Nicht-kooperative Spieltheorie</span>"
    ]
  },
  {
    "objectID": "Verhaltensoekonomik.html",
    "href": "Verhaltensoekonomik.html",
    "title": "4  Verhaltensökonomik",
    "section": "",
    "text": "4.1 Einleitung",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Verhaltensökonomik</span>"
    ]
  },
  {
    "objectID": "Verhaltensoekonomik.html#unrealistische-annahmen-vs.-realistische-modellierung",
    "href": "Verhaltensoekonomik.html#unrealistische-annahmen-vs.-realistische-modellierung",
    "title": "4  Verhaltensökonomik",
    "section": "4.2 Unrealistische Annahmen vs. realistische Modellierung",
    "text": "4.2 Unrealistische Annahmen vs. realistische Modellierung",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Verhaltensökonomik</span>"
    ]
  },
  {
    "objectID": "Verhaltensoekonomik.html#flat-rate-bias",
    "href": "Verhaltensoekonomik.html#flat-rate-bias",
    "title": "4  Verhaltensökonomik",
    "section": "4.3 Flat-Rate Bias",
    "text": "4.3 Flat-Rate Bias",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Verhaltensökonomik</span>"
    ]
  },
  {
    "objectID": "Verhaltensoekonomik.html#die-prospect-theory",
    "href": "Verhaltensoekonomik.html#die-prospect-theory",
    "title": "4  Verhaltensökonomik",
    "section": "4.4 Die Prospect Theory",
    "text": "4.4 Die Prospect Theory",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Verhaltensökonomik</span>"
    ]
  },
  {
    "objectID": "Verhaltensoekonomik.html#mental-accounting",
    "href": "Verhaltensoekonomik.html#mental-accounting",
    "title": "4  Verhaltensökonomik",
    "section": "4.5 Mental Accounting",
    "text": "4.5 Mental Accounting",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Verhaltensökonomik</span>"
    ]
  },
  {
    "objectID": "Verhaltensoekonomik.html#der-status-quo-bias",
    "href": "Verhaltensoekonomik.html#der-status-quo-bias",
    "title": "4  Verhaltensökonomik",
    "section": "4.6 Der Status-quo Bias",
    "text": "4.6 Der Status-quo Bias",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Verhaltensökonomik</span>"
    ]
  },
  {
    "objectID": "Verhaltensoekonomik.html#umgang-mit-risiken",
    "href": "Verhaltensoekonomik.html#umgang-mit-risiken",
    "title": "4  Verhaltensökonomik",
    "section": "4.7 Umgang mit Risiken",
    "text": "4.7 Umgang mit Risiken",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Verhaltensökonomik</span>"
    ]
  },
  {
    "objectID": "Verhaltensoekonomik.html#kritische-diskussion-der-verhaltensökonomik",
    "href": "Verhaltensoekonomik.html#kritische-diskussion-der-verhaltensökonomik",
    "title": "4  Verhaltensökonomik",
    "section": "4.8 Kritische Diskussion der Verhaltensökonomik",
    "text": "4.8 Kritische Diskussion der Verhaltensökonomik",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Verhaltensökonomik</span>"
    ]
  }
]