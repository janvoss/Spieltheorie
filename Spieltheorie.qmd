# Nicht-kooperative Spieltheorie

## Einleitung und begriffliche Einordnung

## Simultane Spiele

### Grundsätzliche Struktur eines Spiels

[![Allgemeines Struktur eines Spiels](figure/Allgemeine-Struktur.png){width="50%"}]::

```{python}
#| message: false
#| warning: false

from lets_plot import *

LetsPlot.setup_html()

ggplot() + \
geom_text(x=- .5, y= 2   , label='a') +\
geom_text(x=-1.5, y=  .75, label='A') +\
geom_text(x=- .5, y=-1   , label='b') +\
geom_text(x=-1.5, y=-2.25, label='B') +\
geom_text(x= 1.5, y= 2   , label='c') +\
geom_text(x=  .5, y=  .75, label='C') +\
geom_text(x= 1.5, y=-1   , label='d') +\
geom_text(x=  .5, y=-2.25, label='D') +\
geom_text(x=-1  , y= 3.3 , label='links')+\
geom_text(x= 1  , y= 3.3 , label='rechts')+\
geom_text(x=-2.2, y= 1.375, angle=90, label='oben')+\
geom_text(x=-2.2, y=-1.625, angle=90, label='unten')+\
geom_text(x= 0 , y= 4 ,
          fontface = "bold", label='Spieler 2')+\
geom_text(x=-2.7 , y= 0 , angle=90,
          fontface = "bold", label='Spieler 1')+\
geom_segment(x=-2,  xend= 2, y= 0, yend= 0) +\
geom_segment(x=-2,  xend= 2, y= 3, yend= 3) +\
geom_segment(x=-2,  xend= 2, y=-3, yend=-3) +\
geom_segment(x=-2,  xend=-2, y=-3, yend= 3) +\
geom_segment(x= 0,  xend= 0, y=-3, yend= 3) +\
geom_segment(x= 2,  xend= 2, y=-3, yend= 3) +\
theme_void()+\
labs(title='Auszahlungen in einem simultanen Spiel' #,
    # caption = 'Caption'
)

```

### Reine Strategien

#### Definition Nash-Gleichgewicht

Ein Nash-Gleichgewicht liegt vor, wenn jeder Spieler die beste Antwort auf die beste Strategie des Gegenspielers spielt.

Formal:

$u_{i}\left(s_{i}^{*},s_{-i}^{*}\right)\geq u_{i}\left(s_{i},s_{-i}^{*}\right)\mbox{ für alle }i,\mbox{ }s_{i}\in S_{i}$

Intuition: Ein Nash-Gleichgewicht liegt vor, wenn kein Spieler mehr die Möglichkeit hat, seine Situation durch eine **nur eigene** Entscheidungsänderung zu verbessern.

In der Matrix oben heißt dass, das geprüft werden muss

$A \geq B \land a \geq c$ $\rightarrow$ **ol**

$B \geq A \land b \geq d$ $\rightarrow$ **ul**

$C \geq D \land c \geq a$ $\rightarrow$ **or**

$D \geq C \land d \geq b$ $\rightarrow$ **ur**

Es kann kein oder ein Nash-Gleichgewicht existieren oder mehrere Nash-Gleichgewichte

#### Einperiodige Spiele

```{python}

import numpy as np

import random

# Zufällige Ganzzahlen zwischen 0 und 9 generieren

random.seed(123)

A = random.randint(0, 9)
B = random.randint(0, 9)
C = random.randint(0, 9)
D = random.randint(0, 9)
a = random.randint(0, 9)
b = random.randint(0, 9)
c = random.randint(0, 9)
d = random.randint(0, 9)

# Formatierte Bimatrix ausgeben
# print(f"     l    r\n o  {A},{a}  {C},{c}\n # u  {B},{b}  {D},{d}")

from lets_plot import *

LetsPlot.setup_html()

ggplot() + \
geom_text(x=- .5, y= 2   , label=a) +\
geom_text(x=-1.5, y=  .75, label=A) +\
geom_text(x=- .5, y=-1   , label=b) +\
geom_text(x=-1.5, y=-2.25, label=B) +\
geom_text(x= 1.5, y= 2   , label=c) +\
geom_text(x=  .5, y=  .75, label=C) +\
geom_text(x= 1.5, y=-1   , label=d) +\
geom_text(x=  .5, y=-2.25, label=D) +\
geom_text(x=-1  , y= 3.3 , label='links')+\
geom_text(x= 1  , y= 3.3 , label='rechts')+\
geom_text(x=-2.2, y= 1.375, angle=90, label='oben')+\
geom_text(x=-2.2, y=-1.625, angle=90, label='unten')+\
geom_text(x= 0 , y= 4 ,
          fontface = "bold", label='Spieler 2')+\
geom_text(x=-2.7 , y= 0 , angle=90,
          fontface = "bold", label='Spieler 1')+\
geom_segment(x=-2,  xend= 2, y= 0, yend= 0) +\
geom_segment(x=-2,  xend= 2, y= 3, yend= 3) +\
geom_segment(x=-2,  xend= 2, y=-3, yend=-3) +\
geom_segment(x=-2,  xend=-2, y=-3, yend= 3) +\
geom_segment(x= 0,  xend= 0, y=-3, yend= 3) +\
geom_segment(x= 2,  xend= 2, y=-3, yend= 3) +\
theme_void()+\
labs(title='Auszahlungen in einem simultanen Spiel')

```

```{python}

# Funktionen für Nash-Bedingungen
def is_ol_nash(A, B, a, c):
  return "ol" if (A >= B) and (a >= c) else "not_ol"

def is_ul_nash(B, A, b, d):
  return "ul" if (B >= A) and (b >= d) else "not_ul"

def is_or_nash(C, D, c, a):
  return "or" if (C >= D) and (c >= a) else "not_or"

def is_ur_nash(D, C, d, b):
  return "ur" if (D >= C) and (d >= b) else "not_ur"

# Nash-Bedingungen überprüfen und Strings zuweisen
Cand_Nash_ol = is_ol_nash(A, B, a, c)
Cand_Nash_ul = is_ul_nash(B, A, b, d)
Cand_Nash_or = is_or_nash(C, D, c, a)
Cand_Nash_ur = is_ur_nash(D, C, d, b)

# Ergebnisse kombinieren und NAs entfernen
Nash_GG = np.array([Cand_Nash_ol, Cand_Nash_ul, Cand_Nash_or, Cand_Nash_ur])
Nash_GG_filtered = []
for element in Nash_GG:
  if element == "ol" or element == "ul" or element == "or" or element == "ur":
    Nash_GG_filtered.append(element)

# Ergebnis ausgeben
#print(Nash_GG_filtered)

```

```{python}
print(f"Nash-Gleichgewicht(e) in reinen Strategien: {', '.join(Nash_GG_filtered)}")
```

##### Koordinationsspiel

[![Koordinationsspiel](figure/Koordinationsspiel-1.png){width="50%"}]::

```{python}

import numpy as np

import random

random.seed(123)

# Zufällige Ganzzahlen zwischen 0 und 9 generieren
A = 0
B = random.randint(1, 9)
C = B
D = A
a = A
b = B
c = C
d = D

# Formatierte Bimatrix ausgeben
#print(f"     l    r\n o  #{A},{a}  {C},{c}\n u  {B},{b} # {D},{d}")


def create_plot():
    LetsPlot.setup_html()
    return (
        ggplot() +
        geom_text(x=-0.5, y=2, label=a) +
        geom_text(x=-1.5, y=0.75, label=A) +
        geom_text(x=-0.5, y=-1, label=b) +
        geom_text(x=-1.5, y=-2.25, label=B) +
        geom_text(x=1.5, y=2, label=c) +
        geom_text(x=0.5, y=0.75, label=C) +
        geom_text(x=1.5, y=-1, label=d) +
        geom_text(x=0.5, y=-2.25, label=D) +
        geom_text(x=-1, y=3.3, label='links') +
        geom_text(x=1, y=3.3, label='rechts') +
        geom_text(x=-2.2, y=1.375, angle=90, label='oben') +
        geom_text(x=-2.2, y=-1.625, angle=90, label='unten') +
        geom_text(x=0 , y=4 , fontface="bold", label='Spieler 2') +
        geom_text(x=-2.7 , y=0 , angle=90 , fontface="bold", label='Spieler 1') +
        geom_segment(x=-2, xend=2, y=0, yend=0) +
        geom_segment(x=-2, xend=2, y=3, yend=3) +
        geom_segment(x=-2, xend=2, y=-3, yend=-3) +
        geom_segment(x=-2, xend=-2, y=-3, yend=3) +
        geom_segment(x=0 , xend=0 , y=-3 , yend=3) +
        geom_segment(x=2 , xend=2 , y=-3 , yend=3) +
        theme_void() +
        labs(title='Auszahlungen in einem simultanen Spiel')
    )

    
plot = create_plot()

plot
```

```{python}

# Funktionen für Nash-Bedingungen
def is_ol_nash(A, B, a, c):
  return "ol" if (A >= B) and (a >= c) else "not_ol"

def is_ul_nash(B, A, b, d):
  return "ul" if (B >= A) and (b >= d) else "not_ul"

def is_or_nash(C, D, c, a):
  return "or" if (C >= D) and (c >= a) else "not_or"

def is_ur_nash(D, C, d, b):
  return "ur" if (D >= C) and (d >= b) else "not_ur"

# Nash-Bedingungen überprüfen und Strings zuweisen
Cand_Nash_ol = is_ol_nash(A, B, a, c)
Cand_Nash_ul = is_ul_nash(B, A, b, d)
Cand_Nash_or = is_or_nash(C, D, c, a)
Cand_Nash_ur = is_ur_nash(D, C, d, b)

# Ergebnisse kombinieren und NAs entfernen
Nash_GG = np.array([Cand_Nash_ol, Cand_Nash_ul, Cand_Nash_or, Cand_Nash_ur])
Nash_GG_filtered = []
for element in Nash_GG:
  if element == "ol" or element == "ul" or element == "or" or element == "ur":
    Nash_GG_filtered.append(element)

# Ergebnis ausgeben
print(f"Nash-Gleichgewicht(e) in reinen Strategien: {', '.join(Nash_GG_filtered)}")
```

##### Chicken Game

[![Chicken Game](figure/Chicken-Game-1.png){width="50%"}]::

```{python}

import numpy as np

import random

# Zufällige Ganzzahlen zwischen 0 und 9 generieren
A = random.randint(5, 7)
B = random.randint(8, 9)
C = random.randint(2, 4)
D = random.randint(0, 1)
a = random.randint(5, 7)
b = random.randint(2, 4)
c = random.randint(8, 9)
d = random.randint(0, 1)

# Formatierte Bimatrix ausgeben
# print(f"     l    r\n o  {A},{a}  {C},{c}\n u  {B},{b}  {D},{d}")

plot = create_plot()

plot

```

```{python}

# Funktionen für Nash-Bedingungen
def is_ol_nash(A, B, a, c):
  return "ol" if (A >= B) and (a >= c) else "not_ol"

def is_ul_nash(B, A, b, d):
  return "ul" if (B >= A) and (b >= d) else "not_ul"

def is_or_nash(C, D, c, a):
  return "or" if (C >= D) and (c >= a) else "not_or"

def is_ur_nash(D, C, d, b):
  return "ur" if (D >= C) and (d >= b) else "not_ur"

# Nash-Bedingungen überprüfen und Strings zuweisen
Cand_Nash_ol = is_ol_nash(A, B, a, c)
Cand_Nash_ul = is_ul_nash(B, A, b, d)
Cand_Nash_or = is_or_nash(C, D, c, a)
Cand_Nash_ur = is_ur_nash(D, C, d, b)

# Ergebnisse kombinieren und NAs entfernen
Nash_GG = np.array([Cand_Nash_ol, Cand_Nash_ul, Cand_Nash_or, Cand_Nash_ur])
Nash_GG_filtered = []
for element in Nash_GG:
  if element == "ol" or element == "ul" or element == "or" or element == "ur":
    Nash_GG_filtered.append(element)

# Ergebnis ausgeben
print(f"Nash-Gleichgewicht(e) in reinen Strategien: {', '.join(Nash_GG_filtered)}")

```

##### Geschlechterkampf

[![Geschlechterkampf](figure/Geschlechterkampf-1.png){width="50%"}]::

```{python}

import numpy as np

import random

# Zufällige Ganzzahlen zwischen 0 und 9 generieren
A = random.randint(8, 9)
B = random.randint(0, 2)
C = random.randint(3, 5)
D = random.randint(6, 7)
a = random.randint(6, 7)
b = random.randint(0, 2)
c = random.randint(3, 5)
d = random.randint(8, 9)

# Formatierte Bimatrix ausgeben
# print(f"     l    r\n o  {A},{a}  {C},{c}\n u  {B},{b}  {D},{d}")

plot = create_plot()

plot
```

```{python}

# Funktionen für Nash-Bedingungen
def is_ol_nash(A, B, a, c):
  return "ol" if (A >= B) and (a >= c) else "not_ol"

def is_ul_nash(B, A, b, d):
  return "ul" if (B >= A) and (b >= d) else "not_ul"

def is_or_nash(C, D, c, a):
  return "or" if (C >= D) and (c >= a) else "not_or"

def is_ur_nash(D, C, d, b):
  return "ur" if (D >= C) and (d >= b) else "not_ur"

# Nash-Bedingungen überprüfen und Strings zuweisen
Cand_Nash_ol = is_ol_nash(A, B, a, c)
Cand_Nash_ul = is_ul_nash(B, A, b, d)
Cand_Nash_or = is_or_nash(C, D, c, a)
Cand_Nash_ur = is_ur_nash(D, C, d, b)

# Ergebnisse kombinieren und NAs entfernen
Nash_GG = np.array([Cand_Nash_ol, Cand_Nash_ul, Cand_Nash_or, Cand_Nash_ur])
Nash_GG_filtered = []
for element in Nash_GG:
  if element == "ol" or element == "ul" or element == "or" or element == "ur":
    Nash_GG_filtered.append(element)

# Ergebnis ausgeben
print(f"Nash-Gleichgewicht(e) in reinen Strategien: {', '.join(Nash_GG_filtered)}")

```

##### Gefangenendilemma

[![Gefangenendilemma](figure/Gefangenendilemma-1.png){width="50%"}]::

```{python}


import numpy as np

import random

# Zufällige Ganzzahlen zwischen 0 und 9 generieren
A = random.randint(5, 7)
B = random.randint(8, 9)
C = random.randint(0, 1)
D = random.randint(2, 4)
a = random.randint(5, 7)
b = random.randint(0, 1)
c = random.randint(8, 9)
d = random.randint(2, 4)

# Formatierte Bimatrix ausgeben
# print(f"     l    r\n o  {A},{a}  {C},{c}\n u  {B},{b}  {D},{d}")

plot = create_plot()

plot

```

```{python}

# Funktionen für Nash-Bedingungen
def is_ol_nash(A, B, a, c):
  return "ol" if (A >= B) and (a >= c) else "not_ol"

def is_ul_nash(B, A, b, d):
  return "ul" if (B >= A) and (b >= d) else "not_ul"

def is_or_nash(C, D, c, a):
  return "or" if (C >= D) and (c >= a) else "not_or"

def is_ur_nash(D, C, d, b):
  return "ur" if (D >= C) and (d >= b) else "not_ur"

# Nash-Bedingungen überprüfen und Strings zuweisen
Cand_Nash_ol = is_ol_nash(A, B, a, c)
Cand_Nash_ul = is_ul_nash(B, A, b, d)
Cand_Nash_or = is_or_nash(C, D, c, a)
Cand_Nash_ur = is_ur_nash(D, C, d, b)

# Ergebnisse kombinieren und NAs entfernen
Nash_GG = np.array([Cand_Nash_ol, Cand_Nash_ul, Cand_Nash_or, Cand_Nash_ur])
Nash_GG_filtered = []
for element in Nash_GG:
  if element == "ol" or element == "ul" or element == "or" or element == "ur":
    Nash_GG_filtered.append(element)

# Ergebnis ausgeben
print(f"Nash-Gleichgewicht(e) in reinen Strategien: {', '.join(Nash_GG_filtered)}")
```

##### Spiel ohne Gleichgewicht

```{python}

import numpy as np
import random

while True:
    A = random.randint(0, 9)
    a = random.randint(0, 9)
    B = random.randint(0, 9)
    b = random.randint(0, 9)
    C = random.randint(0, 9)
    c = random.randint(0, 9)
    D = random.randint(0, 9)
    d = random.randint(0, 9)

    # Bedingungen prüfen
    cond1 = (A >= B) and (a >= c)
    cond2 = (B >= A) and (b >= d)
    cond3 = (C >= D) and (c >= a)
    cond4 = (D >= C) and (d >= b)

    # Wenn keine Bedingung erfüllt ist, Schleife beenden
    if not (cond1 or cond2 or cond3 or cond4):
        break

plot = create_plot()

plot

```

```{python}

# Nash-Bedingungen überprüfen und Strings zuweisen
Cand_Nash_ol = is_ol_nash(A, B, a, c)
Cand_Nash_ul = is_ul_nash(B, A, b, d)
Cand_Nash_or = is_or_nash(C, D, c, a)
Cand_Nash_ur = is_ur_nash(D, C, d, b)

# Ergebnisse kombinieren und NAs entfernen
Nash_GG = np.array([Cand_Nash_ol, Cand_Nash_ul, Cand_Nash_or, Cand_Nash_ur])
Nash_GG_filtered = []
for element in Nash_GG:
  if element == "ol" or element == "ul" or element == "or" or element == "ur":
    Nash_GG_filtered.append(element)

# Ergebnis ausgeben
print(f"Nash-Gleichgewicht(e) in reinen Strategien: {', '.join(Nash_GG_filtered)}")
```


#### Wiederholte Spiele

-   Ausgangspunkt Gefangenendilemma mit $B>A>D>C$ und $c>a>d>b$

- Nash-Gleichgewicht dann unten rechts mit der Auszahlung D, d

- Effizient wäre oben links mit Ausuahlung A, a

- Tit for Tat: Kooperiere in der ersten Runde, erwidere danach die Strategiewahl des Gegenspielers reziprok

- Dadurch "Bestrafung" für unkooperatives Verhalten möglich

- Funktioniert das immer?

- Funktioniert nicht bei bekannter endlicher Anzahl von Runden

- In jeder Runde wird mit der Wahrscheinlichkeit $p$ eine weitere Runde gespielt.

- Erwartungswert der Kooperationsgeflecht für $T$ Perioden (die Annahme einer endlichen Anzahl von Perioden wird gleich wieder aufgegeben)

  $E^1_k=\sum_{t=0}^T A \times p^t$

  Hilfsüberlegung: $(1-p)E^1_k = (1-p)\sum_{t=0}^T A \times p^t=A(\sum_{t=0}^T p^t - \sum_{t=0}^T p^{t+1})$
  
$=A(\sum_{t=0}^T p^t - \sum_{t=1}^{T+1}p^{t})$

$= A(1-p^{T+1})$

$\iff E^1_k=\frac{A(1-p^{T+1})}{1-p}$

  $$\boxed{\lim_{T \to \infty}{E^1_k}=\frac{A}{1-p}}$$

-   Erwartungswert der Nicht-Kooperation für Spieler 1: $E^1_{nk}= B+ \frac{D}{1-p}-D$

-   Erwartungswert der Kooperation für Spieler 2: $E^2_k= \frac{a}{1-p}$

-   Erwartungswert der Nicht-Kooperation für Spieler 2: $E^2_{nk}= c+ \frac{d}{1-p}-d$

-   Kooperation durch Spieler 1 wenn $p\geq \frac{B-A}{B-D}$

-   Kooperation durch Spieler 2 wenn $p\geq \frac{c-a}{c-d}$


```{python}
#| eval: false


from sympy import Symbol, solve, Eq

A = Symbol('A')
B = Symbol('B')
C = Symbol('C')
D = Symbol('D')
a = Symbol('a')
b = Symbol('b')
c = Symbol('c')
d = Symbol('d')
p = Symbol('p')

# Ungleichung aufstellen

E_1K = A/(1-p)


E_1NK = B+ D/(1-p)-D


Bedingung = Eq(E_1K, E_1NK)


sol1=solve(Bedingung, p) # wie löse ich das als Ungleichung?

print(sol1)

E_2K = a/(1-p)

E_2NK = c+ d/(1-p) -d

Bedingung = Eq(E_2K, E_2NK)

sol2 = solve(Bedingung, p)
print(sol2)
```


```{python}
#| eval: false


import numpy as np

import random

# Zufällige Ganzzahlen zwischen 0 und 9 generieren
A = random.randint(5, 7)
B = random.randint(8, 9)
C = random.randint(0, 1)
D = random.randint(2, 4)
a = random.randint(5, 8)
b = random.randint(0, 1)
c = random.randint(8, 9)
d = random.randint(2, 4)

# Formatierte Bimatrix ausgeben
print("    l   r")
print(f"o  {A},{a}  {C},{c}")
print(f"u  {B},{b}  {D},{d}")


# Funktionen für Nash-Bedingungen
def is_ol_nash(A, B, a, c):
  return "ol" if (A >= B) and (a >= c) else "not_ol"

def is_ul_nash(B, A, b, d):
  return "ul" if (B >= A) and (b >= d) else "not_ul"

def is_or_nash(C, D, c, a):
  return "or" if (C >= D) and (c >= a) else "not_or"

def is_ur_nash(D, C, d, b):
  return "ur" if (D >= C) and (d >= b) else "not_ur"

# Nash-Bedingungen überprüfen und Strings zuweisen
Cand_Nash_ol = is_ol_nash(A, B, a, c)
Cand_Nash_ul = is_ul_nash(B, A, b, d)
Cand_Nash_or = is_or_nash(C, D, c, a)
Cand_Nash_ur = is_ur_nash(D, C, d, b)

# Ergebnisse kombinieren und NAs entfernen
Nash_GG = np.array([Cand_Nash_ol, Cand_Nash_ul, Cand_Nash_or, Cand_Nash_ur])
Nash_GG_filtered = []
for element in Nash_GG:
  if element == "ol" or element == "ul" or element == "or" or element == "ur":
    Nash_GG_filtered.append(element)

# Ergebnis ausgeben
print(Nash_GG_filtered)

# Kritisches p für Kooperation

p_krit = (B-A)/(B - D)
#print(round(p_krit,3))
print(f"Für Kooperation durch Spieler 1 muss die Wahrscheinlichkeit für eine weitere Runde mindestens {str(round(p_krit,3)).replace('.',',')} betragen.")

p_krit = (c-a)/(c - d)
#print(round(p_krit,3))
print(f"Für Kooperation durch Spieler 2 muss die Wahrscheinlichkeit für eine weitere Runde mindestens {str(round(p_krit,3)).replace('.',',')} betragen.")

```


#### Trembling Hand

```{python}
#| message: false
#| warning: false

# Python

import random

random.seed(246)

while True:
    A = random.randint(0, 9)
    a = random.randint(0, 9)
    B = random.randint(0, 9)
    b = random.randint(0, 9)
   # C = random.randint(0, 9)
    C=-20
    c = random.randint(0, 9)
    D = random.randint(0, 9)
    d = random.randint(0, 9)

    # Bedingungen prüfen
    cond1 = (A > B) and (a >= c) # NGG ol
    cond2 = (D  > C) and (A > D) and (a > d)

    # Wenn beide Bedingung erfüllt ist, Schleife beenden
    if  (cond1 and cond2):
        break

# Ausgabe der Zahlen
#print(f"A={A}, a={a}, B={B}, b={b}, C={C}, c={c}, D={D}, d={d}")

# Formatierte Bimatrix ausgeben
#print("    l   r")
#print(f"o  {A},{a}  {C},{c}")
#print(f"u  {B},{b}  {D},{d}")


plot = create_plot()

plot


```


-   Idee: Manche Nash-Gleichgewichte sind riskant

-   Wenn der Gegenspieler "versehentlich" eine falsche Strategie spielt, dann macht man evtl hohe Verluste

-   Wie hoch darf die Fehlerwahrscheinlichkeit des Gegenspielers sein, damit das Nash-Gleichgewicht noch die richtige Strategie impliziert?

Angenommen, beide Spieler streben ein Nash-Gleichgewicht oben links an

**Für Spieler 1 muss dann gelten**

$E_o\geq E_u$

Wenn er davon ausgeht, dass Spieler 2 mit einer Wahrscheinlichkeit von $p$ versehentlich rechts statt links spielt, heißt das

$(1-p)A+pC \geq (1-p)B+pD$

$\iff A-pA+pC\geq B-pB+pD$

$\iff A-p(A-C) \geq B-p(B-D)$

$\iff p(B-D)-p(A-C) \geq B-A$

$\iff p(B-D-A+C)\geq B-A$

mit $(B-D-A+C) <0$

$\iff p \leq \frac{B-A}{B-A-D+C}=\frac{A-B}{A-B-C+D}$

**Für Spieler 2 muss dann gelten**

$E_l\geq E_r$

$(1-p)a+pb \geq (1-p)c+pd$

$\iff a-pa+pb \geq c-pc+pd$

$\iff a-p(a-b) \geq c-p(c-d)$

$\iff p(c-d)-p(a-b) \geq c-a$

$\iff p(c-d-a+b) \geq c-a$

mit $(c-d-a+b)\neq 0$

$p \leq \frac{c-a}{(c-d-a+b)}=\frac{a-c}{(a-b-c+d)}$

```{python}
#| echo: true
#| eval: false

# Wahrscheinlichkeiten ausrechnen

from sympy import Symbol, solve, Eq

symbols = [Symbol(name) for name in 'ABCDabcdp']
A, B, C, D, a, b, c, d, p = symbols  # Entpacken und als separate Variablen speichern

# Beide streben ol an

E_o= (1-p)*A+p*C

E_u= (1-p)*B + p*D

sol = solve(Eq(E_o, E_u), p)
print(sol)

E_l = (1-p)*a + p*b
E_r = (1-p)*c + p*d

sol = solve(Eq(E_l, E_r),p)
print(sol)

```

### Gemischte Strategien

- Wenn es entweder kein Nash-Gleichgewicht (in reinen Strategien) gibt oder mehrere Nash-Gleichgewichte, dann lässt sich das Handeln der Spielenden nicht gut vorhersagen

- Aus der Perspektive jedes Spielenden ist das Handeln des Gegenübers eine Zufallsvariable. Mit einer bestimmten Wahrscheinlichkeit wählt das Gegenüber eine seiner Strategien.

- Den Zufall kann man aber näher charakterisieren, wenn man sich überlegt, **welche Wahrscheinlichkeiten ein rationales Gegenüber wählen würde**.

- Ein rationales Gegenüber wählt die Wahrscheinlichkeiten so, dass der spielende Akteur keine Möglichkeit mehr hat, seine Situation durch die Wahl seiner Strategie zu verbessern. 
- Jede spielende Person wählt die Wahrscheinlichkeiten für ihre Handlung also so, dass das jeweilige Gegenüber indifferent ist in der Wahl seiner Handlungen.

- Es muss also gelten: $$E_o=E_u$$
$$\iff p_l A+(1-p_l)C=p_lB+(1-p_l)D$$


$$\iff p_l A + C-p_lC=p_lB+D-p_lD$$

$$\iff p_l(A-C)+C=p_l(B-D)+D$$

$$\iff p_l(A-C-B+D)=D-C$$
$$\boxed{p_l=\frac{D-C}{A-B-C+D}}$$
$$E_l=E_r$$

$$\iff p_o a+(1-p_o)b=p_o c + (1-p_o)d$$

$$\iff p_o a+b-p_ob=p_oc+d-p_od$$
$$\iff p_o(a-b)+b=p_o(c-d)+d$$

$$\iff p_o(a-b-c+d)=d-b$$

$$\iff \boxed{p_o=\frac{d-b}{a-b-c+d}}$$



```{python}
#| message: false
#| warning: false

import numpy as np
import random
from lets_plot import *

random.seed(12)

while True:
    A = random.randint(0, 9)
    a = random.randint(0, 9)
    B = random.randint(0, 9)
    b = random.randint(0, 9)
    C = random.randint(0, 9)
    c = random.randint(0, 9)
    D = random.randint(0, 9)
    d = random.randint(0, 9)

    # Bedingungen prüfen: Keine dominante Strategien
    cond1 = (A >= B) and (C >= D)
    cond2 = (B >= A) and (D >= C)
    cond3 = (a >= c) and (b >= d)
    cond4 = (c >= a) and (d >= b)

    # Wenn keine Bedingung erfüllt ist, Schleife beenden
    if not (cond1 or cond2 or cond3 or cond4):
        break

plot = create_plot()

plot



# Funktionen für Nash-Bedingungen
def is_ol_nash(A, B, a, c):
  return "ol" if (A >= B) and (a >= c) else "not_ol"

def is_ul_nash(B, A, b, d):
  return "ul" if (B >= A) and (b >= d) else "not_ul"

def is_or_nash(C, D, c, a):
  return "or" if (C >= D) and (c >= a) else "not_or"

def is_ur_nash(D, C, d, b):
  return "ur" if (D >= C) and (d >= b) else "not_ur"

# Nash-Bedingungen überprüfen und Strings zuweisen
Cand_Nash_ol = is_ol_nash(A, B, a, c)
Cand_Nash_ul = is_ul_nash(B, A, b, d)
Cand_Nash_or = is_or_nash(C, D, c, a)
Cand_Nash_ur = is_ur_nash(D, C, d, b)

# Ergebnisse kombinieren und NAs entfernen
Nash_GG = np.array([Cand_Nash_ol, Cand_Nash_ul, Cand_Nash_or, Cand_Nash_ur])
Nash_GG_filtered = []
for element in Nash_GG:
  if element == "ol" or element == "ul" or element == "or" or element == "ur":
    Nash_GG_filtered.append(element)



# Ergebnis ausgeben
if Nash_GG_filtered == []:
   print('Es gibt kein Nash-Gleichgewicht in reinen Strategien')

else:
   print(f"Nash-Gleichgewicht(e) in reinen Strategien: {', '.join(Nash_GG_filtered)}")



# Anzahl der Nash GG

#Anzahl_NGG=len(Nash_GG_filtered)
#print(Anzahl_NGG)

# Wahrscheinlichkeiten ausrechnen.
# Dabei jeweils den Fall Division duch 0 aussschließen

#p_l
if (A - B - C + D)!=0: p_l = ( D-C)/(A - B - C + D)

#print(round(p_l, 2))

#p_o
if (-b + d)/(a - b - c + d)!=0: p_o = (-b + d)/(a - b - c + d)

#print(round(p_o, 2))


# Ausgabe Abhängig von Bedingungen

if (#Anzahl_NGG == 1 or
    p_o < 0 or p_l < 0 or
            p_o > 1 or p_l > 1 or
            (a - b - c + d) == 0 or
            (A - B - C + D) == 0):
    print("Kein Nash-Gleichgewicht in gemischten Strategien")
else:   print(f"Gemischte Strategien: p_o= {round(p_o, 2)}, p_l= {round(p_l, 2)}")
```




```{python}
#| eval: false

# Wahrscheinlichkeiten ausrechnen

from sympy import Symbol, solve, Eq

symbols = [Symbol(name) for name in 'ABCDabcdp']
A, B, C, D, a, b, c, d, p = symbols  # Auspacken in verschiedene Variablen


#p_l
E_o= p*A+(1-p)*C

E_u= p*B  + (1-p)*D

sol = solve(Eq(E_o, E_u), p)
print(sol)

#p_o

E_l = p*a + (1-p)*b
E_r = p*c + (1-p)*d

sol = solve(Eq(E_l, E_r),p)
print(sol)
```


## Sequenzielle Spiele

Spieler spielen nacheinander. Dabei kann man die Fälle unterscheiden, dass die Spieler ihre vorherigen Züge sehen können oder nicht oder unvollständig. Man kann ebenso die Fälle unterscheiden, dass sie die Auszahlungen der Mitspieler kennen oder nicht oder unvollständig informiert sind.

### Vollständige Information

Annahme: Alle Spieler kennen alle Auszahlungen und sehen alle bislang erfolgten Spielzüge

Darstellung des Spiels mittels eines Spielbaums. Die Benennung der Auszahlungen mit $A,a$ für oben rechts usw. folgt der Darstellung für simultane Spiele.

![Grundstruktur eines Spielbaums](figure/Baum-Grundstruktur-1.png){width="50%"}

#### Rückwärtsinduktion

Sequenzielle Spiele wereden 	&bdquo;von hinten nach vorn&ldquo; gelöst. Man löst zunächst alle Entscheidungen der Vorrunde, dann die der Runde davor usw. Auf diese Weise vollzieht man nach, dass rationale Spieler die rationalen Entscheidungen ihrer Mitspieler antizipieren. 

##### Beispiele

![Beispiel für Rückwärtsinduktion](figure/Baum-Rückwärtsinduktion-a-1.png){width="50%"}

![Beispiel für Rückwärtsinduktion](figure/Baum-Rückwärtsinduktion-b-1.png){width="50%"}

##### Bedingungen für ein Nash-Gleichgewicht

Zunächst vereinfachende Annahme: $a\neq c\ \text{und}\ b \neq d$


**ol**: $a>c \land ((A>B\ \land\ b>d) \lor (A>D\ \land\ d>b))$

**or**: $c>a  \land ((C>D\ \land d>b) \lor (C>B\ \land b> d))$

**ul**: $b>d \land ((B>A \land a>c)\lor(B>C \land c>a))$

**ur**: $d>b \land ((D>A \land a>c)\lor (D>C \land c>a))$



```{python}
import numpy as np
import random

random.seed(123) # Für reproduzierbare Ergebnisse ggf. fixieren

# Zufällige Ganzzahlen zwischen 0 und 9 generieren
#A = random.randint(0, 9)
#B = random.randint(0, 9)
#C = random.randint(0, 9)
#D = random.randint(0, 9)
#a = random.randint(0, 9)
#b = random.randint(0, 9)
#c = random.randint(0, 9)
#d = random.randint(0, 9)

#A = 1
#B = 0
#C = 0
#D = 0
#a = 1
#b = 0
#c = 0
#d = 0

# Zufallszahlen, aber alle unterschiedlich
choices = np.arange(10)

# Generate unique random integers for variables
Parameter = np.random.choice(choices, size=8, replace=False)
A, B, C, D, a, b, c, d = Parameter


# Formatierte Bimatrix ausgeben
#print("    l   r")
#print(f"o  {A},{a}  {C},{c}")
#print(f"u  {B},{b}  {D},{d}")


# Spielbaum ausgeben

print(f" ol: {A}, {a}\n or: {C}, {c}\n ul: {B}, {b}\n ur: {D}, {d}")

# Funktionen für Nash-Bedingungen
# Spieler 2 (a) entscheidet l/r, Spieler 1 (A) entscheidet o/u
def is_ol_nash(A, B, D, a, b, c, d):
  return "ol" if ((a > c) and ((A>= B and b> d) or
              (A >= D and d>=b))) else "not_ol"

def is_or_nash( B, C, D, a, b, c, d):
  return "or" if (c>a and ((C>= B and b>=d) or
              (C >= D and d>b))) else "not_or"


def is_ul_nash(A, B, C,  a, b, c, d):
  return "ul" if (b>=d and ((B>= A and a>= c) or
              (B >= C and c>=a))) else "not_ul"


def is_ur_nash(A,  C, D, a, b, c, d):
  return "ur" if (d>=b and ((D>= A and a>= c) or
              (D >= C and c>=a))) else "not_ur"


# Nash-Bedingungen überprüfen und Strings zuweisen

Cand_Nash_ol = is_ol_nash(A, B,    D, a, b, c, d)
Cand_Nash_or = is_or_nash(   B, C, D, a, b, c, d)
Cand_Nash_ul = is_ul_nash(A, B, C,    a, b, c, d)
Cand_Nash_ur = is_ur_nash(A,    C, D, a, b, c, d)

# Ergebnisse kombinieren und NAs entfernen
Nash_GG = np.array([Cand_Nash_ol, Cand_Nash_ul, Cand_Nash_or, Cand_Nash_ur])
Nash_GG_filtered = []
for element in Nash_GG:
  if element == "ol" or element == "or" or element == "ul" or element == "ur":
    Nash_GG_filtered.append(element)

# Ergebnis ausgeben
print(Nash_GG_filtered)
```

#### Teilspielperfektheit

-   Teilspielperfektheit verlangt, dass jeder Spieler jeden Zug so ausführt, dass das Ergebnis des Zuges seinen Interessen nicht schadet.

-   Ein Teilspiel beginnt in einem Knoten und enthält alle nachfolgenden Knoten

-   Für später: Ein Teilspiel darf nachfolgende Informationsmengen nicht teilen. Es gehören also immer alle Knoten einer Informationsmenge zu einem Teilspiel

Beispiel: Unglaubwürdige Drohung

![Unglaubwürdige Drohung](figure/Baum-Unglaubwürdige-Drohung-1.png){width="50%"}


Hier: Tafelaufschrieb Markteintrittsspiel

#### Selbstbindung

Hier: [Sonderabbildung Weltvernichtungsbombe aus @Winter-Spieltheorie](https://neo.hfwu.de/sendfile.php?force_download=1&type=0&file_id=c47cc228ea9b922bd29c873be1980fa3&file_name=Baum_Weltvernichtung_komplett.pdf)

- Automatisierung der Drohung erzeugt erwünschte Glaubwürdigkeit

- Aber: Automatisierung ist riskant, wenn Fehler möglich sind.

- Trembling Hand Überlegungen


```{python}
#| message: false
#| warning: false

# Python

A= 1
a= 1
B= -1
b= -1
C= 1
c= 1
D= 2
d= 0


from lets_plot import *

LetsPlot.setup_html()

ggplot() + \
geom_text(x=- .5, y= 2   , label=a) +\
geom_text(x=-1.5, y=  .75, label=A) +\
geom_text(x=- .5, y=-1   , label=b) +\
geom_text(x=-1.5, y=-2.25, label=B) +\
geom_text(x= 1.5, y= 2   , label=c) +\
geom_text(x=  .5, y=  .75, label=C) +\
geom_text(x= 1.5, y=-1   , label=d) +\
geom_text(x=  .5, y=-2.25, label=D) +\
geom_text(x=-1  , y= 3.3 , label='automatische Bombe')+\
geom_text(x= 1  , y= 3.3 , label='nichtautomatische Bombe')+\
geom_text(x=-2.2, y= 1.375, angle=90, label='Kein Angriff')+\
geom_text(x=-2.2, y=-1.625, angle=90, label='Angriff')+\
geom_text(x= 0 , y= 4 ,
          fontface = "bold", label='UdSSR')+\
geom_text(x=-2.7 , y= 0 , angle=90,
          fontface = "bold", label='USA')+\
geom_segment(x=-2,  xend= 2, y= 0, yend= 0) +\
geom_segment(x=-2,  xend= 2, y= 3, yend= 3) +\
geom_segment(x=-2,  xend= 2, y=-3, yend=-3) +\
geom_segment(x=-2,  xend=-2, y=-3, yend= 3) +\
geom_segment(x= 0,  xend= 0, y=-3, yend= 3) +\
geom_segment(x= 2,  xend= 2, y=-3, yend= 3) +\
theme_void()+\
labs(title='Auszahlungen im Szenario mit Weltvernichtungsbombe')

```
- Zwei Nash-Gleichgewichte

- Zunächst das Gleichgewicht oben links

- Wie ist es einzuschätzen, wenn beide Spieler mit einer Wahrscheinlichkeit $p_i$ mit $i \in (\text{USA, UdSSR})$ einen Fehler machen?

**Kalkül der USA:**

$E_{kA}=(1-p_{\text{UdSSR}}) 1 + p_{\text{UdSSR}} 1 =1$

$E_A=(1-p_{\text{UdSSR}}) (-1) + p_{\text{UdSSR}} 2$

$=-1 + p_{\text{UdSSR}} +2 p_{\text{UdSSR}}=-1+ 3 p_{\text{UdSSR}}$

$E_{kA}\geq E_A$

$1\geq -1+ 3 p_{\text{UdSSR}}$

$\iff p_{\text{UdSSR}} \leq \frac{2}{3}$


**Kalkül der UdSSR**

$E_{aB}=(1-p_{\text{USA}}) 1 + p_{\text{USA}} (-1) = 1-2p_{\text{USA}}$

$E_{naB}= (1-p_{\text{USA}}) 1 + p_{\text{USA}} 0 = 1-p_{\text{USA}}$

$E_{aB} \geq E_{naB}$

$1-2p_{\text{USA}} \geq 1-p_{\text{USA}}$

$\iff p_{\text{USA}} \leq 0$


$\rightarrow$ das Gleichgewicht ist nicht trembling-Hand-perfekt

Wie sieht es mit dem anderen Gleichgewichht aus? 

Probieren Sie es aus!

$E_A=$

$E_{kA}=$

### Unvollständige Information

#### Alles beobachtbar, aber Auszahlungen für Spieler 1 u/o 2 können gleich sein

![Auszahlungen von Spieler 1 sind gleich](figure/Baum-Gleiche-Auszahlungen-S1-1.png){width="50%"}

$\rightarrow$ Spieler 1 muss sich irgendwie entscheiden, aber Spieler 2 kann die Entscheidung sehen.

$\rightarrow$ Unproblematischer Fall

![Auszahlungen von Spieler 2 sind gleich](figure/Baum-Gleiche-Auszahlungen-S2-1.png){width="50%"}

$\rightarrow$ Spieler 1 kann nicht antizipieren, was Spieler 2 im Fall "unten" macht. 

$\rightarrow$ Kriterium für Entscheidung unter Risiko

Mögliche Kriterien:

- **Erwartungswert**
- Erwartungsnutzen
- Maximin
- $\dots$

Hier unterstellt: Erwartungswertkriterium

Die Bedingungen für ein Nash-Gleichgewicht bei sequenziellen Spielen lauten dann:


[ja wie?]::


**ol**: $a>c \land ((A\geq B\ \land\ b \geq d) \lor (A \geq  D\ \land\ d \geq b) ) \lor a=c \land ((b>d \land (\frac{A+C}{2} \geq B)\lor (d>b \land \frac{A+C}{2}\geq D) \lor (b=d \land(\frac{A+C}{2}\geq \frac{B+D}{2})))$

**or**: $c>a  \land ((C>D\ \land d>b) \lor (C>B\ \land b> d)) \lor a=c \land ((b>d \land (\frac{A+C}{2} \geq B)\lor (d>b \land \frac{A+C}{2}\geq D) \lor (b=d \land(\frac{A+C}{2}\geq \frac{B+D}{2})))$

**ul**: $b>d \land ((B>A \land a>c)\lor(B>C \land c>a))\lor b=d \land ((a>c \land (\frac{B+D}{2} \geq A)\lor (c>a \land \frac{B+D}{2}\geq C) \lor (b=d \land(\frac{B+D}{2}\geq \frac{A+C}{2})))$

**ur**: $d>b \land ((D>A \land a>c)\lor (D>C \land c>a))\lor b=d \land ((a>c \land (\frac{B+D}{2} \geq A)\lor (c>a \land \frac{B+D}{2}\geq C) \lor (b=d \land(\frac{B+D}{2}\geq \frac{A+C}{2})))$

```{python}
#| include: false

# Spielbaum vollständige Information
import numpy as np
import random

#random.seed(123) # Für reproduzierbare Ergebnisse ggf. fixieren

# Zufällige Ganzzahlen zwischen 0 und 9 generieren
A = random.randint(0, 9)
B = random.randint(0, 9)
C = random.randint(0, 9)
D = random.randint(0, 9)
a = random.randint(0, 9)
b = random.randint(0, 9)
c = random.randint(0, 9)
d = random.randint(0, 9)

# Formatierte Bimatrix ausgeben
#print("    l   r")
#print(f"o  {A},{a}  {C},{c}")
#print(f"u  {B},{b}  {D},{d}")


# Spielbaum ausgeben

print(f" ol: {A}, {a}\n or: {C}, {c}\n ul: {B}, {b}\n ur: {D}, {d}")


# Annahme: Spieler 2 sieht Zug von Spieler 1.
# Beide Spieler kennen alle Auszahlungen
# Spieler 2 zieht nach Spieler 1



# Funktionen für Nash-Bedingungen
# Spieler 2 (a) entscheidet l/r, Spieler 1 (A) entscheidet o/u

# Funktionen für Nash-Bedingungen


def is_ol_nash(A, B, C, D, a, b, c, d):
  return "ol" if (a > c and ((A>= B and b>=d)  or
                            (A >= D and d>=b)) or
                 (a==c and ((b>d  and (A+C)/2>=B) or
                           (d>b  and (A+C)/2>=D) or
                           (d==b and (A+C)/2>=(B+D)/2)))) else "not_ol"

def is_or_nash(A, B, C, D, a, b, c, d):
  return "or" if (c > a and ((C>= B and b>=d)  or
                            (C >= D and d>=b)) or
                 (c==a and ((b>d  and (A+C)/2>=B) or
                           (d>b  and (A+C)/2>=D) or
                           (d==b and (A+C)/2>=(B+D)/2)))) else "not_or"




def is_ul_nash(A, B, C, D, a, b, c, d):
  return "ul" if (b > d and ((B>= A and a>=c)  or
                            (B >= C and c>=a)) or
                 (b==d  and ((a>c  and (B+D)/2>=A) or
                           (c>a  and (B+D)/2>=C) or
                           (a==c and (B+D)/2>=(A+C)/2)))) else "not_ul"


def is_ur_nash(A, B, C, D, a, b, c, d):
  return "ur" if (d > b and ((D>= A and a>=c)  or
                            (D >= C and c>=a)) or
                 (d==b and ((a>c  and (B+D)/2>=A) or
                           (c>a  and (B+D)/2>=C) or
                           (a==c and (B+D)/2>=(A+C)/2)))) else "not_ur"


# Nash-Bedingungen überprüfen und Strings zuweisen

Cand_Nash_ol = is_ol_nash(A, B, C, D, a, b, c, d)
Cand_Nash_or = is_or_nash(A, B, C, D, a, b, c, d)
Cand_Nash_ul = is_ul_nash(A, B, C, D, a, b, c, d)
Cand_Nash_ur = is_ur_nash(A, B, C, D, a, b, c, d)

# Ergebnisse kombinieren und NAs entfernen
Nash_GG = np.array([Cand_Nash_ol, Cand_Nash_ul, Cand_Nash_or, Cand_Nash_ur])
Nash_GG_filtered = []
for element in Nash_GG:
  if element == "ol" or element == "or" or element == "ul" or element == "ur":
    Nash_GG_filtered.append(element)

# Ergebnis ausgeben
print(Nash_GG_filtered)
```

#### Zug von Spieler 1 ist für Spieler 2 unsichtbar

Durch eine gestrichelte Linie im Spielbaum werdn die Knoten verbunden, die ein Spieler nicht voneinander unterscheiden kann. Die spielende Person weiß also nicht, ob sie sich in dem einen Knoten am einen Ende der gestrichelten Linie befindet oder am anderen Ende.


![Baum Zug 1 unsichtbar ](figure/Baum-Zug1-unsichtbar-1.png)
- Fehlende Information ist für Spieler 2 kein Problem, wenn er eine dominante Alternative hat oder wenn alle Auszahlungen für ihn gleich sind.

- Fehlende Information für Spieler 2 ist auch kein Problem, wenn Spieler 1 eine dominante Alternative hat.

- Wenn Information nicht vorliegt, Entscheidungskriterium unter Risiko nutzen. Hier: Erwartungswert

```{python}
#|echo: false
#| eval: false
#| include: false


import numpy as np
import random

#random.seed(123) # Für reproduzierbare Ergebnisse ggf. fixieren

# Zufällige Ganzzahlen zwischen 0 und 9 generieren

A, B, C, D, a, b, c, d = random.choices(range(10), k=8)


# Formatierte Bimatrix ausgeben
#print("    l   r")
#print(f"o  {A},{a}  {C},{c}")
#print(f"u  {B},{b}  {D},{d}")


# Spielbaum ausgeben

print(f" ol: {A}, {a}\n or: {C}, {c}\n ul: {B}, {b}\n ur: {D}, {d}")


# Annahme: Spieler 2 sieht Zug von Spieler 1 nicht


# Kommentare zur Strategie



# Funktionen für Nash-Bedingungen
# Spieler 2 (a) entscheidet l/r, Spieler 1 (A) entscheidet o/u 

#def is_ol_nash(A, B, C, D, a, b, c, d):
#  return "ol" if ...
#              else "not_ol"

#def is_or_nash(A, B, C, D, a, b, c, d):
 # return "or" if... 
  #          else "not_or"


#def is_ul_nash(A, B, C, D, a, b, c, d):
#  return "ul" if ...
 #             else "not_ul"


#def is_ur_nash(A, B, C, D, a, b, c, d):
#  return "ur" if ...
 #             else "not_ur"


# Nash-Bedingungen überprüfen und Strings zuweisen

Cand_Nash_ol = is_ol_nash(A, B, C, D, a, b, c, d)
Cand_Nash_or = is_or_nash(A, B, C, D, a, b, c, d)
Cand_Nash_ul = is_ul_nash(A, B, C, D, a, b, c, d)
Cand_Nash_ur = is_ur_nash(A, B, C, D, a, b, c, d)

# Ergebnisse kombinieren und NAs entfernen
Nash_GG = np.array([Cand_Nash_ol, Cand_Nash_ul, Cand_Nash_or, Cand_Nash_ur])
Nash_GG_filtered = []
for element in Nash_GG:
  if element == "ol" or element == "or" or element == "ul" or element == "ur":
    Nash_GG_filtered.append(element)
    
#Ergebnis ausgeben
print(Nash_GG_filtered)
```


#### Typ von Spieler 1 (und damit die Menge seiner Auszahlungen) ist für Spieler 2 unsichtbar


s. Tafelaufschrieb

Grundsätzlich zwei verschiedene Typen von Gleichgewichten:

- Separierende Gleichgewichte: Spieler 1 offenbart durch seine Entscheidung, von welchem Typ er ist

- Pooling Gleichgewichte: Man kann kann aus dem Handeln des Spielers 1 nicht auf seinen Typ schließen

![Typ Spieler 1 unsichtbar. Separierendes Gleichgewicht](figure/Baum-Typ-unsichtbar-1.png) 


![Typ Spieler 1 unsichtbar. Pooling-Gleichgewicht](figure/Baum-Typ-unsichtbar2-1.png) 

- Das Verhalten des Spielers 1 lässt jetzt keinen Schluss mehr auf seinen Typ zu.

- Entscheidung unter Risiko (hier: Erwartungswert für Spieler 2 berechnen)

  - $E_l=0,6 \times 7 + 0,4 \times 4=5,8$

  - $E_r=0,6 \times 5 + 0,4 \times 9=6,6$

- Der Erwartungswert für "rechts" ist also höher als der für "links"


![Typ Spieler 1 unsichtbar. Signalspiel](figure/Baum-Typ-unsichtbar3-1.png) 
- Spieler 2 spielt "rechts", wenn "unten"

- Spieler 2 spielt "links", wenn "oben"

- Spieler 1 spielt "oben", wenn Typ 1

- Spieler 1 spielt "unten", wenn Typ 2

[## Koalitionsspiele]::

## Evolutionäre Spiele

[https://eckhartarnold.de/papers/2009_Vorlesung_Entscheidungstheorie/node127.html]:

### Grundlagen

- Modell zur Beschreibung der Verbreitung bestimmter Strategien in Populationen basierend auf relativer Fitness  

- Unterscheidet sich von klassischer Spieltheorie durch Fokus auf evolutionäre Selektion statt rationaler Entscheidungen  

- **Grundkonzepte der evolutionären Spieltheorie**  
  - Betrachtet Populationen mit unterschiedlichen Verhaltensstrategien  

  - Frequenzabhängige Selektion: Fitness hängt von Populationszusammensetzung ab  

  - Drei evolutionäre Grundprinzipien:  
    - Replikation  
    - Selektion  
    - Mutation (in Grundmodellen oft vernachlässigt)  

  - Mathematische Beschreibung durch Normalformspiele mit Auszahlungsmatrix $U = [u_{ij}]$  

  - Hier: 2 Spielertypen $i=1,2$

- **Replikatordynamik-Gleichung**  
  - Kontinuierliche Differentialgleichung für unendliche (oder zumindest sehr große) Populationen:  
$$\dot{p}_i = p_i \left(f_i(P_t) - \bar{f}(P_t)\right)$$
    - $P_t$: Zusammensetzung der Population zum Zeitpunkt $t$
    - $p_i$: Anteil der Strategie-i-Spieler  
    - $f_i(P_t)$: Fitness der Strategie $i$ zum Zeitpunkt $t$
    - $\bar{f}(P_t)$: Durchschnittliche Populationsfitness zum Zeitpunkt $t$  
  - Fitnessberechnung:

$$f_1(P_t) = p_1 u_{11} + (1-p_1) u_{12}$$
$$f_2(P_t) = p_1 u_{21} + (1-p_1) u_{22}$$

  - Durchschnittsfitness:  

$$\bar{f}(P_t) = p_1 f_1(P_t) + (1-p_1) f_2(P_t)$$

- Kernaussage: Der Anteil der Population, der eine überdurchschnittlicher Fitness aufweist, wächst, der andere schrumpft.

- Grundsätzlich möglich

  - Randlösungen: Eine Strategie setzt sich komplett durch
  
  - Stabile Anteile der Strategien

### Einige Spiele

#### Koordinationsspiel

- Im (klassischen) Koordinationsspiel gibt es  ein Gleichgewicht in gemischten Strategien

- In einem evolutionären (klassischen) Koordinationsspiel sind drei Fälle in Abhängigkeit der Ausgangsverteilung der Strategien möglich

  - Die Anteile der Strategien entsprechen den Wahrscheinlichkeiten des Gleichgewichts in gemischten Strategien

  - Die Anteile der Strategien konvergieren gegen das eine Nash-Gleichgewicht in reinen Strategien

  - Die Anteile konvergieren gegen das andere Gleichgewicht
  
```{python}
#| message: false
#| warning: false

# Python


A= 1
a= 1
B= 0
b= 0
C= 0
c= 0
D= 1
d= 1


from lets_plot import *

LetsPlot.setup_html()

ggplot() + \
geom_text(x=- .5, y= 2   , label=a) +\
geom_text(x=-1.5, y=  .75, label=A) +\
geom_text(x=- .5, y=-1   , label=b) +\
geom_text(x=-1.5, y=-2.25, label=B) +\
geom_text(x= 1.5, y= 2   , label=c) +\
geom_text(x=  .5, y=  .75, label=C) +\
geom_text(x= 1.5, y=-1   , label=d) +\
geom_text(x=  .5, y=-2.25, label=D) +\
geom_text(x=-1  , y= 3.3 , label='I')+\
geom_text(x= 1  , y= 3.3 , label='II')+\
geom_text(x=-2.2, y= 1.375, angle=90, label='I')+\
geom_text(x=-2.2, y=-1.625, angle=90, label='II')+\
geom_text(x= 0 , y= 4 ,
          fontface = "bold", label='Spieler 2')+\
geom_text(x=-2.7 , y= 0 , angle=90,
          fontface = "bold", label='Spieler 1')+\
geom_segment(x=-2,  xend= 2, y= 0, yend= 0) +\
geom_segment(x=-2,  xend= 2, y= 3, yend= 3) +\
geom_segment(x=-2,  xend= 2, y=-3, yend=-3) +\
geom_segment(x=-2,  xend=-2, y=-3, yend= 3) +\
geom_segment(x= 0,  xend= 0, y=-3, yend= 3) +\
geom_segment(x= 2,  xend= 2, y=-3, yend= 3) +\
theme_void()+\
labs(title='Auszahlungen in einem Koordinationsspiel')
```
  

```{python}
#| message: false
#| warning: false

#p_l
if (A - B - C + D)!=0: p_l = ( D-C)/(A - B - C + D)

#print(round(p_l, 2))

#p_o
if (-b + d)/(a - b - c + d)!=0: p_o = (-b + d)/(a - b - c + d)

#print(round(p_o, 2))


# Ausgabe Abhängig von Bedingungen

if (#Anzahl_NGG == 1 or
    p_o < 0 or p_l < 0 or
            p_o > 1 or p_l > 1 or
            (a - b - c + d) == 0 or
            (A - B - C + D) == 0):
    print("Kein Nash-Gleichgewicht in gemischten Strategien")
else:   print(f"Gemischte Strategien: p_o= {round(p_o, 2)}, p_l= {round(p_l, 2)}")
```

Für dieses Spiel beträgt im Gleichgewicht in gemischten Strategien $p_I=p_II=0,5$

- Erster Fall: Schon zu Beginn des Spiels entsprechen die Populationsanteile diesen Werten und die Replikatordynamik ist deterministisch. Dann ist die Zusammensetzung der Population stabil.

- Zweiter Fall: Schon zu Beginn des Spiels entsprechen die Populationsanteile diesen Werten und die Replikatordynamik ist stochastisch. Dann ist die Zusammensetzung der Population instabil und konvergiert gegen $p_I=0$ oder gegen $p_I=1$.

- Dritter Fall: Zu Beginn des Spiels gilt $p_I \neq 0.5$. Dann konvergiert gegen $p_I=0$ oder gegen $p_I=1$, je nachdem ob zu Beginn $p_I$ kleiner oder größer $0,5$ war.

```{python}
#| message: false
#| warning: false

import sympy as sp
import numpy as np
from lets_plot import *

# Symbolische Berechnung des Gleichgewichts mit sympy
p = sp.symbols('p')
F_II = p * D + (1 - p) * B
F_I = p * C + (1 - p) * A
equilibrium_eq = sp.Eq(F_II, F_I)
equilibrium_p = sp.solve(equilibrium_eq, p)[0]
print(f"Das Gleichgewicht liegt bei p = {equilibrium_p}")

# Parameter für die Simulation
generations = 100
p_value = 0.5  # Startanteil der Strategie II
q_value=1-p_value
dt = 0.1
p_values = [p_value]
q_values = [q_value]
sigma=0

# Simulation
for _ in range(generations):
    F_II_val = p_value * D + (1 - p_value) * B
    F_I_val = p_value * C + (1 - p_value) * A
    F_avg = p_value * F_II_val + (1 - p_value) * F_I_val
    dp_dt = p_value * (F_II_val - F_avg) + np.random.normal(loc=0, scale=sigma) # noise
    p_value += dp_dt * dt
    p_values.append(p_value)
    q_values.append(1-p_value)

# Daten für den Plot vorbereiten

data = {
    'Generation': list(range(generations + 1))*2,
    'Strategien': [item for item in ["Strategie I","Strategie II"] for _ in range (generations + 1)],
    'Anteile'   : q_values + p_values
}

# print(data)

# Plot mit lets-plot

LetsPlot.setup_html()

p = (ggplot(data, aes(x='Generation', y='Anteile', color='Strategien')) +
     geom_line() +
     geom_hline(yintercept=float(equilibrium_p), color='red', linetype='dashed', size=1) +
     ggtitle('Evolution im Koordinationsspiel') +
     xlab('Generation') +
     ylab('Anteil der Strategien') +
     theme_minimal() #+
 #    + geom_text(x=11, y=float(equilibrium_p) + 0.05,
  #               label=f'Gleichgewicht p = #{round(equilibrium_p, 2)}', color='red')
)

# Plot anzeigen
p.show()
```


```{python}
#| message: false
#| warning: false

import numpy as np
import sympy as sp
from lets_plot import *

LetsPlot.setup_html()


# Symbolische Berechnung des Gleichgewichts mit sympy
p = sp.symbols('p')
F_II = p * D + (1 - p) * B
F_I = p * C + (1 - p) * A
equilibrium_eq = sp.Eq(F_II, F_I)
equilibrium_p = sp.solve(equilibrium_eq, p)[0]
print(f"Das Gleichgewicht liegt bei p = {equilibrium_p}")



seeds = list(range(3,7))
plots = []

runde = 0

for seed in seeds:
    # Parameter (Beispielwerte, bitte ggf. anpassen)

    runde= runde+1

    generations = 100
 #   A, B, C, D = 1, 2, 3, 4
    sigma = 0.1
    dt = 0.1
  #  equilibrium_p = 0.5  # Beispielwert

    np.random.seed(seed)
    p_value = 0.5
    p_values = [p_value]
    q_values = [1 - p_value]

    # Simulation
    for _ in range(generations):
        F_II_val = p_value * D + (1 - p_value) * B
        F_I_val = p_value * C + (1 - p_value) * A
        F_avg = p_value * F_II_val + (1 - p_value) * F_I_val
        dp_dt = p_value * (F_II_val - F_avg) + np.random.normal(loc=0, scale=sigma)
        p_value += dp_dt * dt
        p_values.append(p_value)
        q_values.append(1 - p_value)

    # Daten für den Plot vorbereiten
    data = {
        'Generation': list(range(generations + 1)) * 2,
        'Strategien': [item for item in ["Strategie I", "Strategie II"] for _ in range(generations + 1)],
        'Anteile': q_values + p_values
    }

    # Plot erstellen
    p = (
        ggplot(data, aes(x='Generation', y='Anteile', color='Strategien')) +
        geom_line() +
        geom_hline(yintercept=float(equilibrium_p), color='red', linetype='dashed', size=1) +
        ggtitle(f'Runde {runde}') +
        xlab('Generation') +
        ylab('Anteil der Strategien') +
        theme_minimal() #+
    #    geom_text(x=44, y=float(equilibrium_p) + 0.05,
    #              label=f'Gleichgewicht p = {round(equilibrium_p, 2)}', color='red')
    )
    plots.append(p)

# Plots im 2x2-Grid anzeigen
gggrid(plots, ncol=2)
```

#### Anti-Koordinationsspiel

Koordinationsspiele mit asymmetrischen Nash-Gleichgewichten nennt man auch Anti-Koordinationsspiel.

```{python}
#| message: false
#| warning: false

# Python


A= 0
a= 0
B= 1
b= 1
C= 1
c= 1
D= 0
d= 0


from lets_plot import *

LetsPlot.setup_html()

ggplot() + \
geom_text(x=- .5, y= 2   , label=a) +\
geom_text(x=-1.5, y=  .75, label=A) +\
geom_text(x=- .5, y=-1   , label=b) +\
geom_text(x=-1.5, y=-2.25, label=B) +\
geom_text(x= 1.5, y= 2   , label=c) +\
geom_text(x=  .5, y=  .75, label=C) +\
geom_text(x= 1.5, y=-1   , label=d) +\
geom_text(x=  .5, y=-2.25, label=D) +\
geom_text(x=-1  , y= 3.3 , label='I')+\
geom_text(x= 1  , y= 3.3 , label='II')+\
geom_text(x=-2.2, y= 1.375, angle=90, label='I')+\
geom_text(x=-2.2, y=-1.625, angle=90, label='II')+\
geom_text(x= 0 , y= 4 ,
          fontface = "bold", label='Spieler 2')+\
geom_text(x=-2.7 , y= 0 , angle=90,
          fontface = "bold", label='Spieler 1')+\
geom_segment(x=-2,  xend= 2, y= 0, yend= 0) +\
geom_segment(x=-2,  xend= 2, y= 3, yend= 3) +\
geom_segment(x=-2,  xend= 2, y=-3, yend=-3) +\
geom_segment(x=-2,  xend=-2, y=-3, yend= 3) +\
geom_segment(x= 0,  xend= 0, y=-3, yend= 3) +\
geom_segment(x= 2,  xend= 2, y=-3, yend= 3) +\
theme_void()+\
labs(title='Auszahlungen in einem Anti-Koordinationsspiel')
```

```{python}
#| message: false
#| warning: false

#p_l
if (A - B - C + D)!=0: p_l = ( D-C)/(A - B - C + D)

#print(round(p_l, 2))

#p_o
if (-b + d)/(a - b - c + d)!=0: p_o = (-b + d)/(a - b - c + d)

#print(round(p_o, 2))


# Ausgabe Abhängig von Bedingungen

if (#Anzahl_NGG == 1 or
    p_o < 0 or p_l < 0 or
            p_o > 1 or p_l > 1 or
            (a - b - c + d) == 0 or
            (A - B - C + D) == 0):
    print("Kein Nash-Gleichgewicht in gemischten Strategien")
else:   print(f"Gemischte Strategien: p_o= {round(p_o, 2)}, p_l= {round(p_l, 2)}")
```

```{python}
#| message: false
#| warning: false

import sympy as sp
import numpy as np
from lets_plot import *

# Symbolische Berechnung des Gleichgewichts mit sympy
p = sp.symbols('p')
F_II = p * D + (1 - p) * B
F_I = p * C + (1 - p) * A
equilibrium_eq = sp.Eq(F_II, F_I)
equilibrium_p = sp.solve(equilibrium_eq, p)[0]
print(f"Das Gleichgewicht liegt bei p = {equilibrium_p}")

# Parameter für die Simulation
generations = 100
p_value = 0.5  # Startanteil der Strategie II
q_value=1-p_value
dt = 0.1
p_values = [p_value]
q_values = [q_value]

sigma=0


# Simulation
for _ in range(generations):
    F_II_val = p_value * D + (1 - p_value) * B
    F_I_val = p_value * C + (1 - p_value) * A
    F_avg = p_value * F_II_val + (1 - p_value) * F_I_val
    dp_dt = p_value * (F_II_val - F_avg)  + np.random.normal(loc=0, scale=sigma) # noise
    p_value += dp_dt * dt
    p_values.append(p_value)
    q_values.append(1-p_value)

# Daten für den Plot vorbereiten

data = {
    'Generation': list(range(generations + 1))*2,
    'Strategien': [item for item in ["Strategie I","Strategie II"] for _ in range (generations + 1)],
    'Anteile'   : q_values + p_values
}

# print(data)

# Plot mit lets-plot

LetsPlot.setup_html()

p = (ggplot(data, aes(x='Generation', y='Anteile', color='Strategien')) +
     geom_line() +
     geom_hline(yintercept=float(equilibrium_p), color='red', linetype='dashed', size=1) +
     ggtitle('Evolution im Anti-Koordinationsspiel') +
     xlab('Generation') +
     ylab('Anteil der Strategien') +
     theme_minimal() #+
 #    + geom_text(x=11, y=float(equilibrium_p) + 0.05,
 #                label=f'Gleichgewicht p = {round(equilibrium_p, 2)}', color='red')
)

# Plot anzeigen
p.show()
```

```{python}
#| message: false
#| warning: false

import numpy as np
import sympy as sp
from lets_plot import *

LetsPlot.setup_html()


# Symbolische Berechnung des Gleichgewichts mit sympy
p = sp.symbols('p')
F_II = p * D + (1 - p) * B
F_I = p * C + (1 - p) * A
equilibrium_eq = sp.Eq(F_II, F_I)
equilibrium_p = sp.solve(equilibrium_eq, p)[0]
print(f"Das Gleichgewicht liegt bei p = {equilibrium_p}")



seeds = [123, 124, 125, 126]
plots = []

runde = 0

for seed in seeds:
    # Parameter (Beispielwerte, bitte ggf. anpassen)
    runde=runde+1
    generations = 100
 #   A, B, C, D = 1, 2, 3, 4
    sigma = 0.1
    dt = 0.1
  #  equilibrium_p = 0.5  # Beispielwert

    np.random.seed(seed)
    p_value = 0.5
    p_values = [p_value]
    q_values = [1 - p_value]

    # Simulation
    for _ in range(generations):
        F_II_val = p_value * D + (1 - p_value) * B
        F_I_val = p_value * C + (1 - p_value) * A
        F_avg = p_value * F_II_val + (1 - p_value) * F_I_val
        dp_dt = p_value * (F_II_val - F_avg) + np.random.normal(loc=0, scale=sigma)
        p_value += dp_dt * dt
        p_values.append(p_value)
        q_values.append(1 - p_value)

    # Daten für den Plot vorbereiten
    data = {
        'Generation': list(range(generations + 1)) * 2,
        'Strategien': [item for item in ["Strategie I", "Strategie II"] for _ in range(generations + 1)],
        'Anteile': q_values + p_values
    }

    # Plot erstellen
    p = (
        ggplot(data, aes(x='Generation', y='Anteile', color='Strategien')) +
        geom_line() +
        geom_hline(yintercept=float(equilibrium_p), color='red', linetype='dashed', size=1) +
        ggtitle(f'Runde {runde}') +
        xlab('Generation') +
        ylab('Anteil der Strategien') +
        theme_minimal() #+
      #  geom_text(x=11, y=float(equilibrium_p) + 0.05,
      #            label=f'Gleichgewicht p = {round(equilibrium_p, 2)}', color='red')
    )
    plots.append(p)

# Plots im 2x2-Grid anzeigen
gggrid(plots, ncol=2)
```

Der Evolutionsprozess konvergiert immer gegen die Anteile entsprechend des Nash-Gleichgewichts in gemischten Strategien

#### Falke-Tauben-Spiel

```{python}
#| warning: false
#| message: false

# Python


A= 2
a= 2
B= 4
b= 0
C= 0
c= 4
D= -1
d= -1


from lets_plot import *

LetsPlot.setup_html()

ggplot() + \
geom_text(x=- .5, y= 2   , label=a) +\
geom_text(x=-1.5, y=  .75, label=A) +\
geom_text(x=- .5, y=-1   , label=b) +\
geom_text(x=-1.5, y=-2.25, label=B) +\
geom_text(x= 1.5, y= 2   , label=c) +\
geom_text(x=  .5, y=  .75, label=C) +\
geom_text(x= 1.5, y=-1   , label=d) +\
geom_text(x=  .5, y=-2.25, label=D) +\
geom_text(x=-1  , y= 3.3 , label='Taube')+\
geom_text(x= 1  , y= 3.3 , label='Falke')+\
geom_text(x=-2.2, y= 1.375, angle=90, label='Taube')+\
geom_text(x=-2.2, y=-1.625, angle=90, label='Falke')+\
geom_text(x= 0 , y= 4 ,
          fontface = "bold", label='Spieler 2')+\
geom_text(x=-2.7 , y= 0 , angle=90,
          fontface = "bold", label='Spieler 1')+\
geom_segment(x=-2,  xend= 2, y= 0, yend= 0) +\
geom_segment(x=-2,  xend= 2, y= 3, yend= 3) +\
geom_segment(x=-2,  xend= 2, y=-3, yend=-3) +\
geom_segment(x=-2,  xend=-2, y=-3, yend= 3) +\
geom_segment(x= 0,  xend= 0, y=-3, yend= 3) +\
geom_segment(x= 2,  xend= 2, y=-3, yend= 3) +\
theme_void()+\
labs(title='Auszahlungen Tauben und Falken')
```

```{python}
#| warning: false
#| message: false

#p_l
if (A - B - C + D)!=0: p_l = ( D-C)/(A - B - C + D)

#print(round(p_l, 2))

#p_o
if (-b + d)/(a - b - c + d)!=0: p_o = (-b + d)/(a - b - c + d)

#print(round(p_o, 2))


# Ausgabe Abhängig von Bedingungen

if (#Anzahl_NGG == 1 or
    p_o < 0 or p_l < 0 or
            p_o > 1 or p_l > 1 or
            (a - b - c + d) == 0 or
            (A - B - C + D) == 0):
    print("Kein Nash-Gleichgewicht in gemischten Strategien")
else:   print(f"Gemischte Strategien: p_o= {round(p_o, 2)}, p_l= {round(p_l, 2)}")
```

```{python}
#| message: false
#| warning: false

import sympy as sp
from lets_plot import *

# Symbolische Berechnung des Gleichgewichts mit sympy
p = sp.symbols('p')
F_falke = p * D + (1 - p) * B
F_taube = p * C + (1 - p) * A
equilibrium_eq = sp.Eq(F_falke, F_taube)
equilibrium_p = sp.solve(equilibrium_eq, p)[0]
print(f"Das Gleichgewicht liegt bei p = {equilibrium_p}")

# Parameter für die Simulation
generations = 100
p_value = 0.2  # Startanteil der Falken
dt = 0.1
p_values = [p_value]

# Simulation
for _ in range(generations):
    F_falke_val = p_value * D + (1 - p_value) * B
    F_taube_val = p_value * C + (1 - p_value) * A
    F_avg = p_value * F_falke_val + (1 - p_value) * F_taube_val
    dp_dt = p_value * (F_falke_val - F_avg)
    p_value += dp_dt * dt
    p_values.append(p_value)

# Daten für den Plot vorbereiten
data = {
    'Generation': list(range(generations + 1)),
    'Anteil_Falken': p_values
}

# Plot mit lets-plot

LetsPlot.setup_html()

p = (ggplot(data, aes(x='Generation', y='Anteil_Falken')) +
     geom_line(color='blue', size=1, tooltips=layer_tooltips().line('@Anteil_Falken')) +
     geom_hline(yintercept=float(equilibrium_p), color='red', linetype='dashed', size=1) +
     ggtitle('Evolution im Falke-Tauben-Spiel') +
     xlab('Generation') +
     ylab('Anteil der Falken') +
     theme_minimal() #+
    # + geom_text(x=11, y=float(equilibrium_p) + 0.05,
     #            label=f'Gleichgewicht p = {round(equilibrium_p, 2)}', #color='red')
)

# Plot anzeigen
p.show()
```


### Diskussion und Ausblick

- Wofür (evolutionäre) Spieltheorie?

- Nur eine Heuristik?

- Ist das so wenig?


