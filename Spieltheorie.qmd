# Nicht-kooperative Spieltheorie

## Einleitung und begriffliche Einordnung

## Das Nash-Gleichgewicht

## Simultane Spiele

### Grundsätzliche Struktur eines Spiels

![Allgemeines Struktur eines Spiels](figure/Allgemeine-Struktur.png){width="50%"}

### Reine Strategien

#### Definition Nash-Gleichgewicht

Ein Nash-Gleichgewicht liegt vor, wenn jeder Spieler die beste Antwort auf die beste Strategie des Gegenspielers spielt.

Formal:

$u_{i}\left(s_{i}^{*},s_{-i}^{*}\right)\geq u_{i}\left(s_{i},s_{-i}^{*}\right)\mbox{ für alle }i,\mbox{ }s_{i}\in S_{i}$

Intuition: Ein Nash-Gleichgewicht liegt vor, wenn kein Spieler mehr die Möglichkeit hat, seine Situation durch eine **nur eigene** Entscheidungsänderung zu verbessern.

In der Matrix oben heißt dass, das geprüft werden muss

$A \geq B \land a \geq c$ $\rightarrow$ **ol**

$B \geq A \land b \geq d$ $\rightarrow$ **ul**

$C \geq D \land c \geq a$ $\rightarrow$ **or**

$D \geq C \land d \geq b$ $\rightarrow$ **ur**

Es kann kein oder ein Nash-Gleichgewicht existieren oder mehrere Nash-Gleichgewichte

#### Einperiodige Spiele

```{python}

import numpy as np

import random

# Zufällige Ganzzahlen zwischen 0 und 9 generieren
A = random.randint(0, 9)
B = random.randint(0, 9)
C = random.randint(0, 9)
D = random.randint(0, 9)
a = random.randint(0, 9)
b = random.randint(0, 9)
c = random.randint(0, 9)
d = random.randint(0, 9)

# Formatierte Bimatrix ausgeben
print("    l   r")
print(f"o  {A},{a}  {C},{c}")
print(f"u  {B},{b}  {D},{d}")


# Funktionen für Nash-Bedingungen
def is_ol_nash(A, B, a, c):
  return "ol" if (A >= B) and (a >= c) else "not_ol"

def is_ul_nash(B, A, b, d):
  return "ul" if (B >= A) and (b >= d) else "not_ul"

def is_or_nash(C, D, c, a):
  return "or" if (C >= D) and (c >= a) else "not_or"

def is_ur_nash(D, C, d, b):
  return "ur" if (D >= C) and (d >= b) else "not_ur"

# Nash-Bedingungen überprüfen und Strings zuweisen
Cand_Nash_ol = is_ol_nash(A, B, a, c)
Cand_Nash_ul = is_ul_nash(B, A, b, d)
Cand_Nash_or = is_or_nash(C, D, c, a)
Cand_Nash_ur = is_ur_nash(D, C, d, b)

# Ergebnisse kombinieren und NAs entfernen
Nash_GG = np.array([Cand_Nash_ol, Cand_Nash_ul, Cand_Nash_or, Cand_Nash_ur])
Nash_GG_filtered = []
for element in Nash_GG:
  if element == "ol" or element == "ul" or element == "or" or element == "ur":
    Nash_GG_filtered.append(element)

# Ergebnis ausgeben
#print(Nash_GG_filtered)

```

```{python}
print(Nash_GG_filtered)
```

##### Koordinationsspiel

![Koordinationsspiel](figure/Koordinationsspiel-1.png){width="50%"}

```{python}

import numpy as np

import random

# Zufällige Ganzzahlen zwischen 0 und 9 generieren
A = 0
B = random.randint(1, 9)
C = B
D = A
a = A
b = B
c = C
d = D

# Formatierte Bimatrix ausgeben
print("    l   r")
print(f"o  {A},{a}  {C},{c}")
print(f"u  {B},{b}  {D},{d}")


# Funktionen für Nash-Bedingungen
def is_ol_nash(A, B, a, c):
  return "ol" if (A >= B) and (a >= c) else "not_ol"

def is_ul_nash(B, A, b, d):
  return "ul" if (B >= A) and (b >= d) else "not_ul"

def is_or_nash(C, D, c, a):
  return "or" if (C >= D) and (c >= a) else "not_or"

def is_ur_nash(D, C, d, b):
  return "ur" if (D >= C) and (d >= b) else "not_ur"

# Nash-Bedingungen überprüfen und Strings zuweisen
Cand_Nash_ol = is_ol_nash(A, B, a, c)
Cand_Nash_ul = is_ul_nash(B, A, b, d)
Cand_Nash_or = is_or_nash(C, D, c, a)
Cand_Nash_ur = is_ur_nash(D, C, d, b)

# Ergebnisse kombinieren und NAs entfernen
Nash_GG = np.array([Cand_Nash_ol, Cand_Nash_ul, Cand_Nash_or, Cand_Nash_ur])
Nash_GG_filtered = []
for element in Nash_GG:
  if element == "ol" or element == "ul" or element == "or" or element == "ur":
    Nash_GG_filtered.append(element)

# Ergebnis ausgeben
print(Nash_GG_filtered)
```

##### Chicken Game

![Chicken Game](figure/Chicken-Game-1.png){width="50%"}

```{python}

import numpy as np

import random

# Zufällige Ganzzahlen zwischen 0 und 9 generieren
A = random.randint(5, 7)
B = random.randint(8, 9)
C = random.randint(2, 4)
D = random.randint(0, 1)
a = random.randint(5, 7)
b = random.randint(2, 4)
c = random.randint(8, 9)
d = random.randint(0, 1)

# Formatierte Bimatrix ausgeben
print("    l   r")
print(f"o  {A},{a}  {C},{c}")
print(f"u  {B},{b}  {D},{d}")


# Funktionen für Nash-Bedingungen
def is_ol_nash(A, B, a, c):
  return "ol" if (A >= B) and (a >= c) else "not_ol"

def is_ul_nash(B, A, b, d):
  return "ul" if (B >= A) and (b >= d) else "not_ul"

def is_or_nash(C, D, c, a):
  return "or" if (C >= D) and (c >= a) else "not_or"

def is_ur_nash(D, C, d, b):
  return "ur" if (D >= C) and (d >= b) else "not_ur"

# Nash-Bedingungen überprüfen und Strings zuweisen
Cand_Nash_ol = is_ol_nash(A, B, a, c)
Cand_Nash_ul = is_ul_nash(B, A, b, d)
Cand_Nash_or = is_or_nash(C, D, c, a)
Cand_Nash_ur = is_ur_nash(D, C, d, b)

# Ergebnisse kombinieren und NAs entfernen
Nash_GG = np.array([Cand_Nash_ol, Cand_Nash_ul, Cand_Nash_or, Cand_Nash_ur])
Nash_GG_filtered = []
for element in Nash_GG:
  if element == "ol" or element == "ul" or element == "or" or element == "ur":
    Nash_GG_filtered.append(element)

# Ergebnis ausgeben
print(Nash_GG_filtered)

```

##### Geschlechterkampf

![Geschlechterkampf](figure/Geschlechterkampf-1.png){width="50%"}

```{python}

import numpy as np

import random

# Zufällige Ganzzahlen zwischen 0 und 9 generieren
A = random.randint(8, 9)
B = random.randint(0, 2)
C = random.randint(3, 5)
D = random.randint(6, 7)
a = random.randint(6, 7)
b = random.randint(0, 2)
c = random.randint(3, 5)
d = random.randint(8, 9)

# Formatierte Bimatrix ausgeben
print("    l   r")
print(f"o  {A},{a}  {C},{c}")
print(f"u  {B},{b}  {D},{d}")


# Funktionen für Nash-Bedingungen
def is_ol_nash(A, B, a, c):
  return "ol" if (A >= B) and (a >= c) else "not_ol"

def is_ul_nash(B, A, b, d):
  return "ul" if (B >= A) and (b >= d) else "not_ul"

def is_or_nash(C, D, c, a):
  return "or" if (C >= D) and (c >= a) else "not_or"

def is_ur_nash(D, C, d, b):
  return "ur" if (D >= C) and (d >= b) else "not_ur"

# Nash-Bedingungen überprüfen und Strings zuweisen
Cand_Nash_ol = is_ol_nash(A, B, a, c)
Cand_Nash_ul = is_ul_nash(B, A, b, d)
Cand_Nash_or = is_or_nash(C, D, c, a)
Cand_Nash_ur = is_ur_nash(D, C, d, b)

# Ergebnisse kombinieren und NAs entfernen
Nash_GG = np.array([Cand_Nash_ol, Cand_Nash_ul, Cand_Nash_or, Cand_Nash_ur])
Nash_GG_filtered = []
for element in Nash_GG:
  if element == "ol" or element == "ul" or element == "or" or element == "ur":
    Nash_GG_filtered.append(element)

# Ergebnis ausgeben
print(Nash_GG_filtered)

```

##### Gefangenendilemma

![Gefangenendilemma](figure/Gefangenendilemma-1.png){width="50%"}

```{python}


import numpy as np

import random

# Zufällige Ganzzahlen zwischen 0 und 9 generieren
A = random.randint(5, 7)
B = random.randint(8, 9)
C = random.randint(0, 1)
D = random.randint(2, 4)
a = random.randint(5, 8)
b = random.randint(0, 1)
c = random.randint(8, 9)
d = random.randint(2, 4)

# Formatierte Bimatrix ausgeben
print("    l   r")
print(f"o  {A},{a}  {C},{c}")
print(f"u  {B},{b}  {D},{d}")


# Funktionen für Nash-Bedingungen
def is_ol_nash(A, B, a, c):
  return "ol" if (A >= B) and (a >= c) else "not_ol"

def is_ul_nash(B, A, b, d):
  return "ul" if (B >= A) and (b >= d) else "not_ul"

def is_or_nash(C, D, c, a):
  return "or" if (C >= D) and (c >= a) else "not_or"

def is_ur_nash(D, C, d, b):
  return "ur" if (D >= C) and (d >= b) else "not_ur"

# Nash-Bedingungen überprüfen und Strings zuweisen
Cand_Nash_ol = is_ol_nash(A, B, a, c)
Cand_Nash_ul = is_ul_nash(B, A, b, d)
Cand_Nash_or = is_or_nash(C, D, c, a)
Cand_Nash_ur = is_ur_nash(D, C, d, b)

# Ergebnisse kombinieren und NAs entfernen
Nash_GG = np.array([Cand_Nash_ol, Cand_Nash_ul, Cand_Nash_or, Cand_Nash_ur])
Nash_GG_filtered = []
for element in Nash_GG:
  if element == "ol" or element == "ul" or element == "or" or element == "ur":
    Nash_GG_filtered.append(element)

# Ergebnis ausgeben
print(Nash_GG_filtered)
```

#### Wiederholte Spiele

-   Ausgangspunkt Gefangenendilemma mit $B>A>D>C$ und $c>a>d>b$

-   Erwartungswert der Kooperation für Spieler 1: $E^1_k\approx \frac{A}{1-p}$

-   Erwartungswert der Nicht-Kooperation für Spieler 1: $E^1_{nk}\approx B+ \frac{D}{1-p}-D$

-   Erwartungswert der Kooperation für Spieler 2: $E^2_k\approx \frac{a}{1-p}$

-   Erwartungswert der Nicht-Kooperation für Spieler 2: $E^2_{nk}\approx c+ \frac{d}{1-p}-d$

-   Kooperation durch Spieler 1 wenn $p\geq \frac{B-A}{B-D}$

-   Kooperation durch Spieler 2 wenn $p\geq \frac{c-a}{c-d}$

#### Trembling Hand

-   Idee: Manche Nash-Gleichgewichte sind riskant

-   Wenn der Gegenspieler "versehentlich" eine falsche Strategie spielt, dann macht man evtl hohe Verluste

-   Wie hoch darf die Fehlerwahrscheinlichkeit des Gegenspielers sein, damit das Nash-Gleichgewicht noch die richtige Strategie impliziert?

Angenommen, beide Spieler streben ein Nash-Gleichgewicht oben links an

**Für Spieler 1 muss dann gelten**

$E_o\geq E_u$

Wenn er davon ausgeht, dass Spieler 2 mit einer Wahrscheinlichkeit von $p$ versehentlich rechts statt links spielt, heißt das

$(1-p)A+pC \geq (1-p)B+pD$

$\iff A-pA+pC\geq B-pB+pD$

$\iff A-p(A-C) \geq B-p(B-D)$

$\iff p(B-D)-p(A-C) \geq B-A$

$\iff p(B-D-A+C)\geq B-A$

mit $(B-D-A+C) <0$

$\iff p \leq \frac{B-A}{B-A-D+C}=\frac{A-B}{A-B-C+D}$

**Für Spieler 2 muss dann gelten**

$E_l\geq E_r$

$(1-p)a+pb \geq (1-p)c+pd$

$\iff a-pa+pb \geq c-pc+pd$

$\iff a-p(a-b) \geq c-p(c-d)$

$\iff p(c-d)-p(a-b) \geq c-a$

$\iff p(c-d-a+b) \geq c-a$

mit $(c-d-a+b)\neq 0$

$p \leq \frac{c-a}{(c-d-a+b)}=\frac{a-c}{(a-b-c+d)}$

```{python}
#| echo: true
#| eval: false

# Wahrscheinlichkeiten ausrechnen

from sympy import Symbol, solve, Eq

symbols = [Symbol(name) for name in 'ABCDabcdp']
A, B, C, D, a, b, c, d, p = symbols  # Entpacken und als separate Variablen speichern

# Beide streben ol an

E_o= (1-p)*A+p*C

E_u= (1-p)*B + p*D

sol = solve(Eq(E_o, E_u), p)
print(sol)

E_l = (1-p)*a + p*b
E_r = (1-p)*c + p*d

sol = solve(Eq(E_l, E_r),p)
print(sol)

```

### Gemischte Strategien

-   Es könnte sinnvoll sein, zufällig zu spielen, um nicht vorhersehbar zu sein

-   Gesucht sind die Wahrscheinlichkeiten, bei denen der Gegenspieler indifferent ist in der Wahl seiner Handlungsmöglichkeiten (also seine Lage durch cleveres Spielen nicht verbessern kann)

```{python}
#| eval: false

# Wahrscheinlichkeiten ausrechnen

from sympy import Symbol, solve, Eq

symbols = [Symbol(name) for name in 'ABCDabcdp']
A, B, C, D, a, b, c, d, p = symbols  # Auspacken in verschiedene Variablen


#p_l
E_o= p*A+(1-p)*C

E_u= p*B  + (1-p)*D

sol = solve(Eq(E_o, E_u), p)
print(sol)

#p_o

E_l = p*a + (1-p)*b
E_r = p*c + (1-p)*d

sol = solve(Eq(E_l, E_r),p)
print(sol)
```

```{python}
#| eval: false

import numpy as np
import random

# Zufällige Ganzzahlen zwischen 0 und 9 generieren
A = random.randint(0, 9)
B = random.randint(0, 9)
C = random.randint(0, 9)
D = random.randint(0, 9)
a = random.randint(0, 9)
b = random.randint(0, 9)
c = random.randint(0, 9)
d = random.randint(0, 9)

# Formatierte Bimatrix ausgeben
print("    l   r")
print(f"o  {A},{a}  {C},{c}")
print(f"u  {B},{b}  {D},{d}")


# Funktionen für Nash-Bedingungen
def is_ol_nash(A, B, a, c):
  return "ol" if (A >= B) and (a >= c) else "not_ol"

def is_ul_nash(B, A, b, d):
  return "ul" if (B >= A) and (b >= d) else "not_ul"

def is_or_nash(C, D, c, a):
  return "or" if (C >= D) and (c >= a) else "not_or"

def is_ur_nash(D, C, d, b):
  return "ur" if (D >= C) and (d >= b) else "not_ur"

# Nash-Bedingungen überprüfen und Strings zuweisen
Cand_Nash_ol = is_ol_nash(A, B, a, c)
Cand_Nash_ul = is_ul_nash(B, A, b, d)
Cand_Nash_or = is_or_nash(C, D, c, a)
Cand_Nash_ur = is_ur_nash(D, C, d, b)

# Ergebnisse kombinieren und NAs entfernen
Nash_GG = np.array([Cand_Nash_ol, Cand_Nash_ul, Cand_Nash_or, Cand_Nash_ur])
Nash_GG_filtered = []
for element in Nash_GG:
  if element == "ol" or element == "ul" or element == "or" or element == "ur":
    Nash_GG_filtered.append(element)

# Ergebnis ausgeben
print(Nash_GG_filtered)


# Anzahl der Nash GG

#Anzahl_NGG=len(Nash_GG_filtered)
#print(Anzahl_NGG)

# Wahrscheinlichkeiten ausrechnen.
# Dabei jeweils den Fall Division duch 0 aussschließen

#p_l
if (A - B - C + D)!=0: p_l = ( D-C)/(A - B - C + D)

#print(round(p_l, 2))

#p_o
if (-b + d)/(a - b - c + d)!=0: p_o = (-b + d)/(a - b - c + d)

#print(round(p_o, 2))


# Ausgabe Abhängig von Bedingungen

if (#Anzahl_NGG == 1 or 
    p_o < 0 or p_l < 0 or
            p_o > 1 or p_l > 1 or
            (a - b - c + d) == 0 or
            (A - B - C + D) == 0): print("Kein Nash-Gleichgewicht in gemischten Strategien")
else:   print(f"p_l= {round(p_l, 2)}, p_o= {(round(p_o, 2))}")
```

## Sequenzielle Spiele

Spieler spielen nacheinander.

### Vollständige Information

Annahme: Alle Spieler kennen alle Auszahlungen und sehen alle bislang erfolgten Spielzüge

Darstellung des Spiels mittels eines Spielbaums

![Grundstruktur eines Spielbaums](figure/Baum-Grundstruktur-1.png){width="50%"}

#### Rückwärtsinduktion

Lösen des Spiels "von hinten nach vorn"

##### Beispiele

![Beispiel für Rückwärtsinduktion](figure/Baum-Rückwärtsinduktion-a-1.png){width="50%"}


![Beispiel für Rückwärtsinduktion](figure/Baum-Rückwärtsinduktion-b-1.png){width="50%"}

##### Bedingungen für ein Nash-Gleichgewicht

Zunächst vereinfachende Annahme: $a\neq c\ \text{und}\ b \neq d$

Ja, was sind die Bedingungen?

**ol**: $a>c \land ((A>B\ \land\ b>d) \lor (A>D\ \land\ d>b))$
**or**: $c>a \land ((C>B\ \land\ b>d) \lor (C>D\ \land\ d>b))$
**ul**: $b>d \land ((B>A\ \land\ a>c) \lor (B>C\ \land\ c>a))$
**ur**: $d>b \land ((D>A\ \land\ a>c) \lor (D>C\ \land\ c>a))$

Hier: Implementierung in Python

#### Teilspielperfektheit

-   Teilspielperfektheit verlangt, dass jeder Spieler jeden Zug so ausführt, dass das Ergebnis des Zuges seinen Interessen nicht schadet.

-   Ein Teilspiel beginnt in einem Knoten und enthält alle nachfolgenden Knoten

-   Für später: Ein Teilspiel darf nachfolgende Informationsmengen nicht teilen. Es gehören also immer alle Knoten einer Informationsmenge zu einem Teilspiel

Beispiel: Unglaubwürdige Drohung

![Unglaubwürdige Drohung](figure/Baum-Unglaubwürdige-Drohung-1.png){width="50%"}

#### Selbstbindung

### Unvollständige Information

## Koalitionsspiele

## Evolutionäre Spiele
