# Nicht-kooperative Spieltheorie

## Einleitung und begriffliche Einordnung

## Simultane Spiele

### Grundsätzliche Struktur eines Spiels

[![Allgemeines Struktur eines Spiels](figure/Allgemeine-Struktur.png){width="50%"}]::

```{python}
#| message: false
#| warning: false

from lets_plot import *

LetsPlot.setup_html()

ggplot() + \
geom_text(x=- .5, y= 2   , label='a') +\
geom_text(x=-1.5, y=  .75, label='A') +\
geom_text(x=- .5, y=-1   , label='b') +\
geom_text(x=-1.5, y=-2.25, label='B') +\
geom_text(x= 1.5, y= 2   , label='c') +\
geom_text(x=  .5, y=  .75, label='C') +\
geom_text(x= 1.5, y=-1   , label='d') +\
geom_text(x=  .5, y=-2.25, label='D') +\
geom_text(x=-1  , y= 3.3 , label='links')+\
geom_text(x= 1  , y= 3.3 , label='rechts')+\
geom_text(x=-2.2, y= 1.375, angle=90, label='oben')+\
geom_text(x=-2.2, y=-1.625, angle=90, label='unten')+\
geom_text(x= 0 , y= 4 ,
          fontface = "bold", label='Spieler 2')+\
geom_text(x=-2.7 , y= 0 , angle=90,
          fontface = "bold", label='Spieler 1')+\
geom_segment(x=-2,  xend= 2, y= 0, yend= 0) +\
geom_segment(x=-2,  xend= 2, y= 3, yend= 3) +\
geom_segment(x=-2,  xend= 2, y=-3, yend=-3) +\
geom_segment(x=-2,  xend=-2, y=-3, yend= 3) +\
geom_segment(x= 0,  xend= 0, y=-3, yend= 3) +\
geom_segment(x= 2,  xend= 2, y=-3, yend= 3) +\
theme_void()+\
labs(title='Auszahlungen in einem simultanen Spiel' #,
    # caption = 'Caption'
)

```

### Reine Strategien

#### Definition Nash-Gleichgewicht

Ein Nash-Gleichgewicht liegt vor, wenn jeder Spieler die beste Antwort auf die beste Strategie des Gegenspielers spielt.

Formal:

$u_{i}\left(s_{i}^{*},s_{-i}^{*}\right)\geq u_{i}\left(s_{i},s_{-i}^{*}\right)\mbox{ für alle }i,\mbox{ }s_{i}\in S_{i}$

Intuition: Ein Nash-Gleichgewicht liegt vor, wenn kein Spieler mehr die Möglichkeit hat, seine Situation durch eine **nur eigene** Entscheidungsänderung zu verbessern.

In der Matrix oben heißt dass, das geprüft werden muss

$A \geq B \land a \geq c$ $\rightarrow$ **ol**

$B \geq A \land b \geq d$ $\rightarrow$ **ul**

$C \geq D \land c \geq a$ $\rightarrow$ **or**

$D \geq C \land d \geq b$ $\rightarrow$ **ur**

Es kann kein oder ein Nash-Gleichgewicht existieren oder mehrere Nash-Gleichgewichte

#### Einperiodige Spiele

```{python}

import numpy as np

import random

# Zufällige Ganzzahlen zwischen 0 und 9 generieren

random.seed(123)

A = random.randint(0, 9)
B = random.randint(0, 9)
C = random.randint(0, 9)
D = random.randint(0, 9)
a = random.randint(0, 9)
b = random.randint(0, 9)
c = random.randint(0, 9)
d = random.randint(0, 9)

# Formatierte Bimatrix ausgeben
# print(f"     l    r\n o  {A},{a}  {C},{c}\n # u  {B},{b}  {D},{d}")

from lets_plot import *

LetsPlot.setup_html()

ggplot() + \
geom_text(x=- .5, y= 2   , label=a) +\
geom_text(x=-1.5, y=  .75, label=A) +\
geom_text(x=- .5, y=-1   , label=b) +\
geom_text(x=-1.5, y=-2.25, label=B) +\
geom_text(x= 1.5, y= 2   , label=c) +\
geom_text(x=  .5, y=  .75, label=C) +\
geom_text(x= 1.5, y=-1   , label=d) +\
geom_text(x=  .5, y=-2.25, label=D) +\
geom_text(x=-1  , y= 3.3 , label='links')+\
geom_text(x= 1  , y= 3.3 , label='rechts')+\
geom_text(x=-2.2, y= 1.375, angle=90, label='oben')+\
geom_text(x=-2.2, y=-1.625, angle=90, label='unten')+\
geom_text(x= 0 , y= 4 ,
          fontface = "bold", label='Spieler 2')+\
geom_text(x=-2.7 , y= 0 , angle=90,
          fontface = "bold", label='SPieler 1')+\
geom_segment(x=-2,  xend= 2, y= 0, yend= 0) +\
geom_segment(x=-2,  xend= 2, y= 3, yend= 3) +\
geom_segment(x=-2,  xend= 2, y=-3, yend=-3) +\
geom_segment(x=-2,  xend=-2, y=-3, yend= 3) +\
geom_segment(x= 0,  xend= 0, y=-3, yend= 3) +\
geom_segment(x= 2,  xend= 2, y=-3, yend= 3) +\
theme_void()+\
labs(title='Auszahlungen in einem simultanen Spiel')



# Funktionen für Nash-Bedingungen
def is_ol_nash(A, B, a, c):
  return "ol" if (A >= B) and (a >= c) else "not_ol"

def is_ul_nash(B, A, b, d):
  return "ul" if (B >= A) and (b >= d) else "not_ul"

def is_or_nash(C, D, c, a):
  return "or" if (C >= D) and (c >= a) else "not_or"

def is_ur_nash(D, C, d, b):
  return "ur" if (D >= C) and (d >= b) else "not_ur"

# Nash-Bedingungen überprüfen und Strings zuweisen
Cand_Nash_ol = is_ol_nash(A, B, a, c)
Cand_Nash_ul = is_ul_nash(B, A, b, d)
Cand_Nash_or = is_or_nash(C, D, c, a)
Cand_Nash_ur = is_ur_nash(D, C, d, b)

# Ergebnisse kombinieren und NAs entfernen
Nash_GG = np.array([Cand_Nash_ol, Cand_Nash_ul, Cand_Nash_or, Cand_Nash_ur])
Nash_GG_filtered = []
for element in Nash_GG:
  if element == "ol" or element == "ul" or element == "or" or element == "ur":
    Nash_GG_filtered.append(element)

# Ergebnis ausgeben
#print(Nash_GG_filtered)

```

```{python}
print(Nash_GG_filtered)
```

##### Koordinationsspiel

[![Koordinationsspiel](figure/Koordinationsspiel-1.png){width="50%"}]::

```{python}

import numpy as np

import random

random.seed(123)

# Zufällige Ganzzahlen zwischen 0 und 9 generieren
A = 0
B = random.randint(1, 9)
C = B
D = A
a = A
b = B
c = C
d = D

# Formatierte Bimatrix ausgeben
#print(f"     l    r\n o  #{A},{a}  {C},{c}\n u  {B},{b} # {D},{d}")


def create_plot():
    LetsPlot.setup_html()
    return (
        ggplot() +
        geom_text(x=-0.5, y=2, label=a) +
        geom_text(x=-1.5, y=0.75, label=A) +
        geom_text(x=-0.5, y=-1, label=b) +
        geom_text(x=-1.5, y=-2.25, label=B) +
        geom_text(x=1.5, y=2, label=c) +
        geom_text(x=0.5, y=0.75, label=C) +
        geom_text(x=1.5, y=-1, label=d) +
        geom_text(x=0.5, y=-2.25, label=D) +
        geom_text(x=-1, y=3.3, label='links') +
        geom_text(x=1, y=3.3, label='rechts') +
        geom_text(x=-2.2, y=1.375, angle=90, label='oben') +
        geom_text(x=-2.2, y=-1.625, angle=90, label='unten') +
        geom_text(x=0 , y=4 , fontface="bold", label='Spieler 2') +
        geom_text(x=-2.7 , y=0 , angle=90 , fontface="bold", label='Spieler 1') +
        geom_segment(x=-2, xend=2, y=0, yend=0) +
        geom_segment(x=-2, xend=2, y=3, yend=3) +
        geom_segment(x=-2, xend=2, y=-3, yend=-3) +
        geom_segment(x=-2, xend=-2, y=-3, yend=3) +
        geom_segment(x=0 , xend=0 , y=-3 , yend=3) +
        geom_segment(x=2 , xend=2 , y=-3 , yend=3) +
        theme_void() +
        labs(title='Auszahlungen in einem simultanen Spiel')
    )

    
plot = create_plot()

plot


# Funktionen für Nash-Bedingungen
def is_ol_nash(A, B, a, c):
  return "ol" if (A >= B) and (a >= c) else "not_ol"

def is_ul_nash(B, A, b, d):
  return "ul" if (B >= A) and (b >= d) else "not_ul"

def is_or_nash(C, D, c, a):
  return "or" if (C >= D) and (c >= a) else "not_or"

def is_ur_nash(D, C, d, b):
  return "ur" if (D >= C) and (d >= b) else "not_ur"

# Nash-Bedingungen überprüfen und Strings zuweisen
Cand_Nash_ol = is_ol_nash(A, B, a, c)
Cand_Nash_ul = is_ul_nash(B, A, b, d)
Cand_Nash_or = is_or_nash(C, D, c, a)
Cand_Nash_ur = is_ur_nash(D, C, d, b)

# Ergebnisse kombinieren und NAs entfernen
Nash_GG = np.array([Cand_Nash_ol, Cand_Nash_ul, Cand_Nash_or, Cand_Nash_ur])
Nash_GG_filtered = []
for element in Nash_GG:
  if element == "ol" or element == "ul" or element == "or" or element == "ur":
    Nash_GG_filtered.append(element)

# Ergebnis ausgeben
print(Nash_GG_filtered)
```

##### Chicken Game

[![Chicken Game](figure/Chicken-Game-1.png){width="50%"}]::

```{python}

import numpy as np

import random

# Zufällige Ganzzahlen zwischen 0 und 9 generieren
A = random.randint(5, 7)
B = random.randint(8, 9)
C = random.randint(2, 4)
D = random.randint(0, 1)
a = random.randint(5, 7)
b = random.randint(2, 4)
c = random.randint(8, 9)
d = random.randint(0, 1)

# Formatierte Bimatrix ausgeben
# print(f"     l    r\n o  {A},{a}  {C},{c}\n u  {B},{b}  {D},{d}")

plot = create_plot()

plot


# Funktionen für Nash-Bedingungen
def is_ol_nash(A, B, a, c):
  return "ol" if (A >= B) and (a >= c) else "not_ol"

def is_ul_nash(B, A, b, d):
  return "ul" if (B >= A) and (b >= d) else "not_ul"

def is_or_nash(C, D, c, a):
  return "or" if (C >= D) and (c >= a) else "not_or"

def is_ur_nash(D, C, d, b):
  return "ur" if (D >= C) and (d >= b) else "not_ur"

# Nash-Bedingungen überprüfen und Strings zuweisen
Cand_Nash_ol = is_ol_nash(A, B, a, c)
Cand_Nash_ul = is_ul_nash(B, A, b, d)
Cand_Nash_or = is_or_nash(C, D, c, a)
Cand_Nash_ur = is_ur_nash(D, C, d, b)

# Ergebnisse kombinieren und NAs entfernen
Nash_GG = np.array([Cand_Nash_ol, Cand_Nash_ul, Cand_Nash_or, Cand_Nash_ur])
Nash_GG_filtered = []
for element in Nash_GG:
  if element == "ol" or element == "ul" or element == "or" or element == "ur":
    Nash_GG_filtered.append(element)

# Ergebnis ausgeben
print(Nash_GG_filtered)

```

##### Geschlechterkampf

[![Geschlechterkampf](figure/Geschlechterkampf-1.png){width="50%"}]::

```{python}

import numpy as np

import random

# Zufällige Ganzzahlen zwischen 0 und 9 generieren
A = random.randint(8, 9)
B = random.randint(0, 2)
C = random.randint(3, 5)
D = random.randint(6, 7)
a = random.randint(6, 7)
b = random.randint(0, 2)
c = random.randint(3, 5)
d = random.randint(8, 9)

# Formatierte Bimatrix ausgeben
# print(f"     l    r\n o  {A},{a}  {C},{c}\n u  {B},{b}  {D},{d}")

plot = create_plot()

plot

# Funktionen für Nash-Bedingungen
def is_ol_nash(A, B, a, c):
  return "ol" if (A >= B) and (a >= c) else "not_ol"

def is_ul_nash(B, A, b, d):
  return "ul" if (B >= A) and (b >= d) else "not_ul"

def is_or_nash(C, D, c, a):
  return "or" if (C >= D) and (c >= a) else "not_or"

def is_ur_nash(D, C, d, b):
  return "ur" if (D >= C) and (d >= b) else "not_ur"

# Nash-Bedingungen überprüfen und Strings zuweisen
Cand_Nash_ol = is_ol_nash(A, B, a, c)
Cand_Nash_ul = is_ul_nash(B, A, b, d)
Cand_Nash_or = is_or_nash(C, D, c, a)
Cand_Nash_ur = is_ur_nash(D, C, d, b)

# Ergebnisse kombinieren und NAs entfernen
Nash_GG = np.array([Cand_Nash_ol, Cand_Nash_ul, Cand_Nash_or, Cand_Nash_ur])
Nash_GG_filtered = []
for element in Nash_GG:
  if element == "ol" or element == "ul" or element == "or" or element == "ur":
    Nash_GG_filtered.append(element)

# Ergebnis ausgeben
print(Nash_GG_filtered)

```

##### Gefangenendilemma

[![Gefangenendilemma](figure/Gefangenendilemma-1.png){width="50%"}]::

```{python}


import numpy as np

import random

# Zufällige Ganzzahlen zwischen 0 und 9 generieren
A = random.randint(5, 7)
B = random.randint(8, 9)
C = random.randint(0, 1)
D = random.randint(2, 4)
a = random.randint(5, 7)
b = random.randint(0, 1)
c = random.randint(8, 9)
d = random.randint(2, 4)

# Formatierte Bimatrix ausgeben
# print(f"     l    r\n o  {A},{a}  {C},{c}\n u  {B},{b}  {D},{d}")

plot = create_plot()

plot

# Funktionen für Nash-Bedingungen
def is_ol_nash(A, B, a, c):
  return "ol" if (A >= B) and (a >= c) else "not_ol"

def is_ul_nash(B, A, b, d):
  return "ul" if (B >= A) and (b >= d) else "not_ul"

def is_or_nash(C, D, c, a):
  return "or" if (C >= D) and (c >= a) else "not_or"

def is_ur_nash(D, C, d, b):
  return "ur" if (D >= C) and (d >= b) else "not_ur"

# Nash-Bedingungen überprüfen und Strings zuweisen
Cand_Nash_ol = is_ol_nash(A, B, a, c)
Cand_Nash_ul = is_ul_nash(B, A, b, d)
Cand_Nash_or = is_or_nash(C, D, c, a)
Cand_Nash_ur = is_ur_nash(D, C, d, b)

# Ergebnisse kombinieren und NAs entfernen
Nash_GG = np.array([Cand_Nash_ol, Cand_Nash_ul, Cand_Nash_or, Cand_Nash_ur])
Nash_GG_filtered = []
for element in Nash_GG:
  if element == "ol" or element == "ul" or element == "or" or element == "ur":
    Nash_GG_filtered.append(element)

# Ergebnis ausgeben
print(Nash_GG_filtered)
```

##### Spiel ohne Gleichgewicht

```{python}

import numpy as np
import random

while True:
    A = random.randint(0, 9)
    a = random.randint(0, 9)
    B = random.randint(0, 9)
    b = random.randint(0, 9)
    C = random.randint(0, 9)
    c = random.randint(0, 9)
    D = random.randint(0, 9)
    d = random.randint(0, 9)

    # Bedingungen prüfen
    cond1 = (A >= B) and (a >= c)
    cond2 = (B >= A) and (b >= d)
    cond3 = (C >= D) and (c >= a)
    cond4 = (D >= C) and (d >= b)

    # Wenn keine Bedingung erfüllt ist, Schleife beenden
    if not (cond1 or cond2 or cond3 or cond4):
        break

plot = create_plot()

plot

# Nash-Bedingungen überprüfen und Strings zuweisen
Cand_Nash_ol = is_ol_nash(A, B, a, c)
Cand_Nash_ul = is_ul_nash(B, A, b, d)
Cand_Nash_or = is_or_nash(C, D, c, a)
Cand_Nash_ur = is_ur_nash(D, C, d, b)

# Ergebnisse kombinieren und NAs entfernen
Nash_GG = np.array([Cand_Nash_ol, Cand_Nash_ul, Cand_Nash_or, Cand_Nash_ur])
Nash_GG_filtered = []
for element in Nash_GG:
  if element == "ol" or element == "ul" or element == "or" or element == "ur":
    Nash_GG_filtered.append(element)

# Ergebnis ausgeben
print(Nash_GG_filtered)
```


#### Wiederholte Spiele

-   Ausgangspunkt Gefangenendilemma mit $B>A>D>C$ und $c>a>d>b$

- Nash-Gleichgewicht dann unten rechts mit der Auszahlung D, d

- Effizient wäre oben links mit Ausuahlung A, a

- Tit for Tat: Kooperiere in der ersten Runde, erwidere danach die Strategiewahl des Gegenspielers reziprok

- Dadurch "Bestrafung" für unkooperatives Verhalten möglich

- Funktioniert das immer?

- Funktioniert nicht bei bekannter endlicher Anzahl von Runden

- In jeder Runde wird mit der Wahrscheinlichkeit $p$ eine weitere Runde gespielt.

- Erwartungswert der Kooperationsgeflecht für $T$ Perioden (die Annahme einer endlichen Anzahl von Perioden wird gleich wieder aufgegeben)

  $E^1_k=\sum_{t=0}^T A \times p^t$

  Hilfsüberlegung: $(1-p)E^1_k = (1-p)\sum_{t=0}^T A \times p^t=A(\sum_{t=0}^T p^t - \sum_{t=0}^T p^{t+1})$
  
$=A(\sum_{t=0}^T p^t - \sum_{t=1}^{T+1}p^{t})$

$= A(1-p^{T+1})$

$\iff E^1_k=\frac{A(1-p^{T+1})}{1-p}$

  $$\boxed{\lim_{T \to \infty}{E^1_k}=\frac{A}{1-p}}$$

-   Erwartungswert der Nicht-Kooperation für Spieler 1: $E^1_{nk}= B+ \frac{D}{1-p}-D$

-   Erwartungswert der Kooperation für Spieler 2: $E^2_k= \frac{a}{1-p}$

-   Erwartungswert der Nicht-Kooperation für Spieler 2: $E^2_{nk}= c+ \frac{d}{1-p}-d$

-   Kooperation durch Spieler 1 wenn $p\geq \frac{B-A}{B-D}$

-   Kooperation durch Spieler 2 wenn $p\geq \frac{c-a}{c-d}$


```{python}
#| eval: false


from sympy import Symbol, solve, Eq

A = Symbol('A')
B = Symbol('B')
C = Symbol('C')
D = Symbol('D')
a = Symbol('a')
b = Symbol('b')
c = Symbol('c')
d = Symbol('d')
p = Symbol('p')

# Ungleichung aufstellen

E_1K = A/(1-p)


E_1NK = B+ D/(1-p)-D


Bedingung = Eq(E_1K, E_1NK)


sol1=solve(Bedingung, p) # wie löse ich das als Ungleichung?

print(sol1)

E_2K = a/(1-p)

E_2NK = c+ d/(1-p) -d

Bedingung = Eq(E_2K, E_2NK)

sol2 = solve(Bedingung, p)
print(sol2)
```


```{python}
#| eval: false


import numpy as np

import random

# Zufällige Ganzzahlen zwischen 0 und 9 generieren
A = random.randint(5, 7)
B = random.randint(8, 9)
C = random.randint(0, 1)
D = random.randint(2, 4)
a = random.randint(5, 8)
b = random.randint(0, 1)
c = random.randint(8, 9)
d = random.randint(2, 4)

# Formatierte Bimatrix ausgeben
print("    l   r")
print(f"o  {A},{a}  {C},{c}")
print(f"u  {B},{b}  {D},{d}")


# Funktionen für Nash-Bedingungen
def is_ol_nash(A, B, a, c):
  return "ol" if (A >= B) and (a >= c) else "not_ol"

def is_ul_nash(B, A, b, d):
  return "ul" if (B >= A) and (b >= d) else "not_ul"

def is_or_nash(C, D, c, a):
  return "or" if (C >= D) and (c >= a) else "not_or"

def is_ur_nash(D, C, d, b):
  return "ur" if (D >= C) and (d >= b) else "not_ur"

# Nash-Bedingungen überprüfen und Strings zuweisen
Cand_Nash_ol = is_ol_nash(A, B, a, c)
Cand_Nash_ul = is_ul_nash(B, A, b, d)
Cand_Nash_or = is_or_nash(C, D, c, a)
Cand_Nash_ur = is_ur_nash(D, C, d, b)

# Ergebnisse kombinieren und NAs entfernen
Nash_GG = np.array([Cand_Nash_ol, Cand_Nash_ul, Cand_Nash_or, Cand_Nash_ur])
Nash_GG_filtered = []
for element in Nash_GG:
  if element == "ol" or element == "ul" or element == "or" or element == "ur":
    Nash_GG_filtered.append(element)

# Ergebnis ausgeben
print(Nash_GG_filtered)

# Kritisches p für Kooperation

p_krit = (B-A)/(B - D)
#print(round(p_krit,3))
print(f"Für Kooperation durch Spieler 1 muss die Wahrscheinlichkeit für eine weitere Runde mindestens {str(round(p_krit,3)).replace('.',',')} betragen.")

p_krit = (c-a)/(c - d)
#print(round(p_krit,3))
print(f"Für Kooperation durch Spieler 2 muss die Wahrscheinlichkeit für eine weitere Runde mindestens {str(round(p_krit,3)).replace('.',',')} betragen.")

```


#### Trembling Hand

```{python}
#| message: false
#| warning: false

# Python

import random

random.seed(246)

while True:
    A = random.randint(0, 9)
    a = random.randint(0, 9)
    B = random.randint(0, 9)
    b = random.randint(0, 9)
   # C = random.randint(0, 9)
    C=-20
    c = random.randint(0, 9)
    D = random.randint(0, 9)
    d = random.randint(0, 9)

    # Bedingungen prüfen
    cond1 = (A > B) and (a >= c) # NGG ol
    cond2 = (D  > C) and (A > D) and (a > d)

    # Wenn beide Bedingung erfüllt ist, Schleife beenden
    if  (cond1 and cond2):
        break

# Ausgabe der Zahlen
#print(f"A={A}, a={a}, B={B}, b={b}, C={C}, c={c}, D={D}, d={d}")

# Formatierte Bimatrix ausgeben
#print("    l   r")
#print(f"o  {A},{a}  {C},{c}")
#print(f"u  {B},{b}  {D},{d}")


plot = create_plot()

plot


```


-   Idee: Manche Nash-Gleichgewichte sind riskant

-   Wenn der Gegenspieler "versehentlich" eine falsche Strategie spielt, dann macht man evtl hohe Verluste

-   Wie hoch darf die Fehlerwahrscheinlichkeit des Gegenspielers sein, damit das Nash-Gleichgewicht noch die richtige Strategie impliziert?

Angenommen, beide Spieler streben ein Nash-Gleichgewicht oben links an

**Für Spieler 1 muss dann gelten**

$E_o\geq E_u$

Wenn er davon ausgeht, dass Spieler 2 mit einer Wahrscheinlichkeit von $p$ versehentlich rechts statt links spielt, heißt das

$(1-p)A+pC \geq (1-p)B+pD$

$\iff A-pA+pC\geq B-pB+pD$

$\iff A-p(A-C) \geq B-p(B-D)$

$\iff p(B-D)-p(A-C) \geq B-A$

$\iff p(B-D-A+C)\geq B-A$

mit $(B-D-A+C) <0$

$\iff p \leq \frac{B-A}{B-A-D+C}=\frac{A-B}{A-B-C+D}$

**Für Spieler 2 muss dann gelten**

$E_l\geq E_r$

$(1-p)a+pb \geq (1-p)c+pd$

$\iff a-pa+pb \geq c-pc+pd$

$\iff a-p(a-b) \geq c-p(c-d)$

$\iff p(c-d)-p(a-b) \geq c-a$

$\iff p(c-d-a+b) \geq c-a$

mit $(c-d-a+b)\neq 0$

$p \leq \frac{c-a}{(c-d-a+b)}=\frac{a-c}{(a-b-c+d)}$

```{python}
#| echo: true
#| eval: false

# Wahrscheinlichkeiten ausrechnen

from sympy import Symbol, solve, Eq

symbols = [Symbol(name) for name in 'ABCDabcdp']
A, B, C, D, a, b, c, d, p = symbols  # Entpacken und als separate Variablen speichern

# Beide streben ol an

E_o= (1-p)*A+p*C

E_u= (1-p)*B + p*D

sol = solve(Eq(E_o, E_u), p)
print(sol)

E_l = (1-p)*a + p*b
E_r = (1-p)*c + p*d

sol = solve(Eq(E_l, E_r),p)
print(sol)

```

### Gemischte Strategien

- Wenn es entweder kein Nash-Gleichgewicht (in reinen Strategien) gibt oder mehrere Nash-Gleichgewichte, dann lässt sich das Handeln der Spielenden nicht gut vorhersagen

- Aus der Perspektive jedes Spielenden ist das Handeln des Gegenübers eine Zufallsvariable. Mit einer bestimmten Wahrscheinlichkeit wählt das Gegenüber eine seiner Strategien.

- Den Zufall kann man aber näher charakterisieren, wenn man sich überlegt, **welche Wahrscheinlichkeiten ein rationales Gegenüber wählen würde**.

- Ein rationales Gegenüber wählt die Wahrscheinlichkeiten so, dass der spielende Akteur keine Möglichkeit mehr hat, seine Situation durch die Wahl seiner Strategie zu verbessern. 
- Jede spielende Person wählt die Wahrscheinlichkeiten für ihre Handlung also so, dass das jeweilige Gegenüber indifferent ist in der Wahl seiner Handlungen.

- Es muss also gelten: $$E_o=E_u$$
$$\iff p_l A+(1-p_l)C=p_lB+(1-p_l)D$$


$$\iff p_l A + C-p_lC=p_lB+D-p_lD$$

$$\iff p_l(A-C)+C=p_l(B-D)+D$$

$$\iff p_l(A-C-B+D)=D-C$$
$$\boxed{p_l=\frac{D-C}{A-B-C+D}}$$
$$E_l=E_r$$

$$\iff p_o a+(1-p_o)b=p_o c + (1-p_o)d$$

$$\iff p_o a+b-p_ob=p_oc+d-p_od$$
$$\iff p_o(a-b)+b=p_o(c-d)+d$$

$$\iff p_o(a-b-c+d)=d-b$$

$$\iff \boxed{p_o=\frac{d-b}{a-b-c+d}}$$



```{python}
#| message: false
#| warning: false

import numpy as np
import random
from lets_plot import *

random.seed(12)

while True:
    A = random.randint(0, 9)
    a = random.randint(0, 9)
    B = random.randint(0, 9)
    b = random.randint(0, 9)
    C = random.randint(0, 9)
    c = random.randint(0, 9)
    D = random.randint(0, 9)
    d = random.randint(0, 9)

    # Bedingungen prüfen: Keine dominante Strategien
    cond1 = (A >= B) and (C >= D)
    cond2 = (B >= A) and (D >= C)
    cond3 = (a >= c) and (b >= d)
    cond4 = (c >= a) and (d >= b)

    # Wenn keine Bedingung erfüllt ist, Schleife beenden
    if not (cond1 or cond2 or cond3 or cond4):
        break

plot = create_plot()

plot



# Funktionen für Nash-Bedingungen
def is_ol_nash(A, B, a, c):
  return "ol" if (A >= B) and (a >= c) else "not_ol"

def is_ul_nash(B, A, b, d):
  return "ul" if (B >= A) and (b >= d) else "not_ul"

def is_or_nash(C, D, c, a):
  return "or" if (C >= D) and (c >= a) else "not_or"

def is_ur_nash(D, C, d, b):
  return "ur" if (D >= C) and (d >= b) else "not_ur"

# Nash-Bedingungen überprüfen und Strings zuweisen
Cand_Nash_ol = is_ol_nash(A, B, a, c)
Cand_Nash_ul = is_ul_nash(B, A, b, d)
Cand_Nash_or = is_or_nash(C, D, c, a)
Cand_Nash_ur = is_ur_nash(D, C, d, b)

# Ergebnisse kombinieren und NAs entfernen
Nash_GG = np.array([Cand_Nash_ol, Cand_Nash_ul, Cand_Nash_or, Cand_Nash_ur])
Nash_GG_filtered = []
for element in Nash_GG:
  if element == "ol" or element == "ul" or element == "or" or element == "ur":
    Nash_GG_filtered.append(element)



# Ergebnis ausgeben
if Nash_GG_filtered == []:
   print('Es gibt kein Nash-Gleichgewicht in reinen Strategien')

else:
   print(f"Nash-Gleichgewicht(e) in reinen Strategien: {', '.join(Nash_GG_filtered)}")



# Anzahl der Nash GG

#Anzahl_NGG=len(Nash_GG_filtered)
#print(Anzahl_NGG)

# Wahrscheinlichkeiten ausrechnen.
# Dabei jeweils den Fall Division duch 0 aussschließen

#p_l
if (A - B - C + D)!=0: p_l = ( D-C)/(A - B - C + D)

#print(round(p_l, 2))

#p_o
if (-b + d)/(a - b - c + d)!=0: p_o = (-b + d)/(a - b - c + d)

#print(round(p_o, 2))


# Ausgabe Abhängig von Bedingungen

if (#Anzahl_NGG == 1 or
    p_o < 0 or p_l < 0 or
            p_o > 1 or p_l > 1 or
            (a - b - c + d) == 0 or
            (A - B - C + D) == 0):
    print("Kein Nash-Gleichgewicht in gemischten Strategien")
else:   print(f"Gemischte Strategien: p_o= {round(p_o, 2)}, p_l= {round(p_l, 2)}")
```




```{python}
#| eval: false

# Wahrscheinlichkeiten ausrechnen

from sympy import Symbol, solve, Eq

symbols = [Symbol(name) for name in 'ABCDabcdp']
A, B, C, D, a, b, c, d, p = symbols  # Auspacken in verschiedene Variablen


#p_l
E_o= p*A+(1-p)*C

E_u= p*B  + (1-p)*D

sol = solve(Eq(E_o, E_u), p)
print(sol)

#p_o

E_l = p*a + (1-p)*b
E_r = p*c + (1-p)*d

sol = solve(Eq(E_l, E_r),p)
print(sol)
```


## Sequenzielle Spiele

Spieler spielen nacheinander.

### Vollständige Information

Annahme: Alle Spieler kennen alle Auszahlungen und sehen alle bislang erfolgten Spielzüge

Darstellung des Spiels mittels eines Spielbaums

![Grundstruktur eines Spielbaums](figure/Baum-Grundstruktur-1.png){width="50%"}

#### Rückwärtsinduktion

Lösen des Spiels "von hinten nach vorn"

##### Beispiele

![Beispiel für Rückwärtsinduktion](figure/Baum-Rückwärtsinduktion-a-1.png){width="50%"}

![Beispiel für Rückwärtsinduktion](figure/Baum-Rückwärtsinduktion-b-1.png){width="50%"}

##### Bedingungen für ein Nash-Gleichgewicht

Zunächst vereinfachende Annahme: $a\neq c\ \text{und}\ b \neq d$

Ja, was sind die Bedingungen?

**ol**: $a>c \land ((A>B\ \land\ b>d) \lor (A>D\ \land\ d>b))$

**or**: $c>a  \land ((C>D\ \land d>b) \lor (C>B\ \land b> d))$

**ul**: $b>d \land ((B>A \land a>c)\lor(B>C \land c>a))$

**ur**: $d>b \land ((D>A \land a>c)\lor (D>C \land c>a))$

```{r, eval=F, include=F}

**or**: $c>a \land ((C>B\ \land\ b>d) \lor (C>D\ \land\ d>b))$

**ul**: $b>d \land ((B>A\ \land\ a>c) \lor (B>C\ \land\ c>a))$

**ur**: $d>b \land ((D>A\ \land\ a>c) \lor (D>C\ \land\ c>a))$

```

Hier: Implementierung in Python

```{python}
import numpy as np
import random

random.seed(123) # Für reproduzierbare Ergebnisse ggf. fixieren

# Zufällige Ganzzahlen zwischen 0 und 9 generieren
#A = random.randint(0, 9)
#B = random.randint(0, 9)
#C = random.randint(0, 9)
#D = random.randint(0, 9)
#a = random.randint(0, 9)
#b = random.randint(0, 9)
#c = random.randint(0, 9)
#d = random.randint(0, 9)

#A = 1
#B = 0
#C = 0
#D = 0
#a = 1
#b = 0
#c = 0
#d = 0

# Zufallszahlen, aber alle unterschiedlich
choices = np.arange(10)

# Generate unique random integers for uppercase variables
Parameter = np.random.choice(choices, size=8, replace=False)
A, B, C, D, a, b, c, d = Parameter


# Formatierte Bimatrix ausgeben
#print("    l   r")
#print(f"o  {A},{a}  {C},{c}")
#print(f"u  {B},{b}  {D},{d}")


# Spielbaum ausgeben

print(f" ol: {A}, {a}\n or: {C}, {c}\n ul: {B}, {b}\n ur: {D}, {d}")

# Funktionen für Nash-Bedingungen
# Spieler 2 (a) entscheidet l/r, Spieler 1 (A) entscheidet o/u
def is_ol_nash(A, B, D, a, b, c, d):
  return "ol" if ((a > c) and ((A>= B and b> d) or
              (A >= D and d>=b))) else "not_ol"

def is_or_nash( B, C, D, a, b, c, d):
  return "or" if (c>a and ((C>= B and b>=d) or
              (C >= D and d>b))) else "not_or"


def is_ul_nash(A, B, C,  a, b, c, d):
  return "ul" if (b>=d and ((B>= A and a>= c) or
              (B >= C and c>=a))) else "not_ul"


def is_ur_nash(A,  C, D, a, b, c, d):
  return "ur" if (d>=b and ((D>= A and a>= c) or
              (D >= C and c>=a))) else "not_ur"


# Nash-Bedingungen überprüfen und Strings zuweisen

Cand_Nash_ol = is_ol_nash(A, B,    D, a, b, c, d)
Cand_Nash_or = is_or_nash(   B, C, D, a, b, c, d)
Cand_Nash_ul = is_ul_nash(A, B, C,    a, b, c, d)
Cand_Nash_ur = is_ur_nash(A,    C, D, a, b, c, d)

# Ergebnisse kombinieren und NAs entfernen
Nash_GG = np.array([Cand_Nash_ol, Cand_Nash_ul, Cand_Nash_or, Cand_Nash_ur])
Nash_GG_filtered = []
for element in Nash_GG:
  if element == "ol" or element == "or" or element == "ul" or element == "ur":
    Nash_GG_filtered.append(element)

# Ergebnis ausgeben
print(Nash_GG_filtered)
```

#### Teilspielperfektheit

-   Teilspielperfektheit verlangt, dass jeder Spieler jeden Zug so ausführt, dass das Ergebnis des Zuges seinen Interessen nicht schadet.

-   Ein Teilspiel beginnt in einem Knoten und enthält alle nachfolgenden Knoten

-   Für später: Ein Teilspiel darf nachfolgende Informationsmengen nicht teilen. Es gehören also immer alle Knoten einer Informationsmenge zu einem Teilspiel

Beispiel: Unglaubwürdige Drohung

![Unglaubwürdige Drohung](figure/Baum-Unglaubwürdige-Drohung-1.png){width="50%"}


Hier: Tafelaufschrieb Markteintrittsspiel

#### Selbstbindung


Hier: Sonderabbildung Weltvernichtungsbombe

### Unvollständige Information

#### Alles beobachtbar, aber Auszahlungen können gleich sein

![Auszahlungen von Spieler 1 sind gleich](figure/Baum-Gleiche-Auszahlungen-S1-1.png){width="50%"}

$\rightarrow$ Spieler 1 muss sich irgendwie entscheiden, aber Spieler 2 kann die Entscheidung sehen.


![Auszahlungen von Spieler 2 sind gleich](figure/Baum-Gleiche-Auszahlungen-S2-1.png){width="50%"}

$\rightarrow$ Spieler 1 kann nicht antizipieren, was Spieler 2 im Fall "unten" macht. 

$\rightarrow$ Kriterium für Entscheidung unter Risiko

Mögliche Kriterien:

- **Erwartungswert**
- Erwartungsnutzen
- Maximin
- $\dots$

Hier unterstellt: Erwartungswertkriterium

Die Bedingungen für ein Nash-Gleichgewicht bei sequenziellen Spielen lauten dann:


ja wie?


**ol**: $a>c \land ((A\geq B\ \land\ b \geq d) \lor (A \geq  D\ \land\ d \geq b) ) \lor a=c \land ((b>d \land (\frac{A+C}{2} \geq B)\lor (d>b \land \frac{A+C}{2}\geq D) \lor (b=d \land(\frac{A+C}{2}\geq \frac{B+D}{2})))$

**or**: $c>a  \land ((C>D\ \land d>b) \lor (C>B\ \land b> d))$

**ul**: $b>d \land ((B>A \land a>c)\lor(B>C \land c>a))$

**ur**: $d>b \land ((D>A \land a>c)\lor (D>C \land c>a))$

```{python}
#| include: false

# Spielbaum vollständige Information
import numpy as np
import random

#random.seed(123) # Für reproduzierbare Ergebnisse ggf. fixieren

# Zufällige Ganzzahlen zwischen 0 und 9 generieren
A = random.randint(0, 9)
B = random.randint(0, 9)
C = random.randint(0, 9)
D = random.randint(0, 9)
a = random.randint(0, 9)
b = random.randint(0, 9)
c = random.randint(0, 9)
d = random.randint(0, 9)

# Formatierte Bimatrix ausgeben
#print("    l   r")
#print(f"o  {A},{a}  {C},{c}")
#print(f"u  {B},{b}  {D},{d}")


# Spielbaum ausgeben

print(f" ol: {A}, {a}\n or: {C}, {c}\n ul: {B}, {b}\n ur: {D}, {d}")


# Annahme: Spieler 2 sieht Zug von Spieler 1.
# Beide Spieler kennen alle Auszahlungen
# Spieler 2 zieht nach Spieler 1



# Funktionen für Nash-Bedingungen
# Spieler 2 (a) entscheidet l/r, Spieler 1 (A) entscheidet o/u

# Funktionen für Nash-Bedingungen


def is_ol_nash(A, B, C, D, a, b, c, d):
  return "ol" if (a > c and ((A>= B and b>=d)  or
                            (A >= D and d>=b)) or
                 (a==c and ((b>d  and (A+C)/2>=B) or
                           (d>b  and (A+C)/2>=D) or
                           (d==b and (A+C)/2>=(B+D)/2)))) else "not_ol"

def is_or_nash(A, B, C, D, a, b, c, d):
  return "or" if (c > a and ((C>= B and b>=d)  or
                            (C >= D and d>=b)) or
                 (c==a and ((b>d  and (A+C)/2>=B) or
                           (d>b  and (A+C)/2>=D) or
                           (d==b and (A+C)/2>=(B+D)/2)))) else "not_or"




def is_ul_nash(A, B, C, D, a, b, c, d):
  return "ul" if (b > d and ((B>= A and a>=c)  or
                            (B >= C and c>=a)) or
                 (b==d  and ((a>c  and (B+D)/2>=A) or
                           (c>a  and (B+D)/2>=C) or
                           (a==c and (B+D)/2>=(A+C)/2)))) else "not_ul"


def is_ur_nash(A, B, C, D, a, b, c, d):
  return "ur" if (d > b and ((D>= A and a>=c)  or
                            (D >= C and c>=a)) or
                 (d==b and ((a>c  and (B+D)/2>=A) or
                           (c>a  and (B+D)/2>=C) or
                           (a==c and (B+D)/2>=(A+C)/2)))) else "not_ur"


# Nash-Bedingungen überprüfen und Strings zuweisen

Cand_Nash_ol = is_ol_nash(A, B, C, D, a, b, c, d)
Cand_Nash_or = is_or_nash(A, B, C, D, a, b, c, d)
Cand_Nash_ul = is_ul_nash(A, B, C, D, a, b, c, d)
Cand_Nash_ur = is_ur_nash(A, B, C, D, a, b, c, d)

# Ergebnisse kombinieren und NAs entfernen
Nash_GG = np.array([Cand_Nash_ol, Cand_Nash_ul, Cand_Nash_or, Cand_Nash_ur])
Nash_GG_filtered = []
for element in Nash_GG:
  if element == "ol" or element == "or" or element == "ul" or element == "ur":
    Nash_GG_filtered.append(element)

# Ergebnis ausgeben
print(Nash_GG_filtered)
```

#### Zug von Spieler 1 ist für Spieler 2 unsichtbar


![Baum Zug 1 unsichtbar ](figure/Baum-Zug1-unsichtbar-1.png)
- Fehlende Information für Spieler 2 kein Problem, wenn er eine dominante Alternative hat oder wenn alle Auszahlungen für ihn gleich sind.

- Fehlende Information für Spieler 2 kein Problem, wenn Spieler 1 eine dominante Alternative hat.

- Wenn Information nicht vorliegt, Entscheidungskriterium unter Risiko nutzen. Hier: Erwartungswert

```{python}
#|echo: true
#| eval: false


import numpy as np
import random

#random.seed(123) # Für reproduzierbare Ergebnisse ggf. fixieren

# Zufällige Ganzzahlen zwischen 0 und 9 generieren

A, B, C, D, a, b, c, d = random.choices(range(10), k=8)


# Formatierte Bimatrix ausgeben
#print("    l   r")
#print(f"o  {A},{a}  {C},{c}")
#print(f"u  {B},{b}  {D},{d}")


# Spielbaum ausgeben

print(f" ol: {A}, {a}\n or: {C}, {c}\n ul: {B}, {b}\n ur: {D}, {d}")


# Annahme: Spieler 2 sieht Zug von Spieler 1 nicht


# Kommentare zur Strategie



# Funktionen für Nash-Bedingungen
# Spieler 2 (a) entscheidet l/r, Spieler 1 (A) entscheidet o/u 

#def is_ol_nash(A, B, C, D, a, b, c, d):
#  return "ol" if ...
#              else "not_ol"

#def is_or_nash(A, B, C, D, a, b, c, d):
 # return "or" if... 
  #          else "not_or"


#def is_ul_nash(A, B, C, D, a, b, c, d):
#  return "ul" if ...
 #             else "not_ul"


#def is_ur_nash(A, B, C, D, a, b, c, d):
#  return "ur" if ...
 #             else "not_ur"


# Nash-Bedingungen überprüfen und Strings zuweisen

Cand_Nash_ol = is_ol_nash(A, B, C, D, a, b, c, d)
Cand_Nash_or = is_or_nash(A, B, C, D, a, b, c, d)
Cand_Nash_ul = is_ul_nash(A, B, C, D, a, b, c, d)
Cand_Nash_ur = is_ur_nash(A, B, C, D, a, b, c, d)

# Ergebnisse kombinieren und NAs entfernen
Nash_GG = np.array([Cand_Nash_ol, Cand_Nash_ul, Cand_Nash_or, Cand_Nash_ur])
Nash_GG_filtered = []
for element in Nash_GG:
  if element == "ol" or element == "or" or element == "ul" or element == "ur":
    Nash_GG_filtered.append(element)
    
#Ergebnis ausgeben
print(Nash_GG_filtered)
```


#### Typ von Spieler 1 (und damit die Menge seiner Auszahlungen) ist für Spieler 2 unsichtbar


s. Tafelaufschrieb

Grundsätzlich zwei verschiedene Typen von Gleichgewichten:

- Separierende Gleichgewichte: Spieler 1 offenbart durch seine Entscheidung, von welchem Typ er ist

- Pooling Gleichgewichte: Man kann kann aus dem Handeln des Spielers 1 nicht auf seinen Typ schließen

[## Koalitionsspiele]::

## Evolutionäre Spiele

[https://eckhartarnold.de/papers/2009_Vorlesung_Entscheidungstheorie/node127.html]:

### Idee

### Erfolg von Strategien
[Tournaments]:


### Evolution von Strategien
[Simulationen,  Kriterien für stabile Strategien]::

### Diskussion und Ausblick

```



