{
  "hash": "7eabb5ef0f431770912afc02a531e411",
  "result": {
    "engine": "jupyter",
    "markdown": "# Nicht-kooperative Spieltheorie\n\n## Einleitung und begriffliche Einordnung\n\n## Simultane Spiele\n\n### Grundsätzliche Struktur eines Spiels\n\n[![Allgemeines Struktur eines Spiels](figure/Allgemeine-Struktur.png){width=\"50%\"}]::\n\n::: {#90dff42f .cell message='false' execution_count=1}\n``` {.python .cell-code}\nfrom lets_plot import *\n\nLetsPlot.setup_html()\n\nggplot() + \\\ngeom_text(x=- .5, y= 2   , label='a') +\\\ngeom_text(x=-1.5, y=  .75, label='A') +\\\ngeom_text(x=- .5, y=-1   , label='b') +\\\ngeom_text(x=-1.5, y=-2.25, label='B') +\\\ngeom_text(x= 1.5, y= 2   , label='c') +\\\ngeom_text(x=  .5, y=  .75, label='C') +\\\ngeom_text(x= 1.5, y=-1   , label='d') +\\\ngeom_text(x=  .5, y=-2.25, label='D') +\\\ngeom_text(x=-1  , y= 3.3 , label='links')+\\\ngeom_text(x= 1  , y= 3.3 , label='rechts')+\\\ngeom_text(x=-2.2, y= 1.375, angle=90, label='oben')+\\\ngeom_text(x=-2.2, y=-1.625, angle=90, label='unten')+\\\ngeom_text(x= 0 , y= 4 ,\n          fontface = \"bold\", label='Spieler 2')+\\\ngeom_text(x=-2.7 , y= 0 , angle=90,\n          fontface = \"bold\", label='Spieler 1')+\\\ngeom_segment(x=-2,  xend= 2, y= 0, yend= 0) +\\\ngeom_segment(x=-2,  xend= 2, y= 3, yend= 3) +\\\ngeom_segment(x=-2,  xend= 2, y=-3, yend=-3) +\\\ngeom_segment(x=-2,  xend=-2, y=-3, yend= 3) +\\\ngeom_segment(x= 0,  xend= 0, y=-3, yend= 3) +\\\ngeom_segment(x= 2,  xend= 2, y=-3, yend= 3) +\\\ntheme_void()+\\\nlabs(title='Auszahlungen in einem simultanen Spiel' #,\n    # caption = 'Caption'\n)\n```\n\n::: {.cell-output .cell-output-display}\n```{=html}\n\n            <div id=\"NYcnUL\"></div>\n            <script type=\"text/javascript\" data-lets-plot-script=\"library\">\n                if(!window.letsPlotCallQueue) {\n                    window.letsPlotCallQueue = [];\n                }; \n                window.letsPlotCall = function(f) {\n                    window.letsPlotCallQueue.push(f);\n                };\n                (function() {\n                    var script = document.createElement(\"script\");\n                    script.type = \"text/javascript\";\n                    script.src = \"https://cdn.jsdelivr.net/gh/JetBrains/lets-plot@v4.6.2/js-package/distr/lets-plot.min.js\";\n                    script.onload = function() {\n                        window.letsPlotCall = function(f) {f();};\n                        window.letsPlotCallQueue.forEach(function(f) {f();});\n                        window.letsPlotCallQueue = [];\n                        \n                    };\n                    script.onerror = function(event) {\n                        window.letsPlotCall = function(f) {};    // noop\n                        window.letsPlotCallQueue = [];\n                        var div = document.createElement(\"div\");\n                        div.style.color = 'darkred';\n                        div.textContent = 'Error loading Lets-Plot JS';\n                        document.getElementById(\"NYcnUL\").appendChild(div);\n                    };\n                    var e = document.getElementById(\"NYcnUL\");\n                    e.appendChild(script);\n                })()\n            </script>\n            \n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n```{=html}\n   <div id=\"G3FpT4\"></div>\n   <script type=\"text/javascript\" data-lets-plot-script=\"plot\">\n   \n   (function() {\n   // ----------\n   \n   const forceImmediateRender = false;\n   const responsive = false;\n   \n   let sizing = {\n       width_mode: \"MIN\",\n       height_mode: \"SCALED\",\n       width: null, \n       height: null \n   };\n   \n   const preferredWidth = document.body.dataset.letsPlotPreferredWidth;\n   if (preferredWidth !== undefined) {\n       sizing = {\n           width_mode: 'FIXED',\n           height_mode: 'SCALED',\n           width: parseFloat(preferredWidth)\n       };\n   }\n   \n   const containerDiv = document.getElementById(\"G3FpT4\");\n   let fig = null;\n   \n   function renderPlot() {\n       if (fig === null) {\n           const plotSpec = {\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"theme\":{\n\"name\":\"classic\",\n\"line\":\"blank\",\n\"axis\":\"blank\"\n},\n\"ggtitle\":{\n\"text\":\"Auszahlungen in einem simultanen Spiel\"\n},\n\"kind\":\"plot\",\n\"scales\":[],\n\"layers\":[{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-0.5,\n\"y\":2.0,\n\"label\":\"a\",\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-1.5,\n\"y\":0.75,\n\"label\":\"A\",\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-0.5,\n\"y\":-1.0,\n\"label\":\"b\",\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-1.5,\n\"y\":-2.25,\n\"label\":\"B\",\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":1.5,\n\"y\":2.0,\n\"label\":\"c\",\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":0.5,\n\"y\":0.75,\n\"label\":\"C\",\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":1.5,\n\"y\":-1.0,\n\"label\":\"d\",\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":0.5,\n\"y\":-2.25,\n\"label\":\"D\",\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-1.0,\n\"y\":3.3,\n\"label\":\"links\",\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":1.0,\n\"y\":3.3,\n\"label\":\"rechts\",\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.2,\n\"y\":1.375,\n\"angle\":90.0,\n\"label\":\"oben\",\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.2,\n\"y\":-1.625,\n\"angle\":90.0,\n\"label\":\"unten\",\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":0.0,\n\"y\":4.0,\n\"fontface\":\"bold\",\n\"label\":\"Spieler 2\",\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.7,\n\"y\":0.0,\n\"angle\":90.0,\n\"fontface\":\"bold\",\n\"label\":\"Spieler 1\",\n\"data\":{\n}\n},{\n\"geom\":\"segment\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.0,\n\"xend\":2.0,\n\"y\":0.0,\n\"yend\":0.0,\n\"data\":{\n}\n},{\n\"geom\":\"segment\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.0,\n\"xend\":2.0,\n\"y\":3.0,\n\"yend\":3.0,\n\"data\":{\n}\n},{\n\"geom\":\"segment\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.0,\n\"xend\":2.0,\n\"y\":-3.0,\n\"yend\":-3.0,\n\"data\":{\n}\n},{\n\"geom\":\"segment\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.0,\n\"xend\":-2.0,\n\"y\":-3.0,\n\"yend\":3.0,\n\"data\":{\n}\n},{\n\"geom\":\"segment\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":0.0,\n\"xend\":0.0,\n\"y\":-3.0,\n\"yend\":3.0,\n\"data\":{\n}\n},{\n\"geom\":\"segment\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":2.0,\n\"xend\":2.0,\n\"y\":-3.0,\n\"yend\":3.0,\n\"data\":{\n}\n}],\n\"metainfo_list\":[],\n\"spec_id\":\"1\"\n};\n           window.letsPlotCall(function() { fig = LetsPlot.buildPlotFromProcessedSpecs(plotSpec, containerDiv, sizing); });\n       } else {\n           fig.updateView({});\n       }\n   }\n   \n   const renderImmediately = \n       forceImmediateRender || (\n           sizing.width_mode === 'FIXED' && \n           (sizing.height_mode === 'FIXED' || sizing.height_mode === 'SCALED')\n       );\n   \n   if (renderImmediately) {\n       renderPlot();\n   }\n   \n   if (!renderImmediately || responsive) {\n       // Set up observer for initial sizing or continuous monitoring\n       var observer = new ResizeObserver(function(entries) {\n           for (let entry of entries) {\n               if (entry.contentBoxSize && \n                   entry.contentBoxSize[0].inlineSize > 0) {\n                   if (!responsive && observer) {\n                       observer.disconnect();\n                       observer = null;\n                   }\n                   renderPlot();\n                   if (!responsive) {\n                       break;\n                   }\n               }\n           }\n       });\n       \n       observer.observe(containerDiv);\n   }\n   \n   // ----------\n   })();\n   \n   </script>\n```\n:::\n:::\n\n\n### Reine Strategien\n\n#### Definition Nash-Gleichgewicht\n\nEin Nash-Gleichgewicht liegt vor, wenn jeder Spieler die beste Antwort auf die beste Strategie des Gegenspielers spielt.\n\nFormal:\n\n$u_{i}\\left(s_{i}^{*},s_{-i}^{*}\\right)\\geq u_{i}\\left(s_{i},s_{-i}^{*}\\right)\\mbox{ für alle }i,\\mbox{ }s_{i}\\in S_{i}$\n\nIntuition: Ein Nash-Gleichgewicht liegt vor, wenn kein Spieler mehr die Möglichkeit hat, seine Situation durch eine **nur eigene** Entscheidungsänderung zu verbessern.\n\nIn der Matrix oben heißt dass, das geprüft werden muss\n\n$A \\geq B \\land a \\geq c$ $\\rightarrow$ **ol**\n\n$B \\geq A \\land b \\geq d$ $\\rightarrow$ **ul**\n\n$C \\geq D \\land c \\geq a$ $\\rightarrow$ **or**\n\n$D \\geq C \\land d \\geq b$ $\\rightarrow$ **ur**\n\nEs kann kein oder ein Nash-Gleichgewicht existieren oder mehrere Nash-Gleichgewichte\n\n#### Einperiodige Spiele\n\n::: {#fe8c72d3 .cell execution_count=2}\n``` {.python .cell-code}\nimport numpy as np\n\nimport random\n\n# Zufällige Ganzzahlen zwischen 0 und 9 generieren\n\nrandom.seed(123)\n\nA = random.randint(0, 9)\nB = random.randint(0, 9)\nC = random.randint(0, 9)\nD = random.randint(0, 9)\na = random.randint(0, 9)\nb = random.randint(0, 9)\nc = random.randint(0, 9)\nd = random.randint(0, 9)\n\n# Formatierte Bimatrix ausgeben\n# print(f\"     l    r\\n o  {A},{a}  {C},{c}\\n # u  {B},{b}  {D},{d}\")\n\nfrom lets_plot import *\n\nLetsPlot.setup_html()\n\nggplot() + \\\ngeom_text(x=- .5, y= 2   , label=a) +\\\ngeom_text(x=-1.5, y=  .75, label=A) +\\\ngeom_text(x=- .5, y=-1   , label=b) +\\\ngeom_text(x=-1.5, y=-2.25, label=B) +\\\ngeom_text(x= 1.5, y= 2   , label=c) +\\\ngeom_text(x=  .5, y=  .75, label=C) +\\\ngeom_text(x= 1.5, y=-1   , label=d) +\\\ngeom_text(x=  .5, y=-2.25, label=D) +\\\ngeom_text(x=-1  , y= 3.3 , label='links')+\\\ngeom_text(x= 1  , y= 3.3 , label='rechts')+\\\ngeom_text(x=-2.2, y= 1.375, angle=90, label='oben')+\\\ngeom_text(x=-2.2, y=-1.625, angle=90, label='unten')+\\\ngeom_text(x= 0 , y= 4 ,\n          fontface = \"bold\", label='Spieler 2')+\\\ngeom_text(x=-2.7 , y= 0 , angle=90,\n          fontface = \"bold\", label='Spieler 1')+\\\ngeom_segment(x=-2,  xend= 2, y= 0, yend= 0) +\\\ngeom_segment(x=-2,  xend= 2, y= 3, yend= 3) +\\\ngeom_segment(x=-2,  xend= 2, y=-3, yend=-3) +\\\ngeom_segment(x=-2,  xend=-2, y=-3, yend= 3) +\\\ngeom_segment(x= 0,  xend= 0, y=-3, yend= 3) +\\\ngeom_segment(x= 2,  xend= 2, y=-3, yend= 3) +\\\ntheme_void()+\\\nlabs(title='Auszahlungen in einem simultanen Spiel')\n```\n\n::: {.cell-output .cell-output-display}\n```{=html}\n\n            <div id=\"IJvv2d\"></div>\n            <script type=\"text/javascript\" data-lets-plot-script=\"library\">\n                if(!window.letsPlotCallQueue) {\n                    window.letsPlotCallQueue = [];\n                }; \n                window.letsPlotCall = function(f) {\n                    window.letsPlotCallQueue.push(f);\n                };\n                (function() {\n                    var script = document.createElement(\"script\");\n                    script.type = \"text/javascript\";\n                    script.src = \"https://cdn.jsdelivr.net/gh/JetBrains/lets-plot@v4.6.2/js-package/distr/lets-plot.min.js\";\n                    script.onload = function() {\n                        window.letsPlotCall = function(f) {f();};\n                        window.letsPlotCallQueue.forEach(function(f) {f();});\n                        window.letsPlotCallQueue = [];\n                        \n                    };\n                    script.onerror = function(event) {\n                        window.letsPlotCall = function(f) {};    // noop\n                        window.letsPlotCallQueue = [];\n                        var div = document.createElement(\"div\");\n                        div.style.color = 'darkred';\n                        div.textContent = 'Error loading Lets-Plot JS';\n                        document.getElementById(\"IJvv2d\").appendChild(div);\n                    };\n                    var e = document.getElementById(\"IJvv2d\");\n                    e.appendChild(script);\n                })()\n            </script>\n            \n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=2}\n```{=html}\n   <div id=\"o2nUDE\"></div>\n   <script type=\"text/javascript\" data-lets-plot-script=\"plot\">\n   \n   (function() {\n   // ----------\n   \n   const forceImmediateRender = false;\n   const responsive = false;\n   \n   let sizing = {\n       width_mode: \"MIN\",\n       height_mode: \"SCALED\",\n       width: null, \n       height: null \n   };\n   \n   const preferredWidth = document.body.dataset.letsPlotPreferredWidth;\n   if (preferredWidth !== undefined) {\n       sizing = {\n           width_mode: 'FIXED',\n           height_mode: 'SCALED',\n           width: parseFloat(preferredWidth)\n       };\n   }\n   \n   const containerDiv = document.getElementById(\"o2nUDE\");\n   let fig = null;\n   \n   function renderPlot() {\n       if (fig === null) {\n           const plotSpec = {\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"theme\":{\n\"name\":\"classic\",\n\"line\":\"blank\",\n\"axis\":\"blank\"\n},\n\"ggtitle\":{\n\"text\":\"Auszahlungen in einem simultanen Spiel\"\n},\n\"kind\":\"plot\",\n\"scales\":[],\n\"layers\":[{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-0.5,\n\"y\":2.0,\n\"label\":4.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-1.5,\n\"y\":0.75,\n\"label\":0.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-0.5,\n\"y\":-1.0,\n\"label\":1.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-1.5,\n\"y\":-2.25,\n\"label\":4.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":1.5,\n\"y\":2.0,\n\"label\":0.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":0.5,\n\"y\":0.75,\n\"label\":1.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":1.5,\n\"y\":-1.0,\n\"label\":6.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":0.5,\n\"y\":-2.25,\n\"label\":6.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-1.0,\n\"y\":3.3,\n\"label\":\"links\",\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":1.0,\n\"y\":3.3,\n\"label\":\"rechts\",\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.2,\n\"y\":1.375,\n\"angle\":90.0,\n\"label\":\"oben\",\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.2,\n\"y\":-1.625,\n\"angle\":90.0,\n\"label\":\"unten\",\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":0.0,\n\"y\":4.0,\n\"fontface\":\"bold\",\n\"label\":\"Spieler 2\",\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.7,\n\"y\":0.0,\n\"angle\":90.0,\n\"fontface\":\"bold\",\n\"label\":\"Spieler 1\",\n\"data\":{\n}\n},{\n\"geom\":\"segment\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.0,\n\"xend\":2.0,\n\"y\":0.0,\n\"yend\":0.0,\n\"data\":{\n}\n},{\n\"geom\":\"segment\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.0,\n\"xend\":2.0,\n\"y\":3.0,\n\"yend\":3.0,\n\"data\":{\n}\n},{\n\"geom\":\"segment\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.0,\n\"xend\":2.0,\n\"y\":-3.0,\n\"yend\":-3.0,\n\"data\":{\n}\n},{\n\"geom\":\"segment\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.0,\n\"xend\":-2.0,\n\"y\":-3.0,\n\"yend\":3.0,\n\"data\":{\n}\n},{\n\"geom\":\"segment\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":0.0,\n\"xend\":0.0,\n\"y\":-3.0,\n\"yend\":3.0,\n\"data\":{\n}\n},{\n\"geom\":\"segment\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":2.0,\n\"xend\":2.0,\n\"y\":-3.0,\n\"yend\":3.0,\n\"data\":{\n}\n}],\n\"metainfo_list\":[],\n\"spec_id\":\"2\"\n};\n           window.letsPlotCall(function() { fig = LetsPlot.buildPlotFromProcessedSpecs(plotSpec, containerDiv, sizing); });\n       } else {\n           fig.updateView({});\n       }\n   }\n   \n   const renderImmediately = \n       forceImmediateRender || (\n           sizing.width_mode === 'FIXED' && \n           (sizing.height_mode === 'FIXED' || sizing.height_mode === 'SCALED')\n       );\n   \n   if (renderImmediately) {\n       renderPlot();\n   }\n   \n   if (!renderImmediately || responsive) {\n       // Set up observer for initial sizing or continuous monitoring\n       var observer = new ResizeObserver(function(entries) {\n           for (let entry of entries) {\n               if (entry.contentBoxSize && \n                   entry.contentBoxSize[0].inlineSize > 0) {\n                   if (!responsive && observer) {\n                       observer.disconnect();\n                       observer = null;\n                   }\n                   renderPlot();\n                   if (!responsive) {\n                       break;\n                   }\n               }\n           }\n       });\n       \n       observer.observe(containerDiv);\n   }\n   \n   // ----------\n   })();\n   \n   </script>\n```\n:::\n:::\n\n\n::: {#1de9b1e2 .cell execution_count=3}\n``` {.python .cell-code}\n# Funktionen für Nash-Bedingungen\ndef is_ol_nash(A, B, a, c):\n  return \"ol\" if (A >= B) and (a >= c) else \"not_ol\"\n\ndef is_ul_nash(B, A, b, d):\n  return \"ul\" if (B >= A) and (b >= d) else \"not_ul\"\n\ndef is_or_nash(C, D, c, a):\n  return \"or\" if (C >= D) and (c >= a) else \"not_or\"\n\ndef is_ur_nash(D, C, d, b):\n  return \"ur\" if (D >= C) and (d >= b) else \"not_ur\"\n\n# Nash-Bedingungen überprüfen und Strings zuweisen\nCand_Nash_ol = is_ol_nash(A, B, a, c)\nCand_Nash_ul = is_ul_nash(B, A, b, d)\nCand_Nash_or = is_or_nash(C, D, c, a)\nCand_Nash_ur = is_ur_nash(D, C, d, b)\n\n# Ergebnisse kombinieren und NAs entfernen\nNash_GG = np.array([Cand_Nash_ol, Cand_Nash_ul, Cand_Nash_or, Cand_Nash_ur])\nNash_GG_filtered = []\nfor element in Nash_GG:\n  if element == \"ol\" or element == \"ul\" or element == \"or\" or element == \"ur\":\n    Nash_GG_filtered.append(element)\n\n# Ergebnis ausgeben\n#print(Nash_GG_filtered)\n```\n:::\n\n\n::: {#155090c7 .cell execution_count=4}\n``` {.python .cell-code}\nprint(f\"Nash-Gleichgewicht(e) in reinen Strategien: {', '.join(Nash_GG_filtered)}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNash-Gleichgewicht(e) in reinen Strategien: ur\n```\n:::\n:::\n\n\n##### Koordinationsspiel\n\n[![Koordinationsspiel](figure/Koordinationsspiel-1.png){width=\"50%\"}]::\n\n::: {#f50fbb51 .cell execution_count=5}\n``` {.python .cell-code}\nimport numpy as np\n\nimport random\n\nrandom.seed(123)\n\n# Zufällige Ganzzahlen zwischen 0 und 9 generieren\nA = 0\nB = random.randint(1, 9)\nC = B\nD = A\na = A\nb = B\nc = C\nd = D\n\n# Formatierte Bimatrix ausgeben\n#print(f\"     l    r\\n o  #{A},{a}  {C},{c}\\n u  {B},{b} # {D},{d}\")\n\n\ndef create_plot():\n    LetsPlot.setup_html()\n    return (\n        ggplot() +\n        geom_text(x=-0.5, y=2, label=a) +\n        geom_text(x=-1.5, y=0.75, label=A) +\n        geom_text(x=-0.5, y=-1, label=b) +\n        geom_text(x=-1.5, y=-2.25, label=B) +\n        geom_text(x=1.5, y=2, label=c) +\n        geom_text(x=0.5, y=0.75, label=C) +\n        geom_text(x=1.5, y=-1, label=d) +\n        geom_text(x=0.5, y=-2.25, label=D) +\n        geom_text(x=-1, y=3.3, label='links') +\n        geom_text(x=1, y=3.3, label='rechts') +\n        geom_text(x=-2.2, y=1.375, angle=90, label='oben') +\n        geom_text(x=-2.2, y=-1.625, angle=90, label='unten') +\n        geom_text(x=0 , y=4 , fontface=\"bold\", label='Spieler 2') +\n        geom_text(x=-2.7 , y=0 , angle=90 , fontface=\"bold\", label='Spieler 1') +\n        geom_segment(x=-2, xend=2, y=0, yend=0) +\n        geom_segment(x=-2, xend=2, y=3, yend=3) +\n        geom_segment(x=-2, xend=2, y=-3, yend=-3) +\n        geom_segment(x=-2, xend=-2, y=-3, yend=3) +\n        geom_segment(x=0 , xend=0 , y=-3 , yend=3) +\n        geom_segment(x=2 , xend=2 , y=-3 , yend=3) +\n        theme_void() +\n        labs(title='Auszahlungen in einem simultanen Spiel')\n    )\n\n    \nplot = create_plot()\n\nplot\n```\n\n::: {.cell-output .cell-output-display}\n```{=html}\n\n            <div id=\"rfXArg\"></div>\n            <script type=\"text/javascript\" data-lets-plot-script=\"library\">\n                if(!window.letsPlotCallQueue) {\n                    window.letsPlotCallQueue = [];\n                }; \n                window.letsPlotCall = function(f) {\n                    window.letsPlotCallQueue.push(f);\n                };\n                (function() {\n                    var script = document.createElement(\"script\");\n                    script.type = \"text/javascript\";\n                    script.src = \"https://cdn.jsdelivr.net/gh/JetBrains/lets-plot@v4.6.2/js-package/distr/lets-plot.min.js\";\n                    script.onload = function() {\n                        window.letsPlotCall = function(f) {f();};\n                        window.letsPlotCallQueue.forEach(function(f) {f();});\n                        window.letsPlotCallQueue = [];\n                        \n                    };\n                    script.onerror = function(event) {\n                        window.letsPlotCall = function(f) {};    // noop\n                        window.letsPlotCallQueue = [];\n                        var div = document.createElement(\"div\");\n                        div.style.color = 'darkred';\n                        div.textContent = 'Error loading Lets-Plot JS';\n                        document.getElementById(\"rfXArg\").appendChild(div);\n                    };\n                    var e = document.getElementById(\"rfXArg\");\n                    e.appendChild(script);\n                })()\n            </script>\n            \n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=5}\n```{=html}\n   <div id=\"8JB6sx\"></div>\n   <script type=\"text/javascript\" data-lets-plot-script=\"plot\">\n   \n   (function() {\n   // ----------\n   \n   const forceImmediateRender = false;\n   const responsive = false;\n   \n   let sizing = {\n       width_mode: \"MIN\",\n       height_mode: \"SCALED\",\n       width: null, \n       height: null \n   };\n   \n   const preferredWidth = document.body.dataset.letsPlotPreferredWidth;\n   if (preferredWidth !== undefined) {\n       sizing = {\n           width_mode: 'FIXED',\n           height_mode: 'SCALED',\n           width: parseFloat(preferredWidth)\n       };\n   }\n   \n   const containerDiv = document.getElementById(\"8JB6sx\");\n   let fig = null;\n   \n   function renderPlot() {\n       if (fig === null) {\n           const plotSpec = {\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"theme\":{\n\"name\":\"classic\",\n\"line\":\"blank\",\n\"axis\":\"blank\"\n},\n\"ggtitle\":{\n\"text\":\"Auszahlungen in einem simultanen Spiel\"\n},\n\"kind\":\"plot\",\n\"scales\":[],\n\"layers\":[{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-0.5,\n\"y\":2.0,\n\"label\":0.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-1.5,\n\"y\":0.75,\n\"label\":0.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-0.5,\n\"y\":-1.0,\n\"label\":1.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-1.5,\n\"y\":-2.25,\n\"label\":1.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":1.5,\n\"y\":2.0,\n\"label\":1.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":0.5,\n\"y\":0.75,\n\"label\":1.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":1.5,\n\"y\":-1.0,\n\"label\":0.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":0.5,\n\"y\":-2.25,\n\"label\":0.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-1.0,\n\"y\":3.3,\n\"label\":\"links\",\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":1.0,\n\"y\":3.3,\n\"label\":\"rechts\",\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.2,\n\"y\":1.375,\n\"angle\":90.0,\n\"label\":\"oben\",\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.2,\n\"y\":-1.625,\n\"angle\":90.0,\n\"label\":\"unten\",\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":0.0,\n\"y\":4.0,\n\"fontface\":\"bold\",\n\"label\":\"Spieler 2\",\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.7,\n\"y\":0.0,\n\"angle\":90.0,\n\"fontface\":\"bold\",\n\"label\":\"Spieler 1\",\n\"data\":{\n}\n},{\n\"geom\":\"segment\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.0,\n\"xend\":2.0,\n\"y\":0.0,\n\"yend\":0.0,\n\"data\":{\n}\n},{\n\"geom\":\"segment\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.0,\n\"xend\":2.0,\n\"y\":3.0,\n\"yend\":3.0,\n\"data\":{\n}\n},{\n\"geom\":\"segment\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.0,\n\"xend\":2.0,\n\"y\":-3.0,\n\"yend\":-3.0,\n\"data\":{\n}\n},{\n\"geom\":\"segment\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.0,\n\"xend\":-2.0,\n\"y\":-3.0,\n\"yend\":3.0,\n\"data\":{\n}\n},{\n\"geom\":\"segment\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":0.0,\n\"xend\":0.0,\n\"y\":-3.0,\n\"yend\":3.0,\n\"data\":{\n}\n},{\n\"geom\":\"segment\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":2.0,\n\"xend\":2.0,\n\"y\":-3.0,\n\"yend\":3.0,\n\"data\":{\n}\n}],\n\"metainfo_list\":[],\n\"spec_id\":\"3\"\n};\n           window.letsPlotCall(function() { fig = LetsPlot.buildPlotFromProcessedSpecs(plotSpec, containerDiv, sizing); });\n       } else {\n           fig.updateView({});\n       }\n   }\n   \n   const renderImmediately = \n       forceImmediateRender || (\n           sizing.width_mode === 'FIXED' && \n           (sizing.height_mode === 'FIXED' || sizing.height_mode === 'SCALED')\n       );\n   \n   if (renderImmediately) {\n       renderPlot();\n   }\n   \n   if (!renderImmediately || responsive) {\n       // Set up observer for initial sizing or continuous monitoring\n       var observer = new ResizeObserver(function(entries) {\n           for (let entry of entries) {\n               if (entry.contentBoxSize && \n                   entry.contentBoxSize[0].inlineSize > 0) {\n                   if (!responsive && observer) {\n                       observer.disconnect();\n                       observer = null;\n                   }\n                   renderPlot();\n                   if (!responsive) {\n                       break;\n                   }\n               }\n           }\n       });\n       \n       observer.observe(containerDiv);\n   }\n   \n   // ----------\n   })();\n   \n   </script>\n```\n:::\n:::\n\n\n::: {#631be2b2 .cell execution_count=6}\n``` {.python .cell-code}\n# Funktionen für Nash-Bedingungen\ndef is_ol_nash(A, B, a, c):\n  return \"ol\" if (A >= B) and (a >= c) else \"not_ol\"\n\ndef is_ul_nash(B, A, b, d):\n  return \"ul\" if (B >= A) and (b >= d) else \"not_ul\"\n\ndef is_or_nash(C, D, c, a):\n  return \"or\" if (C >= D) and (c >= a) else \"not_or\"\n\ndef is_ur_nash(D, C, d, b):\n  return \"ur\" if (D >= C) and (d >= b) else \"not_ur\"\n\n# Nash-Bedingungen überprüfen und Strings zuweisen\nCand_Nash_ol = is_ol_nash(A, B, a, c)\nCand_Nash_ul = is_ul_nash(B, A, b, d)\nCand_Nash_or = is_or_nash(C, D, c, a)\nCand_Nash_ur = is_ur_nash(D, C, d, b)\n\n# Ergebnisse kombinieren und NAs entfernen\nNash_GG = np.array([Cand_Nash_ol, Cand_Nash_ul, Cand_Nash_or, Cand_Nash_ur])\nNash_GG_filtered = []\nfor element in Nash_GG:\n  if element == \"ol\" or element == \"ul\" or element == \"or\" or element == \"ur\":\n    Nash_GG_filtered.append(element)\n\n# Ergebnis ausgeben\nprint(f\"Nash-Gleichgewicht(e) in reinen Strategien: {', '.join(Nash_GG_filtered)}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNash-Gleichgewicht(e) in reinen Strategien: ul, or\n```\n:::\n:::\n\n\n##### Chicken Game\n\n[![Chicken Game](figure/Chicken-Game-1.png){width=\"50%\"}]::\n\n::: {#ed34dab3 .cell execution_count=7}\n``` {.python .cell-code}\nimport numpy as np\n\nimport random\n\n# Zufällige Ganzzahlen zwischen 0 und 9 generieren\nA = random.randint(5, 7)\nB = random.randint(8, 9)\nC = random.randint(2, 4)\nD = random.randint(0, 1)\na = random.randint(5, 7)\nb = random.randint(2, 4)\nc = random.randint(8, 9)\nd = random.randint(0, 1)\n\n# Formatierte Bimatrix ausgeben\n# print(f\"     l    r\\n o  {A},{a}  {C},{c}\\n u  {B},{b}  {D},{d}\")\n\nplot = create_plot()\n\nplot\n```\n\n::: {.cell-output .cell-output-display}\n```{=html}\n\n            <div id=\"vJvSpk\"></div>\n            <script type=\"text/javascript\" data-lets-plot-script=\"library\">\n                if(!window.letsPlotCallQueue) {\n                    window.letsPlotCallQueue = [];\n                }; \n                window.letsPlotCall = function(f) {\n                    window.letsPlotCallQueue.push(f);\n                };\n                (function() {\n                    var script = document.createElement(\"script\");\n                    script.type = \"text/javascript\";\n                    script.src = \"https://cdn.jsdelivr.net/gh/JetBrains/lets-plot@v4.6.2/js-package/distr/lets-plot.min.js\";\n                    script.onload = function() {\n                        window.letsPlotCall = function(f) {f();};\n                        window.letsPlotCallQueue.forEach(function(f) {f();});\n                        window.letsPlotCallQueue = [];\n                        \n                    };\n                    script.onerror = function(event) {\n                        window.letsPlotCall = function(f) {};    // noop\n                        window.letsPlotCallQueue = [];\n                        var div = document.createElement(\"div\");\n                        div.style.color = 'darkred';\n                        div.textContent = 'Error loading Lets-Plot JS';\n                        document.getElementById(\"vJvSpk\").appendChild(div);\n                    };\n                    var e = document.getElementById(\"vJvSpk\");\n                    e.appendChild(script);\n                })()\n            </script>\n            \n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=7}\n```{=html}\n   <div id=\"55U63a\"></div>\n   <script type=\"text/javascript\" data-lets-plot-script=\"plot\">\n   \n   (function() {\n   // ----------\n   \n   const forceImmediateRender = false;\n   const responsive = false;\n   \n   let sizing = {\n       width_mode: \"MIN\",\n       height_mode: \"SCALED\",\n       width: null, \n       height: null \n   };\n   \n   const preferredWidth = document.body.dataset.letsPlotPreferredWidth;\n   if (preferredWidth !== undefined) {\n       sizing = {\n           width_mode: 'FIXED',\n           height_mode: 'SCALED',\n           width: parseFloat(preferredWidth)\n       };\n   }\n   \n   const containerDiv = document.getElementById(\"55U63a\");\n   let fig = null;\n   \n   function renderPlot() {\n       if (fig === null) {\n           const plotSpec = {\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"theme\":{\n\"name\":\"classic\",\n\"line\":\"blank\",\n\"axis\":\"blank\"\n},\n\"ggtitle\":{\n\"text\":\"Auszahlungen in einem simultanen Spiel\"\n},\n\"kind\":\"plot\",\n\"scales\":[],\n\"layers\":[{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-0.5,\n\"y\":2.0,\n\"label\":6.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-1.5,\n\"y\":0.75,\n\"label\":5.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-0.5,\n\"y\":-1.0,\n\"label\":2.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-1.5,\n\"y\":-2.25,\n\"label\":9.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":1.5,\n\"y\":2.0,\n\"label\":8.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":0.5,\n\"y\":0.75,\n\"label\":4.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":1.5,\n\"y\":-1.0,\n\"label\":0.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":0.5,\n\"y\":-2.25,\n\"label\":1.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-1.0,\n\"y\":3.3,\n\"label\":\"links\",\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":1.0,\n\"y\":3.3,\n\"label\":\"rechts\",\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.2,\n\"y\":1.375,\n\"angle\":90.0,\n\"label\":\"oben\",\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.2,\n\"y\":-1.625,\n\"angle\":90.0,\n\"label\":\"unten\",\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":0.0,\n\"y\":4.0,\n\"fontface\":\"bold\",\n\"label\":\"Spieler 2\",\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.7,\n\"y\":0.0,\n\"angle\":90.0,\n\"fontface\":\"bold\",\n\"label\":\"Spieler 1\",\n\"data\":{\n}\n},{\n\"geom\":\"segment\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.0,\n\"xend\":2.0,\n\"y\":0.0,\n\"yend\":0.0,\n\"data\":{\n}\n},{\n\"geom\":\"segment\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.0,\n\"xend\":2.0,\n\"y\":3.0,\n\"yend\":3.0,\n\"data\":{\n}\n},{\n\"geom\":\"segment\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.0,\n\"xend\":2.0,\n\"y\":-3.0,\n\"yend\":-3.0,\n\"data\":{\n}\n},{\n\"geom\":\"segment\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.0,\n\"xend\":-2.0,\n\"y\":-3.0,\n\"yend\":3.0,\n\"data\":{\n}\n},{\n\"geom\":\"segment\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":0.0,\n\"xend\":0.0,\n\"y\":-3.0,\n\"yend\":3.0,\n\"data\":{\n}\n},{\n\"geom\":\"segment\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":2.0,\n\"xend\":2.0,\n\"y\":-3.0,\n\"yend\":3.0,\n\"data\":{\n}\n}],\n\"metainfo_list\":[],\n\"spec_id\":\"4\"\n};\n           window.letsPlotCall(function() { fig = LetsPlot.buildPlotFromProcessedSpecs(plotSpec, containerDiv, sizing); });\n       } else {\n           fig.updateView({});\n       }\n   }\n   \n   const renderImmediately = \n       forceImmediateRender || (\n           sizing.width_mode === 'FIXED' && \n           (sizing.height_mode === 'FIXED' || sizing.height_mode === 'SCALED')\n       );\n   \n   if (renderImmediately) {\n       renderPlot();\n   }\n   \n   if (!renderImmediately || responsive) {\n       // Set up observer for initial sizing or continuous monitoring\n       var observer = new ResizeObserver(function(entries) {\n           for (let entry of entries) {\n               if (entry.contentBoxSize && \n                   entry.contentBoxSize[0].inlineSize > 0) {\n                   if (!responsive && observer) {\n                       observer.disconnect();\n                       observer = null;\n                   }\n                   renderPlot();\n                   if (!responsive) {\n                       break;\n                   }\n               }\n           }\n       });\n       \n       observer.observe(containerDiv);\n   }\n   \n   // ----------\n   })();\n   \n   </script>\n```\n:::\n:::\n\n\n::: {#524dcb52 .cell execution_count=8}\n``` {.python .cell-code}\n# Funktionen für Nash-Bedingungen\ndef is_ol_nash(A, B, a, c):\n  return \"ol\" if (A >= B) and (a >= c) else \"not_ol\"\n\ndef is_ul_nash(B, A, b, d):\n  return \"ul\" if (B >= A) and (b >= d) else \"not_ul\"\n\ndef is_or_nash(C, D, c, a):\n  return \"or\" if (C >= D) and (c >= a) else \"not_or\"\n\ndef is_ur_nash(D, C, d, b):\n  return \"ur\" if (D >= C) and (d >= b) else \"not_ur\"\n\n# Nash-Bedingungen überprüfen und Strings zuweisen\nCand_Nash_ol = is_ol_nash(A, B, a, c)\nCand_Nash_ul = is_ul_nash(B, A, b, d)\nCand_Nash_or = is_or_nash(C, D, c, a)\nCand_Nash_ur = is_ur_nash(D, C, d, b)\n\n# Ergebnisse kombinieren und NAs entfernen\nNash_GG = np.array([Cand_Nash_ol, Cand_Nash_ul, Cand_Nash_or, Cand_Nash_ur])\nNash_GG_filtered = []\nfor element in Nash_GG:\n  if element == \"ol\" or element == \"ul\" or element == \"or\" or element == \"ur\":\n    Nash_GG_filtered.append(element)\n\n# Ergebnis ausgeben\nprint(f\"Nash-Gleichgewicht(e) in reinen Strategien: {', '.join(Nash_GG_filtered)}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNash-Gleichgewicht(e) in reinen Strategien: ul, or\n```\n:::\n:::\n\n\n##### Geschlechterkampf\n\n[![Geschlechterkampf](figure/Geschlechterkampf-1.png){width=\"50%\"}]::\n\n::: {#f7ec9637 .cell execution_count=9}\n``` {.python .cell-code}\nimport numpy as np\n\nimport random\n\n# Zufällige Ganzzahlen zwischen 0 und 9 generieren\nA = random.randint(8, 9)\nB = random.randint(0, 2)\nC = random.randint(3, 5)\nD = random.randint(6, 7)\na = random.randint(6, 7)\nb = random.randint(0, 2)\nc = random.randint(3, 5)\nd = random.randint(8, 9)\n\n# Formatierte Bimatrix ausgeben\n# print(f\"     l    r\\n o  {A},{a}  {C},{c}\\n u  {B},{b}  {D},{d}\")\n\nplot = create_plot()\n\nplot\n```\n\n::: {.cell-output .cell-output-display}\n```{=html}\n\n            <div id=\"g5cfQj\"></div>\n            <script type=\"text/javascript\" data-lets-plot-script=\"library\">\n                if(!window.letsPlotCallQueue) {\n                    window.letsPlotCallQueue = [];\n                }; \n                window.letsPlotCall = function(f) {\n                    window.letsPlotCallQueue.push(f);\n                };\n                (function() {\n                    var script = document.createElement(\"script\");\n                    script.type = \"text/javascript\";\n                    script.src = \"https://cdn.jsdelivr.net/gh/JetBrains/lets-plot@v4.6.2/js-package/distr/lets-plot.min.js\";\n                    script.onload = function() {\n                        window.letsPlotCall = function(f) {f();};\n                        window.letsPlotCallQueue.forEach(function(f) {f();});\n                        window.letsPlotCallQueue = [];\n                        \n                    };\n                    script.onerror = function(event) {\n                        window.letsPlotCall = function(f) {};    // noop\n                        window.letsPlotCallQueue = [];\n                        var div = document.createElement(\"div\");\n                        div.style.color = 'darkred';\n                        div.textContent = 'Error loading Lets-Plot JS';\n                        document.getElementById(\"g5cfQj\").appendChild(div);\n                    };\n                    var e = document.getElementById(\"g5cfQj\");\n                    e.appendChild(script);\n                })()\n            </script>\n            \n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=9}\n```{=html}\n   <div id=\"svHMTF\"></div>\n   <script type=\"text/javascript\" data-lets-plot-script=\"plot\">\n   \n   (function() {\n   // ----------\n   \n   const forceImmediateRender = false;\n   const responsive = false;\n   \n   let sizing = {\n       width_mode: \"MIN\",\n       height_mode: \"SCALED\",\n       width: null, \n       height: null \n   };\n   \n   const preferredWidth = document.body.dataset.letsPlotPreferredWidth;\n   if (preferredWidth !== undefined) {\n       sizing = {\n           width_mode: 'FIXED',\n           height_mode: 'SCALED',\n           width: parseFloat(preferredWidth)\n       };\n   }\n   \n   const containerDiv = document.getElementById(\"svHMTF\");\n   let fig = null;\n   \n   function renderPlot() {\n       if (fig === null) {\n           const plotSpec = {\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"theme\":{\n\"name\":\"classic\",\n\"line\":\"blank\",\n\"axis\":\"blank\"\n},\n\"ggtitle\":{\n\"text\":\"Auszahlungen in einem simultanen Spiel\"\n},\n\"kind\":\"plot\",\n\"scales\":[],\n\"layers\":[{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-0.5,\n\"y\":2.0,\n\"label\":6.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-1.5,\n\"y\":0.75,\n\"label\":8.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-0.5,\n\"y\":-1.0,\n\"label\":0.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-1.5,\n\"y\":-2.25,\n\"label\":1.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":1.5,\n\"y\":2.0,\n\"label\":4.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":0.5,\n\"y\":0.75,\n\"label\":3.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":1.5,\n\"y\":-1.0,\n\"label\":9.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":0.5,\n\"y\":-2.25,\n\"label\":7.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-1.0,\n\"y\":3.3,\n\"label\":\"links\",\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":1.0,\n\"y\":3.3,\n\"label\":\"rechts\",\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.2,\n\"y\":1.375,\n\"angle\":90.0,\n\"label\":\"oben\",\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.2,\n\"y\":-1.625,\n\"angle\":90.0,\n\"label\":\"unten\",\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":0.0,\n\"y\":4.0,\n\"fontface\":\"bold\",\n\"label\":\"Spieler 2\",\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.7,\n\"y\":0.0,\n\"angle\":90.0,\n\"fontface\":\"bold\",\n\"label\":\"Spieler 1\",\n\"data\":{\n}\n},{\n\"geom\":\"segment\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.0,\n\"xend\":2.0,\n\"y\":0.0,\n\"yend\":0.0,\n\"data\":{\n}\n},{\n\"geom\":\"segment\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.0,\n\"xend\":2.0,\n\"y\":3.0,\n\"yend\":3.0,\n\"data\":{\n}\n},{\n\"geom\":\"segment\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.0,\n\"xend\":2.0,\n\"y\":-3.0,\n\"yend\":-3.0,\n\"data\":{\n}\n},{\n\"geom\":\"segment\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.0,\n\"xend\":-2.0,\n\"y\":-3.0,\n\"yend\":3.0,\n\"data\":{\n}\n},{\n\"geom\":\"segment\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":0.0,\n\"xend\":0.0,\n\"y\":-3.0,\n\"yend\":3.0,\n\"data\":{\n}\n},{\n\"geom\":\"segment\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":2.0,\n\"xend\":2.0,\n\"y\":-3.0,\n\"yend\":3.0,\n\"data\":{\n}\n}],\n\"metainfo_list\":[],\n\"spec_id\":\"5\"\n};\n           window.letsPlotCall(function() { fig = LetsPlot.buildPlotFromProcessedSpecs(plotSpec, containerDiv, sizing); });\n       } else {\n           fig.updateView({});\n       }\n   }\n   \n   const renderImmediately = \n       forceImmediateRender || (\n           sizing.width_mode === 'FIXED' && \n           (sizing.height_mode === 'FIXED' || sizing.height_mode === 'SCALED')\n       );\n   \n   if (renderImmediately) {\n       renderPlot();\n   }\n   \n   if (!renderImmediately || responsive) {\n       // Set up observer for initial sizing or continuous monitoring\n       var observer = new ResizeObserver(function(entries) {\n           for (let entry of entries) {\n               if (entry.contentBoxSize && \n                   entry.contentBoxSize[0].inlineSize > 0) {\n                   if (!responsive && observer) {\n                       observer.disconnect();\n                       observer = null;\n                   }\n                   renderPlot();\n                   if (!responsive) {\n                       break;\n                   }\n               }\n           }\n       });\n       \n       observer.observe(containerDiv);\n   }\n   \n   // ----------\n   })();\n   \n   </script>\n```\n:::\n:::\n\n\n::: {#d966e924 .cell execution_count=10}\n``` {.python .cell-code}\n# Funktionen für Nash-Bedingungen\ndef is_ol_nash(A, B, a, c):\n  return \"ol\" if (A >= B) and (a >= c) else \"not_ol\"\n\ndef is_ul_nash(B, A, b, d):\n  return \"ul\" if (B >= A) and (b >= d) else \"not_ul\"\n\ndef is_or_nash(C, D, c, a):\n  return \"or\" if (C >= D) and (c >= a) else \"not_or\"\n\ndef is_ur_nash(D, C, d, b):\n  return \"ur\" if (D >= C) and (d >= b) else \"not_ur\"\n\n# Nash-Bedingungen überprüfen und Strings zuweisen\nCand_Nash_ol = is_ol_nash(A, B, a, c)\nCand_Nash_ul = is_ul_nash(B, A, b, d)\nCand_Nash_or = is_or_nash(C, D, c, a)\nCand_Nash_ur = is_ur_nash(D, C, d, b)\n\n# Ergebnisse kombinieren und NAs entfernen\nNash_GG = np.array([Cand_Nash_ol, Cand_Nash_ul, Cand_Nash_or, Cand_Nash_ur])\nNash_GG_filtered = []\nfor element in Nash_GG:\n  if element == \"ol\" or element == \"ul\" or element == \"or\" or element == \"ur\":\n    Nash_GG_filtered.append(element)\n\n# Ergebnis ausgeben\nprint(f\"Nash-Gleichgewicht(e) in reinen Strategien: {', '.join(Nash_GG_filtered)}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNash-Gleichgewicht(e) in reinen Strategien: ol, ur\n```\n:::\n:::\n\n\n##### Gefangenendilemma\n\n[![Gefangenendilemma](figure/Gefangenendilemma-1.png){width=\"50%\"}]::\n\n::: {#dfe53156 .cell execution_count=11}\n``` {.python .cell-code}\nimport numpy as np\n\nimport random\n\n# Zufällige Ganzzahlen zwischen 0 und 9 generieren\nA = random.randint(5, 7)\nB = random.randint(8, 9)\nC = random.randint(0, 1)\nD = random.randint(2, 4)\na = random.randint(5, 7)\nb = random.randint(0, 1)\nc = random.randint(8, 9)\nd = random.randint(2, 4)\n\n# Formatierte Bimatrix ausgeben\n# print(f\"     l    r\\n o  {A},{a}  {C},{c}\\n u  {B},{b}  {D},{d}\")\n\nplot = create_plot()\n\nplot\n```\n\n::: {.cell-output .cell-output-display}\n```{=html}\n\n            <div id=\"1cXtvH\"></div>\n            <script type=\"text/javascript\" data-lets-plot-script=\"library\">\n                if(!window.letsPlotCallQueue) {\n                    window.letsPlotCallQueue = [];\n                }; \n                window.letsPlotCall = function(f) {\n                    window.letsPlotCallQueue.push(f);\n                };\n                (function() {\n                    var script = document.createElement(\"script\");\n                    script.type = \"text/javascript\";\n                    script.src = \"https://cdn.jsdelivr.net/gh/JetBrains/lets-plot@v4.6.2/js-package/distr/lets-plot.min.js\";\n                    script.onload = function() {\n                        window.letsPlotCall = function(f) {f();};\n                        window.letsPlotCallQueue.forEach(function(f) {f();});\n                        window.letsPlotCallQueue = [];\n                        \n                    };\n                    script.onerror = function(event) {\n                        window.letsPlotCall = function(f) {};    // noop\n                        window.letsPlotCallQueue = [];\n                        var div = document.createElement(\"div\");\n                        div.style.color = 'darkred';\n                        div.textContent = 'Error loading Lets-Plot JS';\n                        document.getElementById(\"1cXtvH\").appendChild(div);\n                    };\n                    var e = document.getElementById(\"1cXtvH\");\n                    e.appendChild(script);\n                })()\n            </script>\n            \n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=11}\n```{=html}\n   <div id=\"ICuPm3\"></div>\n   <script type=\"text/javascript\" data-lets-plot-script=\"plot\">\n   \n   (function() {\n   // ----------\n   \n   const forceImmediateRender = false;\n   const responsive = false;\n   \n   let sizing = {\n       width_mode: \"MIN\",\n       height_mode: \"SCALED\",\n       width: null, \n       height: null \n   };\n   \n   const preferredWidth = document.body.dataset.letsPlotPreferredWidth;\n   if (preferredWidth !== undefined) {\n       sizing = {\n           width_mode: 'FIXED',\n           height_mode: 'SCALED',\n           width: parseFloat(preferredWidth)\n       };\n   }\n   \n   const containerDiv = document.getElementById(\"ICuPm3\");\n   let fig = null;\n   \n   function renderPlot() {\n       if (fig === null) {\n           const plotSpec = {\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"theme\":{\n\"name\":\"classic\",\n\"line\":\"blank\",\n\"axis\":\"blank\"\n},\n\"ggtitle\":{\n\"text\":\"Auszahlungen in einem simultanen Spiel\"\n},\n\"kind\":\"plot\",\n\"scales\":[],\n\"layers\":[{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-0.5,\n\"y\":2.0,\n\"label\":7.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-1.5,\n\"y\":0.75,\n\"label\":5.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-0.5,\n\"y\":-1.0,\n\"label\":1.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-1.5,\n\"y\":-2.25,\n\"label\":8.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":1.5,\n\"y\":2.0,\n\"label\":9.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":0.5,\n\"y\":0.75,\n\"label\":1.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":1.5,\n\"y\":-1.0,\n\"label\":3.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":0.5,\n\"y\":-2.25,\n\"label\":3.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-1.0,\n\"y\":3.3,\n\"label\":\"links\",\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":1.0,\n\"y\":3.3,\n\"label\":\"rechts\",\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.2,\n\"y\":1.375,\n\"angle\":90.0,\n\"label\":\"oben\",\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.2,\n\"y\":-1.625,\n\"angle\":90.0,\n\"label\":\"unten\",\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":0.0,\n\"y\":4.0,\n\"fontface\":\"bold\",\n\"label\":\"Spieler 2\",\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.7,\n\"y\":0.0,\n\"angle\":90.0,\n\"fontface\":\"bold\",\n\"label\":\"Spieler 1\",\n\"data\":{\n}\n},{\n\"geom\":\"segment\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.0,\n\"xend\":2.0,\n\"y\":0.0,\n\"yend\":0.0,\n\"data\":{\n}\n},{\n\"geom\":\"segment\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.0,\n\"xend\":2.0,\n\"y\":3.0,\n\"yend\":3.0,\n\"data\":{\n}\n},{\n\"geom\":\"segment\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.0,\n\"xend\":2.0,\n\"y\":-3.0,\n\"yend\":-3.0,\n\"data\":{\n}\n},{\n\"geom\":\"segment\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.0,\n\"xend\":-2.0,\n\"y\":-3.0,\n\"yend\":3.0,\n\"data\":{\n}\n},{\n\"geom\":\"segment\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":0.0,\n\"xend\":0.0,\n\"y\":-3.0,\n\"yend\":3.0,\n\"data\":{\n}\n},{\n\"geom\":\"segment\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":2.0,\n\"xend\":2.0,\n\"y\":-3.0,\n\"yend\":3.0,\n\"data\":{\n}\n}],\n\"metainfo_list\":[],\n\"spec_id\":\"6\"\n};\n           window.letsPlotCall(function() { fig = LetsPlot.buildPlotFromProcessedSpecs(plotSpec, containerDiv, sizing); });\n       } else {\n           fig.updateView({});\n       }\n   }\n   \n   const renderImmediately = \n       forceImmediateRender || (\n           sizing.width_mode === 'FIXED' && \n           (sizing.height_mode === 'FIXED' || sizing.height_mode === 'SCALED')\n       );\n   \n   if (renderImmediately) {\n       renderPlot();\n   }\n   \n   if (!renderImmediately || responsive) {\n       // Set up observer for initial sizing or continuous monitoring\n       var observer = new ResizeObserver(function(entries) {\n           for (let entry of entries) {\n               if (entry.contentBoxSize && \n                   entry.contentBoxSize[0].inlineSize > 0) {\n                   if (!responsive && observer) {\n                       observer.disconnect();\n                       observer = null;\n                   }\n                   renderPlot();\n                   if (!responsive) {\n                       break;\n                   }\n               }\n           }\n       });\n       \n       observer.observe(containerDiv);\n   }\n   \n   // ----------\n   })();\n   \n   </script>\n```\n:::\n:::\n\n\n::: {#d8f7d48b .cell execution_count=12}\n``` {.python .cell-code}\n# Funktionen für Nash-Bedingungen\ndef is_ol_nash(A, B, a, c):\n  return \"ol\" if (A >= B) and (a >= c) else \"not_ol\"\n\ndef is_ul_nash(B, A, b, d):\n  return \"ul\" if (B >= A) and (b >= d) else \"not_ul\"\n\ndef is_or_nash(C, D, c, a):\n  return \"or\" if (C >= D) and (c >= a) else \"not_or\"\n\ndef is_ur_nash(D, C, d, b):\n  return \"ur\" if (D >= C) and (d >= b) else \"not_ur\"\n\n# Nash-Bedingungen überprüfen und Strings zuweisen\nCand_Nash_ol = is_ol_nash(A, B, a, c)\nCand_Nash_ul = is_ul_nash(B, A, b, d)\nCand_Nash_or = is_or_nash(C, D, c, a)\nCand_Nash_ur = is_ur_nash(D, C, d, b)\n\n# Ergebnisse kombinieren und NAs entfernen\nNash_GG = np.array([Cand_Nash_ol, Cand_Nash_ul, Cand_Nash_or, Cand_Nash_ur])\nNash_GG_filtered = []\nfor element in Nash_GG:\n  if element == \"ol\" or element == \"ul\" or element == \"or\" or element == \"ur\":\n    Nash_GG_filtered.append(element)\n\n# Ergebnis ausgeben\nprint(f\"Nash-Gleichgewicht(e) in reinen Strategien: {', '.join(Nash_GG_filtered)}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNash-Gleichgewicht(e) in reinen Strategien: ur\n```\n:::\n:::\n\n\n##### Spiel ohne Gleichgewicht\n\n::: {#d3daa7aa .cell execution_count=13}\n``` {.python .cell-code}\nimport numpy as np\nimport random\n\nwhile True:\n    A = random.randint(0, 9)\n    a = random.randint(0, 9)\n    B = random.randint(0, 9)\n    b = random.randint(0, 9)\n    C = random.randint(0, 9)\n    c = random.randint(0, 9)\n    D = random.randint(0, 9)\n    d = random.randint(0, 9)\n\n    # Bedingungen prüfen\n    cond1 = (A >= B) and (a >= c)\n    cond2 = (B >= A) and (b >= d)\n    cond3 = (C >= D) and (c >= a)\n    cond4 = (D >= C) and (d >= b)\n\n    # Wenn keine Bedingung erfüllt ist, Schleife beenden\n    if not (cond1 or cond2 or cond3 or cond4):\n        break\n\nplot = create_plot()\n\nplot\n```\n\n::: {.cell-output .cell-output-display}\n```{=html}\n\n            <div id=\"EljICy\"></div>\n            <script type=\"text/javascript\" data-lets-plot-script=\"library\">\n                if(!window.letsPlotCallQueue) {\n                    window.letsPlotCallQueue = [];\n                }; \n                window.letsPlotCall = function(f) {\n                    window.letsPlotCallQueue.push(f);\n                };\n                (function() {\n                    var script = document.createElement(\"script\");\n                    script.type = \"text/javascript\";\n                    script.src = \"https://cdn.jsdelivr.net/gh/JetBrains/lets-plot@v4.6.2/js-package/distr/lets-plot.min.js\";\n                    script.onload = function() {\n                        window.letsPlotCall = function(f) {f();};\n                        window.letsPlotCallQueue.forEach(function(f) {f();});\n                        window.letsPlotCallQueue = [];\n                        \n                    };\n                    script.onerror = function(event) {\n                        window.letsPlotCall = function(f) {};    // noop\n                        window.letsPlotCallQueue = [];\n                        var div = document.createElement(\"div\");\n                        div.style.color = 'darkred';\n                        div.textContent = 'Error loading Lets-Plot JS';\n                        document.getElementById(\"EljICy\").appendChild(div);\n                    };\n                    var e = document.getElementById(\"EljICy\");\n                    e.appendChild(script);\n                })()\n            </script>\n            \n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=13}\n```{=html}\n   <div id=\"fKxXMa\"></div>\n   <script type=\"text/javascript\" data-lets-plot-script=\"plot\">\n   \n   (function() {\n   // ----------\n   \n   const forceImmediateRender = false;\n   const responsive = false;\n   \n   let sizing = {\n       width_mode: \"MIN\",\n       height_mode: \"SCALED\",\n       width: null, \n       height: null \n   };\n   \n   const preferredWidth = document.body.dataset.letsPlotPreferredWidth;\n   if (preferredWidth !== undefined) {\n       sizing = {\n           width_mode: 'FIXED',\n           height_mode: 'SCALED',\n           width: parseFloat(preferredWidth)\n       };\n   }\n   \n   const containerDiv = document.getElementById(\"fKxXMa\");\n   let fig = null;\n   \n   function renderPlot() {\n       if (fig === null) {\n           const plotSpec = {\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"theme\":{\n\"name\":\"classic\",\n\"line\":\"blank\",\n\"axis\":\"blank\"\n},\n\"ggtitle\":{\n\"text\":\"Auszahlungen in einem simultanen Spiel\"\n},\n\"kind\":\"plot\",\n\"scales\":[],\n\"layers\":[{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-0.5,\n\"y\":2.0,\n\"label\":8.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-1.5,\n\"y\":0.75,\n\"label\":6.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-0.5,\n\"y\":-1.0,\n\"label\":0.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-1.5,\n\"y\":-2.25,\n\"label\":8.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":1.5,\n\"y\":2.0,\n\"label\":7.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":0.5,\n\"y\":0.75,\n\"label\":4.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":1.5,\n\"y\":-1.0,\n\"label\":8.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":0.5,\n\"y\":-2.25,\n\"label\":3.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-1.0,\n\"y\":3.3,\n\"label\":\"links\",\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":1.0,\n\"y\":3.3,\n\"label\":\"rechts\",\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.2,\n\"y\":1.375,\n\"angle\":90.0,\n\"label\":\"oben\",\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.2,\n\"y\":-1.625,\n\"angle\":90.0,\n\"label\":\"unten\",\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":0.0,\n\"y\":4.0,\n\"fontface\":\"bold\",\n\"label\":\"Spieler 2\",\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.7,\n\"y\":0.0,\n\"angle\":90.0,\n\"fontface\":\"bold\",\n\"label\":\"Spieler 1\",\n\"data\":{\n}\n},{\n\"geom\":\"segment\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.0,\n\"xend\":2.0,\n\"y\":0.0,\n\"yend\":0.0,\n\"data\":{\n}\n},{\n\"geom\":\"segment\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.0,\n\"xend\":2.0,\n\"y\":3.0,\n\"yend\":3.0,\n\"data\":{\n}\n},{\n\"geom\":\"segment\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.0,\n\"xend\":2.0,\n\"y\":-3.0,\n\"yend\":-3.0,\n\"data\":{\n}\n},{\n\"geom\":\"segment\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.0,\n\"xend\":-2.0,\n\"y\":-3.0,\n\"yend\":3.0,\n\"data\":{\n}\n},{\n\"geom\":\"segment\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":0.0,\n\"xend\":0.0,\n\"y\":-3.0,\n\"yend\":3.0,\n\"data\":{\n}\n},{\n\"geom\":\"segment\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":2.0,\n\"xend\":2.0,\n\"y\":-3.0,\n\"yend\":3.0,\n\"data\":{\n}\n}],\n\"metainfo_list\":[],\n\"spec_id\":\"7\"\n};\n           window.letsPlotCall(function() { fig = LetsPlot.buildPlotFromProcessedSpecs(plotSpec, containerDiv, sizing); });\n       } else {\n           fig.updateView({});\n       }\n   }\n   \n   const renderImmediately = \n       forceImmediateRender || (\n           sizing.width_mode === 'FIXED' && \n           (sizing.height_mode === 'FIXED' || sizing.height_mode === 'SCALED')\n       );\n   \n   if (renderImmediately) {\n       renderPlot();\n   }\n   \n   if (!renderImmediately || responsive) {\n       // Set up observer for initial sizing or continuous monitoring\n       var observer = new ResizeObserver(function(entries) {\n           for (let entry of entries) {\n               if (entry.contentBoxSize && \n                   entry.contentBoxSize[0].inlineSize > 0) {\n                   if (!responsive && observer) {\n                       observer.disconnect();\n                       observer = null;\n                   }\n                   renderPlot();\n                   if (!responsive) {\n                       break;\n                   }\n               }\n           }\n       });\n       \n       observer.observe(containerDiv);\n   }\n   \n   // ----------\n   })();\n   \n   </script>\n```\n:::\n:::\n\n\n::: {#45e92a46 .cell execution_count=14}\n``` {.python .cell-code}\n# Nash-Bedingungen überprüfen und Strings zuweisen\nCand_Nash_ol = is_ol_nash(A, B, a, c)\nCand_Nash_ul = is_ul_nash(B, A, b, d)\nCand_Nash_or = is_or_nash(C, D, c, a)\nCand_Nash_ur = is_ur_nash(D, C, d, b)\n\n# Ergebnisse kombinieren und NAs entfernen\nNash_GG = np.array([Cand_Nash_ol, Cand_Nash_ul, Cand_Nash_or, Cand_Nash_ur])\nNash_GG_filtered = []\nfor element in Nash_GG:\n  if element == \"ol\" or element == \"ul\" or element == \"or\" or element == \"ur\":\n    Nash_GG_filtered.append(element)\n\n# Ergebnis ausgeben\nprint(f\"Nash-Gleichgewicht(e) in reinen Strategien: {', '.join(Nash_GG_filtered)}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNash-Gleichgewicht(e) in reinen Strategien: \n```\n:::\n:::\n\n\n#### Wiederholte Spiele\n\n-   Ausgangspunkt Gefangenendilemma mit $B>A>D>C$ und $c>a>d>b$\n\n- Nash-Gleichgewicht dann unten rechts mit der Auszahlung D, d\n\n- Effizient wäre oben links mit Ausuahlung A, a\n\n- Tit for Tat: Kooperiere in der ersten Runde, erwidere danach die Strategiewahl des Gegenspielers reziprok\n\n- Dadurch \"Bestrafung\" für unkooperatives Verhalten möglich\n\n- Funktioniert das immer?\n\n- Funktioniert nicht bei bekannter endlicher Anzahl von Runden\n\n- In jeder Runde wird mit der Wahrscheinlichkeit $p$ eine weitere Runde gespielt.\n\n- Erwartungswert der Kooperationsgeflecht für $T$ Perioden (die Annahme einer endlichen Anzahl von Perioden wird gleich wieder aufgegeben)\n\n  $E^1_k=\\sum_{t=0}^T A \\times p^t$\n\n  Hilfsüberlegung: $(1-p)E^1_k = (1-p)\\sum_{t=0}^T A \\times p^t=A(\\sum_{t=0}^T p^t - \\sum_{t=0}^T p^{t+1})$\n  \n$=A(\\sum_{t=0}^T p^t - \\sum_{t=1}^{T+1}p^{t})$\n\n$= A(1-p^{T+1})$\n\n$\\iff E^1_k=\\frac{A(1-p^{T+1})}{1-p}$\n\n  $$\\boxed{\\lim_{T \\to \\infty}{E^1_k}=\\frac{A}{1-p}}$$\n\n-   Erwartungswert der Nicht-Kooperation für Spieler 1: $E^1_{nk}= B+ \\frac{D}{1-p}-D$\n\n-   Erwartungswert der Kooperation für Spieler 2: $E^2_k= \\frac{a}{1-p}$\n\n-   Erwartungswert der Nicht-Kooperation für Spieler 2: $E^2_{nk}= c+ \\frac{d}{1-p}-d$\n\n-   Kooperation durch Spieler 1 wenn $p\\geq \\frac{B-A}{B-D}$\n\n-   Kooperation durch Spieler 2 wenn $p\\geq \\frac{c-a}{c-d}$\n\n::: {#1bca9047 .cell execution_count=15}\n``` {.python .cell-code}\nfrom sympy import Symbol, solve, Eq\n\nA = Symbol('A')\nB = Symbol('B')\nC = Symbol('C')\nD = Symbol('D')\na = Symbol('a')\nb = Symbol('b')\nc = Symbol('c')\nd = Symbol('d')\np = Symbol('p')\n\n# Ungleichung aufstellen\n\nE_1K = A/(1-p)\n\n\nE_1NK = B+ D/(1-p)-D\n\n\nBedingung = Eq(E_1K, E_1NK)\n\n\nsol1=solve(Bedingung, p) # wie löse ich das als Ungleichung?\n\nprint(sol1)\n\nE_2K = a/(1-p)\n\nE_2NK = c+ d/(1-p) -d\n\nBedingung = Eq(E_2K, E_2NK)\n\nsol2 = solve(Bedingung, p)\nprint(sol2)\n```\n:::\n\n\n::: {#3e1f270f .cell execution_count=16}\n``` {.python .cell-code}\nimport numpy as np\n\nimport random\n\n# Zufällige Ganzzahlen zwischen 0 und 9 generieren\nA = random.randint(5, 7)\nB = random.randint(8, 9)\nC = random.randint(0, 1)\nD = random.randint(2, 4)\na = random.randint(5, 8)\nb = random.randint(0, 1)\nc = random.randint(8, 9)\nd = random.randint(2, 4)\n\n# Formatierte Bimatrix ausgeben\nprint(\"    l   r\")\nprint(f\"o  {A},{a}  {C},{c}\")\nprint(f\"u  {B},{b}  {D},{d}\")\n\n\n# Funktionen für Nash-Bedingungen\ndef is_ol_nash(A, B, a, c):\n  return \"ol\" if (A >= B) and (a >= c) else \"not_ol\"\n\ndef is_ul_nash(B, A, b, d):\n  return \"ul\" if (B >= A) and (b >= d) else \"not_ul\"\n\ndef is_or_nash(C, D, c, a):\n  return \"or\" if (C >= D) and (c >= a) else \"not_or\"\n\ndef is_ur_nash(D, C, d, b):\n  return \"ur\" if (D >= C) and (d >= b) else \"not_ur\"\n\n# Nash-Bedingungen überprüfen und Strings zuweisen\nCand_Nash_ol = is_ol_nash(A, B, a, c)\nCand_Nash_ul = is_ul_nash(B, A, b, d)\nCand_Nash_or = is_or_nash(C, D, c, a)\nCand_Nash_ur = is_ur_nash(D, C, d, b)\n\n# Ergebnisse kombinieren und NAs entfernen\nNash_GG = np.array([Cand_Nash_ol, Cand_Nash_ul, Cand_Nash_or, Cand_Nash_ur])\nNash_GG_filtered = []\nfor element in Nash_GG:\n  if element == \"ol\" or element == \"ul\" or element == \"or\" or element == \"ur\":\n    Nash_GG_filtered.append(element)\n\n# Ergebnis ausgeben\nprint(Nash_GG_filtered)\n\n# Kritisches p für Kooperation\n\np_krit = (B-A)/(B - D)\n#print(round(p_krit,3))\nprint(f\"Für Kooperation durch Spieler 1 muss die Wahrscheinlichkeit für eine weitere Runde mindestens {str(round(p_krit,3)).replace('.',',')} betragen.\")\n\np_krit = (c-a)/(c - d)\n#print(round(p_krit,3))\nprint(f\"Für Kooperation durch Spieler 2 muss die Wahrscheinlichkeit für eine weitere Runde mindestens {str(round(p_krit,3)).replace('.',',')} betragen.\")\n```\n:::\n\n\n#### Trembling Hand\n\n::: {#25dae637 .cell message='false' execution_count=17}\n``` {.python .cell-code}\n# Python\n\nimport random\n\nrandom.seed(246)\n\nwhile True:\n    A = random.randint(0, 9)\n    a = random.randint(0, 9)\n    B = random.randint(0, 9)\n    b = random.randint(0, 9)\n   # C = random.randint(0, 9)\n    C=-20\n    c = random.randint(0, 9)\n    D = random.randint(0, 9)\n    d = random.randint(0, 9)\n\n    # Bedingungen prüfen\n    cond1 = (A > B) and (a >= c) # NGG ol\n    cond2 = (D  > C) and (A > D) and (a > d)\n\n    # Wenn beide Bedingung erfüllt ist, Schleife beenden\n    if  (cond1 and cond2):\n        break\n\n# Ausgabe der Zahlen\n#print(f\"A={A}, a={a}, B={B}, b={b}, C={C}, c={c}, D={D}, d={d}\")\n\n# Formatierte Bimatrix ausgeben\n#print(\"    l   r\")\n#print(f\"o  {A},{a}  {C},{c}\")\n#print(f\"u  {B},{b}  {D},{d}\")\n\n\nplot = create_plot()\n\nplot\n\n```\n\n::: {.cell-output .cell-output-display}\n```{=html}\n\n            <div id=\"dnTgdY\"></div>\n            <script type=\"text/javascript\" data-lets-plot-script=\"library\">\n                if(!window.letsPlotCallQueue) {\n                    window.letsPlotCallQueue = [];\n                }; \n                window.letsPlotCall = function(f) {\n                    window.letsPlotCallQueue.push(f);\n                };\n                (function() {\n                    var script = document.createElement(\"script\");\n                    script.type = \"text/javascript\";\n                    script.src = \"https://cdn.jsdelivr.net/gh/JetBrains/lets-plot@v4.6.2/js-package/distr/lets-plot.min.js\";\n                    script.onload = function() {\n                        window.letsPlotCall = function(f) {f();};\n                        window.letsPlotCallQueue.forEach(function(f) {f();});\n                        window.letsPlotCallQueue = [];\n                        \n                    };\n                    script.onerror = function(event) {\n                        window.letsPlotCall = function(f) {};    // noop\n                        window.letsPlotCallQueue = [];\n                        var div = document.createElement(\"div\");\n                        div.style.color = 'darkred';\n                        div.textContent = 'Error loading Lets-Plot JS';\n                        document.getElementById(\"dnTgdY\").appendChild(div);\n                    };\n                    var e = document.getElementById(\"dnTgdY\");\n                    e.appendChild(script);\n                })()\n            </script>\n            \n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=15}\n```{=html}\n   <div id=\"jo9htF\"></div>\n   <script type=\"text/javascript\" data-lets-plot-script=\"plot\">\n   \n   (function() {\n   // ----------\n   \n   const forceImmediateRender = false;\n   const responsive = false;\n   \n   let sizing = {\n       width_mode: \"MIN\",\n       height_mode: \"SCALED\",\n       width: null, \n       height: null \n   };\n   \n   const preferredWidth = document.body.dataset.letsPlotPreferredWidth;\n   if (preferredWidth !== undefined) {\n       sizing = {\n           width_mode: 'FIXED',\n           height_mode: 'SCALED',\n           width: parseFloat(preferredWidth)\n       };\n   }\n   \n   const containerDiv = document.getElementById(\"jo9htF\");\n   let fig = null;\n   \n   function renderPlot() {\n       if (fig === null) {\n           const plotSpec = {\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"theme\":{\n\"name\":\"classic\",\n\"line\":\"blank\",\n\"axis\":\"blank\"\n},\n\"ggtitle\":{\n\"text\":\"Auszahlungen in einem simultanen Spiel\"\n},\n\"kind\":\"plot\",\n\"scales\":[],\n\"layers\":[{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-0.5,\n\"y\":2.0,\n\"label\":4.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-1.5,\n\"y\":0.75,\n\"label\":8.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-0.5,\n\"y\":-1.0,\n\"label\":2.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-1.5,\n\"y\":-2.25,\n\"label\":7.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":1.5,\n\"y\":2.0,\n\"label\":1.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":0.5,\n\"y\":0.75,\n\"label\":-20.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":1.5,\n\"y\":-1.0,\n\"label\":0.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":0.5,\n\"y\":-2.25,\n\"label\":0.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-1.0,\n\"y\":3.3,\n\"label\":\"links\",\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":1.0,\n\"y\":3.3,\n\"label\":\"rechts\",\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.2,\n\"y\":1.375,\n\"angle\":90.0,\n\"label\":\"oben\",\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.2,\n\"y\":-1.625,\n\"angle\":90.0,\n\"label\":\"unten\",\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":0.0,\n\"y\":4.0,\n\"fontface\":\"bold\",\n\"label\":\"Spieler 2\",\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.7,\n\"y\":0.0,\n\"angle\":90.0,\n\"fontface\":\"bold\",\n\"label\":\"Spieler 1\",\n\"data\":{\n}\n},{\n\"geom\":\"segment\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.0,\n\"xend\":2.0,\n\"y\":0.0,\n\"yend\":0.0,\n\"data\":{\n}\n},{\n\"geom\":\"segment\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.0,\n\"xend\":2.0,\n\"y\":3.0,\n\"yend\":3.0,\n\"data\":{\n}\n},{\n\"geom\":\"segment\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.0,\n\"xend\":2.0,\n\"y\":-3.0,\n\"yend\":-3.0,\n\"data\":{\n}\n},{\n\"geom\":\"segment\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.0,\n\"xend\":-2.0,\n\"y\":-3.0,\n\"yend\":3.0,\n\"data\":{\n}\n},{\n\"geom\":\"segment\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":0.0,\n\"xend\":0.0,\n\"y\":-3.0,\n\"yend\":3.0,\n\"data\":{\n}\n},{\n\"geom\":\"segment\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":2.0,\n\"xend\":2.0,\n\"y\":-3.0,\n\"yend\":3.0,\n\"data\":{\n}\n}],\n\"metainfo_list\":[],\n\"spec_id\":\"8\"\n};\n           window.letsPlotCall(function() { fig = LetsPlot.buildPlotFromProcessedSpecs(plotSpec, containerDiv, sizing); });\n       } else {\n           fig.updateView({});\n       }\n   }\n   \n   const renderImmediately = \n       forceImmediateRender || (\n           sizing.width_mode === 'FIXED' && \n           (sizing.height_mode === 'FIXED' || sizing.height_mode === 'SCALED')\n       );\n   \n   if (renderImmediately) {\n       renderPlot();\n   }\n   \n   if (!renderImmediately || responsive) {\n       // Set up observer for initial sizing or continuous monitoring\n       var observer = new ResizeObserver(function(entries) {\n           for (let entry of entries) {\n               if (entry.contentBoxSize && \n                   entry.contentBoxSize[0].inlineSize > 0) {\n                   if (!responsive && observer) {\n                       observer.disconnect();\n                       observer = null;\n                   }\n                   renderPlot();\n                   if (!responsive) {\n                       break;\n                   }\n               }\n           }\n       });\n       \n       observer.observe(containerDiv);\n   }\n   \n   // ----------\n   })();\n   \n   </script>\n```\n:::\n:::\n\n\n-   Idee: Manche Nash-Gleichgewichte sind riskant\n\n-   Wenn der Gegenspieler \"versehentlich\" eine falsche Strategie spielt, dann macht man evtl hohe Verluste\n\n-   Wie hoch darf die Fehlerwahrscheinlichkeit des Gegenspielers sein, damit das Nash-Gleichgewicht noch die richtige Strategie impliziert?\n\nAngenommen, beide Spieler streben ein Nash-Gleichgewicht oben links an\n\n**Für Spieler 1 muss dann gelten**\n\n$E_o\\geq E_u$\n\nWenn er davon ausgeht, dass Spieler 2 mit einer Wahrscheinlichkeit von $p$ versehentlich rechts statt links spielt, heißt das\n\n$(1-p)A+pC \\geq (1-p)B+pD$\n\n$\\iff A-pA+pC\\geq B-pB+pD$\n\n$\\iff A-p(A-C) \\geq B-p(B-D)$\n\n$\\iff p(B-D)-p(A-C) \\geq B-A$\n\n$\\iff p(B-D-A+C)\\geq B-A$\n\nmit $(B-D-A+C) <0$\n\n$\\iff p \\leq \\frac{B-A}{B-A-D+C}=\\frac{A-B}{A-B-C+D}$\n\n**Für Spieler 2 muss dann gelten**\n\n$E_l\\geq E_r$\n\n$(1-p)a+pb \\geq (1-p)c+pd$\n\n$\\iff a-pa+pb \\geq c-pc+pd$\n\n$\\iff a-p(a-b) \\geq c-p(c-d)$\n\n$\\iff p(c-d)-p(a-b) \\geq c-a$\n\n$\\iff p(c-d-a+b) \\geq c-a$\n\nmit $(c-d-a+b)\\neq 0$\n\n$p \\leq \\frac{c-a}{(c-d-a+b)}=\\frac{a-c}{(a-b-c+d)}$\n\n::: {#dfdb521b .cell execution_count=18}\n``` {.python .cell-code}\n# Wahrscheinlichkeiten ausrechnen\n\nfrom sympy import Symbol, solve, Eq\n\nsymbols = [Symbol(name) for name in 'ABCDabcdp']\nA, B, C, D, a, b, c, d, p = symbols  # Entpacken und als separate Variablen speichern\n\n# Beide streben ol an\n\nE_o= (1-p)*A+p*C\n\nE_u= (1-p)*B + p*D\n\nsol = solve(Eq(E_o, E_u), p)\nprint(sol)\n\nE_l = (1-p)*a + p*b\nE_r = (1-p)*c + p*d\n\nsol = solve(Eq(E_l, E_r),p)\nprint(sol)\n```\n:::\n\n\n### Gemischte Strategien\n\n- Wenn es entweder kein Nash-Gleichgewicht (in reinen Strategien) gibt oder mehrere Nash-Gleichgewichte, dann lässt sich das Handeln der Spielenden nicht gut vorhersagen\n\n- Aus der Perspektive jedes Spielenden ist das Handeln des Gegenübers eine Zufallsvariable. Mit einer bestimmten Wahrscheinlichkeit wählt das Gegenüber eine seiner Strategien.\n\n- Den Zufall kann man aber näher charakterisieren, wenn man sich überlegt, **welche Wahrscheinlichkeiten ein rationales Gegenüber wählen würde**.\n\n- Ein rationales Gegenüber wählt die Wahrscheinlichkeiten so, dass der spielende Akteur keine Möglichkeit mehr hat, seine Situation durch die Wahl seiner Strategie zu verbessern. \n- Jede spielende Person wählt die Wahrscheinlichkeiten für ihre Handlung also so, dass das jeweilige Gegenüber indifferent ist in der Wahl seiner Handlungen.\n\n- Es muss also gelten: $$E_o=E_u$$\n$$\\iff p_l A+(1-p_l)C=p_lB+(1-p_l)D$$\n\n\n$$\\iff p_l A + C-p_lC=p_lB+D-p_lD$$\n\n$$\\iff p_l(A-C)+C=p_l(B-D)+D$$\n\n$$\\iff p_l(A-C-B+D)=D-C$$\n$$\\boxed{p_l=\\frac{D-C}{A-B-C+D}}$$\n$$E_l=E_r$$\n\n$$\\iff p_o a+(1-p_o)b=p_o c + (1-p_o)d$$\n\n$$\\iff p_o a+b-p_ob=p_oc+d-p_od$$\n$$\\iff p_o(a-b)+b=p_o(c-d)+d$$\n\n$$\\iff p_o(a-b-c+d)=d-b$$\n\n$$\\iff \\boxed{p_o=\\frac{d-b}{a-b-c+d}}$$\n\n::: {#d1888c05 .cell message='false' execution_count=19}\n``` {.python .cell-code}\nimport numpy as np\nimport random\nfrom lets_plot import *\n\nrandom.seed(12)\n\nwhile True:\n    A = random.randint(0, 9)\n    a = random.randint(0, 9)\n    B = random.randint(0, 9)\n    b = random.randint(0, 9)\n    C = random.randint(0, 9)\n    c = random.randint(0, 9)\n    D = random.randint(0, 9)\n    d = random.randint(0, 9)\n\n    # Bedingungen prüfen: Keine dominante Strategien\n    cond1 = (A >= B) and (C >= D)\n    cond2 = (B >= A) and (D >= C)\n    cond3 = (a >= c) and (b >= d)\n    cond4 = (c >= a) and (d >= b)\n\n    # Wenn keine Bedingung erfüllt ist, Schleife beenden\n    if not (cond1 or cond2 or cond3 or cond4):\n        break\n\nplot = create_plot()\n\nplot\n\n\n\n# Funktionen für Nash-Bedingungen\ndef is_ol_nash(A, B, a, c):\n  return \"ol\" if (A >= B) and (a >= c) else \"not_ol\"\n\ndef is_ul_nash(B, A, b, d):\n  return \"ul\" if (B >= A) and (b >= d) else \"not_ul\"\n\ndef is_or_nash(C, D, c, a):\n  return \"or\" if (C >= D) and (c >= a) else \"not_or\"\n\ndef is_ur_nash(D, C, d, b):\n  return \"ur\" if (D >= C) and (d >= b) else \"not_ur\"\n\n# Nash-Bedingungen überprüfen und Strings zuweisen\nCand_Nash_ol = is_ol_nash(A, B, a, c)\nCand_Nash_ul = is_ul_nash(B, A, b, d)\nCand_Nash_or = is_or_nash(C, D, c, a)\nCand_Nash_ur = is_ur_nash(D, C, d, b)\n\n# Ergebnisse kombinieren und NAs entfernen\nNash_GG = np.array([Cand_Nash_ol, Cand_Nash_ul, Cand_Nash_or, Cand_Nash_ur])\nNash_GG_filtered = []\nfor element in Nash_GG:\n  if element == \"ol\" or element == \"ul\" or element == \"or\" or element == \"ur\":\n    Nash_GG_filtered.append(element)\n\n\n\n# Ergebnis ausgeben\nif Nash_GG_filtered == []:\n   print('Es gibt kein Nash-Gleichgewicht in reinen Strategien')\n\nelse:\n   print(f\"Nash-Gleichgewicht(e) in reinen Strategien: {', '.join(Nash_GG_filtered)}\")\n\n\n\n# Anzahl der Nash GG\n\n#Anzahl_NGG=len(Nash_GG_filtered)\n#print(Anzahl_NGG)\n\n# Wahrscheinlichkeiten ausrechnen.\n# Dabei jeweils den Fall Division duch 0 aussschließen\n\n#p_l\nif (A - B - C + D)!=0: p_l = ( D-C)/(A - B - C + D)\n\n#print(round(p_l, 2))\n\n#p_o\nif (-b + d)/(a - b - c + d)!=0: p_o = (-b + d)/(a - b - c + d)\n\n#print(round(p_o, 2))\n\n\n# Ausgabe Abhängig von Bedingungen\n\nif (#Anzahl_NGG == 1 or\n    p_o < 0 or p_l < 0 or\n            p_o > 1 or p_l > 1 or\n            (a - b - c + d) == 0 or\n            (A - B - C + D) == 0):\n    print(\"Kein Nash-Gleichgewicht in gemischten Strategien\")\nelse:   print(f\"Gemischte Strategien: p_o= {round(p_o, 2)}, p_l= {round(p_l, 2)}\")\n```\n\n::: {.cell-output .cell-output-display}\n```{=html}\n\n            <div id=\"0meGR0\"></div>\n            <script type=\"text/javascript\" data-lets-plot-script=\"library\">\n                if(!window.letsPlotCallQueue) {\n                    window.letsPlotCallQueue = [];\n                }; \n                window.letsPlotCall = function(f) {\n                    window.letsPlotCallQueue.push(f);\n                };\n                (function() {\n                    var script = document.createElement(\"script\");\n                    script.type = \"text/javascript\";\n                    script.src = \"https://cdn.jsdelivr.net/gh/JetBrains/lets-plot@v4.6.2/js-package/distr/lets-plot.min.js\";\n                    script.onload = function() {\n                        window.letsPlotCall = function(f) {f();};\n                        window.letsPlotCallQueue.forEach(function(f) {f();});\n                        window.letsPlotCallQueue = [];\n                        \n                    };\n                    script.onerror = function(event) {\n                        window.letsPlotCall = function(f) {};    // noop\n                        window.letsPlotCallQueue = [];\n                        var div = document.createElement(\"div\");\n                        div.style.color = 'darkred';\n                        div.textContent = 'Error loading Lets-Plot JS';\n                        document.getElementById(\"0meGR0\").appendChild(div);\n                    };\n                    var e = document.getElementById(\"0meGR0\");\n                    e.appendChild(script);\n                })()\n            </script>\n            \n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nEs gibt kein Nash-Gleichgewicht in reinen Strategien\nGemischte Strategien: p_o= 0.64, p_l= 0.62\n```\n:::\n:::\n\n\n::: {#b569adbc .cell execution_count=20}\n``` {.python .cell-code}\n# Wahrscheinlichkeiten ausrechnen\n\nfrom sympy import Symbol, solve, Eq\n\nsymbols = [Symbol(name) for name in 'ABCDabcdp']\nA, B, C, D, a, b, c, d, p = symbols  # Auspacken in verschiedene Variablen\n\n\n#p_l\nE_o= p*A+(1-p)*C\n\nE_u= p*B  + (1-p)*D\n\nsol = solve(Eq(E_o, E_u), p)\nprint(sol)\n\n#p_o\n\nE_l = p*a + (1-p)*b\nE_r = p*c + (1-p)*d\n\nsol = solve(Eq(E_l, E_r),p)\nprint(sol)\n```\n:::\n\n\n## Sequenzielle Spiele\n\nSpieler spielen nacheinander. Dabei kann man die Fälle unterscheiden, dass die Spieler ihre vorherigen Züge sehen können oder nicht oder unvollständig. Man kann ebenso die Fälle unterscheiden, dass sie die Auszahlungen der Mitspieler kennen oder nicht oder unvollständig informiert sind.\n\n### Vollständige Information\n\nAnnahme: Alle Spieler kennen alle Auszahlungen und sehen alle bislang erfolgten Spielzüge\n\nDarstellung des Spiels mittels eines Spielbaums. Die Benennung der Auszahlungen mit $A,a$ für oben rechts usw. folgt der Darstellung für simultane Spiele.\n\n![Grundstruktur eines Spielbaums](figure/Baum-Grundstruktur-1.png){width=\"50%\"}\n\n#### Rückwärtsinduktion\n\nSequenzielle Spiele wereden \t&bdquo;von hinten nach vorn&ldquo; gelöst. Man löst zunächst alle Entscheidungen der Vorrunde, dann die der Runde davor usw. Auf diese Weise vollzieht man nach, dass rationale Spieler die rationalen Entscheidungen ihrer Mitspieler antizipieren. \n\n##### Beispiele\n\n![Beispiel für Rückwärtsinduktion](figure/Baum-Rückwärtsinduktion-a-1.png){width=\"50%\"}\n\n![Beispiel für Rückwärtsinduktion](figure/Baum-Rückwärtsinduktion-b-1.png){width=\"50%\"}\n\n##### Bedingungen für ein Nash-Gleichgewicht\n\nZunächst vereinfachende Annahme: $a\\neq c\\ \\text{und}\\ b \\neq d$\n\n\n**ol**: $a>c \\land ((A>B\\ \\land\\ b>d) \\lor (A>D\\ \\land\\ d>b))$\n\n**or**: $c>a  \\land ((C>D\\ \\land d>b) \\lor (C>B\\ \\land b> d))$\n\n**ul**: $b>d \\land ((B>A \\land a>c)\\lor(B>C \\land c>a))$\n\n**ur**: $d>b \\land ((D>A \\land a>c)\\lor (D>C \\land c>a))$\n\n::: {#ceca0052 .cell execution_count=21}\n``` {.python .cell-code}\nimport numpy as np\nimport random\n\nrandom.seed(123) # Für reproduzierbare Ergebnisse ggf. fixieren\n\n# Zufällige Ganzzahlen zwischen 0 und 9 generieren\n#A = random.randint(0, 9)\n#B = random.randint(0, 9)\n#C = random.randint(0, 9)\n#D = random.randint(0, 9)\n#a = random.randint(0, 9)\n#b = random.randint(0, 9)\n#c = random.randint(0, 9)\n#d = random.randint(0, 9)\n\n#A = 1\n#B = 0\n#C = 0\n#D = 0\n#a = 1\n#b = 0\n#c = 0\n#d = 0\n\n# Zufallszahlen, aber alle unterschiedlich\nchoices = np.arange(10)\n\n# Generate unique random integers for variables\nParameter = np.random.choice(choices, size=8, replace=False)\nA, B, C, D, a, b, c, d = Parameter\n\n\n# Formatierte Bimatrix ausgeben\n#print(\"    l   r\")\n#print(f\"o  {A},{a}  {C},{c}\")\n#print(f\"u  {B},{b}  {D},{d}\")\n\n\n# Spielbaum ausgeben\n\nprint(f\" ol: {A}, {a}\\n or: {C}, {c}\\n ul: {B}, {b}\\n ur: {D}, {d}\")\n\n# Funktionen für Nash-Bedingungen\n# Spieler 2 (a) entscheidet l/r, Spieler 1 (A) entscheidet o/u\ndef is_ol_nash(A, B, D, a, b, c, d):\n  return \"ol\" if ((a > c) and ((A>= B and b> d) or\n              (A >= D and d>=b))) else \"not_ol\"\n\ndef is_or_nash( B, C, D, a, b, c, d):\n  return \"or\" if (c>a and ((C>= B and b>=d) or\n              (C >= D and d>b))) else \"not_or\"\n\n\ndef is_ul_nash(A, B, C,  a, b, c, d):\n  return \"ul\" if (b>=d and ((B>= A and a>= c) or\n              (B >= C and c>=a))) else \"not_ul\"\n\n\ndef is_ur_nash(A,  C, D, a, b, c, d):\n  return \"ur\" if (d>=b and ((D>= A and a>= c) or\n              (D >= C and c>=a))) else \"not_ur\"\n\n\n# Nash-Bedingungen überprüfen und Strings zuweisen\n\nCand_Nash_ol = is_ol_nash(A, B,    D, a, b, c, d)\nCand_Nash_or = is_or_nash(   B, C, D, a, b, c, d)\nCand_Nash_ul = is_ul_nash(A, B, C,    a, b, c, d)\nCand_Nash_ur = is_ur_nash(A,    C, D, a, b, c, d)\n\n# Ergebnisse kombinieren und NAs entfernen\nNash_GG = np.array([Cand_Nash_ol, Cand_Nash_ul, Cand_Nash_or, Cand_Nash_ur])\nNash_GG_filtered = []\nfor element in Nash_GG:\n  if element == \"ol\" or element == \"or\" or element == \"ul\" or element == \"ur\":\n    Nash_GG_filtered.append(element)\n\n# Ergebnis ausgeben\nprint(Nash_GG_filtered)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n ol: 5, 3\n or: 9, 4\n ul: 0, 1\n ur: 6, 8\n[np.str_('or')]\n```\n:::\n:::\n\n\n#### Teilspielperfektheit\n\n-   Teilspielperfektheit verlangt, dass jeder Spieler jeden Zug so ausführt, dass das Ergebnis des Zuges seinen Interessen nicht schadet.\n\n-   Ein Teilspiel beginnt in einem Knoten und enthält alle nachfolgenden Knoten\n\n-   Für später: Ein Teilspiel darf nachfolgende Informationsmengen nicht teilen. Es gehören also immer alle Knoten einer Informationsmenge zu einem Teilspiel\n\nBeispiel: Unglaubwürdige Drohung\n\n![Unglaubwürdige Drohung](figure/Baum-Unglaubwürdige-Drohung-1.png){width=\"50%\"}\n\n\nHier: Tafelaufschrieb Markteintrittsspiel\n\n#### Selbstbindung\n\nHier: [Sonderabbildung Weltvernichtungsbombe aus @Winter-Spieltheorie](https://neo.hfwu.de/sendfile.php?force_download=1&type=0&file_id=c47cc228ea9b922bd29c873be1980fa3&file_name=Baum_Weltvernichtung_komplett.pdf)\n\n- Automatisierung der Drohung erzeugt erwünschte Glaubwürdigkeit\n\n- Aber: Automatisierung ist riskant, wenn Fehler möglich sind.\n\n- Trembling Hand Überlegungen\n\n::: {#8361b65c .cell message='false' execution_count=22}\n``` {.python .cell-code}\n# Python\n\nA= 1\na= 1\nB= -1\nb= -1\nC= 1\nc= 1\nD= 2\nd= 0\n\n\nfrom lets_plot import *\n\nLetsPlot.setup_html()\n\nggplot() + \\\ngeom_text(x=- .5, y= 2   , label=a) +\\\ngeom_text(x=-1.5, y=  .75, label=A) +\\\ngeom_text(x=- .5, y=-1   , label=b) +\\\ngeom_text(x=-1.5, y=-2.25, label=B) +\\\ngeom_text(x= 1.5, y= 2   , label=c) +\\\ngeom_text(x=  .5, y=  .75, label=C) +\\\ngeom_text(x= 1.5, y=-1   , label=d) +\\\ngeom_text(x=  .5, y=-2.25, label=D) +\\\ngeom_text(x=-1  , y= 3.3 , label='automatische Bombe')+\\\ngeom_text(x= 1  , y= 3.3 , label='nichtautomatische Bombe')+\\\ngeom_text(x=-2.2, y= 1.375, angle=90, label='Kein Angriff')+\\\ngeom_text(x=-2.2, y=-1.625, angle=90, label='Angriff')+\\\ngeom_text(x= 0 , y= 4 ,\n          fontface = \"bold\", label='UdSSR')+\\\ngeom_text(x=-2.7 , y= 0 , angle=90,\n          fontface = \"bold\", label='USA')+\\\ngeom_segment(x=-2,  xend= 2, y= 0, yend= 0) +\\\ngeom_segment(x=-2,  xend= 2, y= 3, yend= 3) +\\\ngeom_segment(x=-2,  xend= 2, y=-3, yend=-3) +\\\ngeom_segment(x=-2,  xend=-2, y=-3, yend= 3) +\\\ngeom_segment(x= 0,  xend= 0, y=-3, yend= 3) +\\\ngeom_segment(x= 2,  xend= 2, y=-3, yend= 3) +\\\ntheme_void()+\\\nlabs(title='Auszahlungen im Szenario mit Weltvernichtungsbombe')\n```\n\n::: {.cell-output .cell-output-display}\n```{=html}\n\n            <div id=\"drfXAr\"></div>\n            <script type=\"text/javascript\" data-lets-plot-script=\"library\">\n                if(!window.letsPlotCallQueue) {\n                    window.letsPlotCallQueue = [];\n                }; \n                window.letsPlotCall = function(f) {\n                    window.letsPlotCallQueue.push(f);\n                };\n                (function() {\n                    var script = document.createElement(\"script\");\n                    script.type = \"text/javascript\";\n                    script.src = \"https://cdn.jsdelivr.net/gh/JetBrains/lets-plot@v4.6.2/js-package/distr/lets-plot.min.js\";\n                    script.onload = function() {\n                        window.letsPlotCall = function(f) {f();};\n                        window.letsPlotCallQueue.forEach(function(f) {f();});\n                        window.letsPlotCallQueue = [];\n                        \n                    };\n                    script.onerror = function(event) {\n                        window.letsPlotCall = function(f) {};    // noop\n                        window.letsPlotCallQueue = [];\n                        var div = document.createElement(\"div\");\n                        div.style.color = 'darkred';\n                        div.textContent = 'Error loading Lets-Plot JS';\n                        document.getElementById(\"drfXAr\").appendChild(div);\n                    };\n                    var e = document.getElementById(\"drfXAr\");\n                    e.appendChild(script);\n                })()\n            </script>\n            \n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=18}\n```{=html}\n   <div id=\"63O7Ph\"></div>\n   <script type=\"text/javascript\" data-lets-plot-script=\"plot\">\n   \n   (function() {\n   // ----------\n   \n   const forceImmediateRender = false;\n   const responsive = false;\n   \n   let sizing = {\n       width_mode: \"MIN\",\n       height_mode: \"SCALED\",\n       width: null, \n       height: null \n   };\n   \n   const preferredWidth = document.body.dataset.letsPlotPreferredWidth;\n   if (preferredWidth !== undefined) {\n       sizing = {\n           width_mode: 'FIXED',\n           height_mode: 'SCALED',\n           width: parseFloat(preferredWidth)\n       };\n   }\n   \n   const containerDiv = document.getElementById(\"63O7Ph\");\n   let fig = null;\n   \n   function renderPlot() {\n       if (fig === null) {\n           const plotSpec = {\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"theme\":{\n\"name\":\"classic\",\n\"line\":\"blank\",\n\"axis\":\"blank\"\n},\n\"ggtitle\":{\n\"text\":\"Auszahlungen im Szenario mit Weltvernichtungsbombe\"\n},\n\"kind\":\"plot\",\n\"scales\":[],\n\"layers\":[{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-0.5,\n\"y\":2.0,\n\"label\":1.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-1.5,\n\"y\":0.75,\n\"label\":1.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-0.5,\n\"y\":-1.0,\n\"label\":-1.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-1.5,\n\"y\":-2.25,\n\"label\":-1.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":1.5,\n\"y\":2.0,\n\"label\":1.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":0.5,\n\"y\":0.75,\n\"label\":1.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":1.5,\n\"y\":-1.0,\n\"label\":0.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":0.5,\n\"y\":-2.25,\n\"label\":2.0,\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-1.0,\n\"y\":3.3,\n\"label\":\"automatische Bombe\",\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":1.0,\n\"y\":3.3,\n\"label\":\"nichtautomatische Bombe\",\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.2,\n\"y\":1.375,\n\"angle\":90.0,\n\"label\":\"Kein Angriff\",\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.2,\n\"y\":-1.625,\n\"angle\":90.0,\n\"label\":\"Angriff\",\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":0.0,\n\"y\":4.0,\n\"fontface\":\"bold\",\n\"label\":\"UdSSR\",\n\"data\":{\n}\n},{\n\"geom\":\"text\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.7,\n\"y\":0.0,\n\"angle\":90.0,\n\"fontface\":\"bold\",\n\"label\":\"USA\",\n\"data\":{\n}\n},{\n\"geom\":\"segment\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.0,\n\"xend\":2.0,\n\"y\":0.0,\n\"yend\":0.0,\n\"data\":{\n}\n},{\n\"geom\":\"segment\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.0,\n\"xend\":2.0,\n\"y\":3.0,\n\"yend\":3.0,\n\"data\":{\n}\n},{\n\"geom\":\"segment\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.0,\n\"xend\":2.0,\n\"y\":-3.0,\n\"yend\":-3.0,\n\"data\":{\n}\n},{\n\"geom\":\"segment\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":-2.0,\n\"xend\":-2.0,\n\"y\":-3.0,\n\"yend\":3.0,\n\"data\":{\n}\n},{\n\"geom\":\"segment\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":0.0,\n\"xend\":0.0,\n\"y\":-3.0,\n\"yend\":3.0,\n\"data\":{\n}\n},{\n\"geom\":\"segment\",\n\"mapping\":{\n},\n\"data_meta\":{\n},\n\"x\":2.0,\n\"xend\":2.0,\n\"y\":-3.0,\n\"yend\":3.0,\n\"data\":{\n}\n}],\n\"metainfo_list\":[],\n\"spec_id\":\"9\"\n};\n           window.letsPlotCall(function() { fig = LetsPlot.buildPlotFromProcessedSpecs(plotSpec, containerDiv, sizing); });\n       } else {\n           fig.updateView({});\n       }\n   }\n   \n   const renderImmediately = \n       forceImmediateRender || (\n           sizing.width_mode === 'FIXED' && \n           (sizing.height_mode === 'FIXED' || sizing.height_mode === 'SCALED')\n       );\n   \n   if (renderImmediately) {\n       renderPlot();\n   }\n   \n   if (!renderImmediately || responsive) {\n       // Set up observer for initial sizing or continuous monitoring\n       var observer = new ResizeObserver(function(entries) {\n           for (let entry of entries) {\n               if (entry.contentBoxSize && \n                   entry.contentBoxSize[0].inlineSize > 0) {\n                   if (!responsive && observer) {\n                       observer.disconnect();\n                       observer = null;\n                   }\n                   renderPlot();\n                   if (!responsive) {\n                       break;\n                   }\n               }\n           }\n       });\n       \n       observer.observe(containerDiv);\n   }\n   \n   // ----------\n   })();\n   \n   </script>\n```\n:::\n:::\n\n\n- Zwei Nash-Gleichgewichte\n\n- Zunächst das Gleichgewicht oben links\n\n- Wie ist es einzuschätzen, wenn beide Spieler mit einer Wahrscheinlichkeit $p_i$ mit $i \\in (\\text{USA, UdSSR})$ einen Fehler machen?\n\n**Kalkül der USA:**\n\n$E_{kA}=(1-p_{\\text{UdSSR}}) 1 + p_{\\text{UdSSR}} 1 =1$\n\n$E_A=(1-p_{\\text{UdSSR}}) (-1) + p_{\\text{UdSSR}} 2$\n\n$=-1 + p_{\\text{UdSSR}} +2 p_{\\text{UdSSR}}=-1+ 3 p_{\\text{UdSSR}}$\n\n$E_{kA}\\geq E_A$\n\n$1\\geq -1+ 3 p_{\\text{UdSSR}}$\n\n$\\iff p_{\\text{UdSSR}} \\leq \\frac{2}{3}$\n\n\n**Kalkül der UdSSR**\n\n$E_{aB}=(1-p_{\\text{USA}}) 1 + p_{\\text{USA}} (-1) = 1-2p_{\\text{USA}}$\n\n$E_{naB}= (1-p_{\\text{USA}}) 1 + p_{\\text{USA}} 0 = 1-p_{\\text{USA}}$\n\n$E_{aB} \\geq E_{naB}$\n\n$1-2p_{\\text{USA}} \\geq 1-p_{\\text{USA}}$\n\n$\\iff p_{\\text{USA}} \\leq 0$\n\n\n$\\rightarrow$ das Gleichgewicht ist nicht trembling-Hand-perfekt\n\nWie sieht es mit dem anderen Gleichgewichht aus? \n\nProbieren Sie es aus!\n\n$E_A=$\n\n$E_{kA}=$\n\n### Unvollständige Information\n\n#### Alles beobachtbar, aber Auszahlungen für Spieler 1 u/o 2 können gleich sein\n\n![Auszahlungen von Spieler 1 sind gleich](figure/Baum-Gleiche-Auszahlungen-S1-1.png){width=\"50%\"}\n\n$\\rightarrow$ Spieler 1 muss sich irgendwie entscheiden, aber Spieler 2 kann die Entscheidung sehen.\n\n$\\rightarrow$ Unproblematischer Fall\n\n![Auszahlungen von Spieler 2 sind gleich](figure/Baum-Gleiche-Auszahlungen-S2-1.png){width=\"50%\"}\n\n$\\rightarrow$ Spieler 1 kann nicht antizipieren, was Spieler 2 im Fall \"unten\" macht. \n\n$\\rightarrow$ Kriterium für Entscheidung unter Risiko\n\nMögliche Kriterien:\n\n- **Erwartungswert**\n- Erwartungsnutzen\n- Maximin\n- $\\dots$\n\nHier unterstellt: Erwartungswertkriterium\n\nDie Bedingungen für ein Nash-Gleichgewicht bei sequenziellen Spielen lauten dann:\n\n\n[ja wie?]::\n\n\n**ol**: $a>c \\land ((A\\geq B\\ \\land\\ b \\geq d) \\lor (A \\geq  D\\ \\land\\ d \\geq b) ) \\lor a=c \\land ((b>d \\land (\\frac{A+C}{2} \\geq B)\\lor (d>b \\land \\frac{A+C}{2}\\geq D) \\lor (b=d \\land(\\frac{A+C}{2}\\geq \\frac{B+D}{2})))$\n\n**or**: $c>a  \\land ((C>D\\ \\land d>b) \\lor (C>B\\ \\land b> d)) \\lor a=c \\land ((b>d \\land (\\frac{A+C}{2} \\geq B)\\lor (d>b \\land \\frac{A+C}{2}\\geq D) \\lor (b=d \\land(\\frac{A+C}{2}\\geq \\frac{B+D}{2})))$\n\n**ul**: $b>d \\land ((B>A \\land a>c)\\lor(B>C \\land c>a))\\lor b=d \\land ((a>c \\land (\\frac{B+D}{2} \\geq A)\\lor (c>a \\land \\frac{B+D}{2}\\geq C) \\lor (b=d \\land(\\frac{B+D}{2}\\geq \\frac{A+C}{2})))$\n\n**ur**: $d>b \\land ((D>A \\land a>c)\\lor (D>C \\land c>a))\\lor b=d \\land ((a>c \\land (\\frac{B+D}{2} \\geq A)\\lor (c>a \\land \\frac{B+D}{2}\\geq C) \\lor (b=d \\land(\\frac{B+D}{2}\\geq \\frac{A+C}{2})))$\n\n\n#### Zug von Spieler 1 ist für Spieler 2 unsichtbar\n\nDurch eine gestrichelte Linie im Spielbaum werdn die Knoten verbunden, die ein Spieler nicht voneinander unterscheiden kann. Die spielende Person weiß also nicht, ob sie sich in dem einen Knoten am einen Ende der gestrichelten Linie befindet oder am anderen Ende.\n\n\n![Baum Zug 1 unsichtbar ](figure/Baum-Zug1-unsichtbar-1.png)\n- Fehlende Information ist für Spieler 2 kein Problem, wenn er eine dominante Alternative hat oder wenn alle Auszahlungen für ihn gleich sind.\n\n- Fehlende Information für Spieler 2 ist auch kein Problem, wenn Spieler 1 eine dominante Alternative hat.\n\n- Wenn Information nicht vorliegt, Entscheidungskriterium unter Risiko nutzen. Hier: Erwartungswert\n\n\n#### Typ von Spieler 1 (und damit die Menge seiner Auszahlungen) ist für Spieler 2 unsichtbar\n\n\ns. Tafelaufschrieb\n\nGrundsätzlich zwei verschiedene Typen von Gleichgewichten:\n\n- Separierende Gleichgewichte: Spieler 1 offenbart durch seine Entscheidung, von welchem Typ er ist\n\n- Pooling Gleichgewichte: Man kann kann aus dem Handeln des Spielers 1 nicht auf seinen Typ schließen\n\n![Typ Spieler 1 unsichtbar](figure/Baum-Typ-unsichtbar-1.png) \n\n\n[## Koalitionsspiele]::\n\n## Evolutionäre Spiele\n\n[https://eckhartarnold.de/papers/2009_Vorlesung_Entscheidungstheorie/node127.html]:\n\n### Idee\n\n### Erfolg von Strategien\n[Tournaments]:\n\n\n### Evolution von Strategien\n[Simulationen,  Kriterien für stabile Strategien]::\n\n### Diskussion und Ausblick\n\n",
    "supporting": [
      "Spieltheorie_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}